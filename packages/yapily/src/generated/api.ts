/* tslint:disable */
/* eslint-disable */
/**
 * Yapily API
 * The Yapily API enables connections between your application and users\' banks. For more information check out our [documentation](https://docs.yapily.com/).<br><br>In particular, make sure to view our [Getting Started](https://docs.yapily.com/pages/home/getting-started/) steps if this is your first time here.<br><br>While testing the API, our list of [sandbox credentials](https://docs.yapily.com/pages/key-concepts/sandbox-credentials/) maybe useful.
 *
 * The version of the OpenAPI document: 2.30.1
 * Contact: support@yapily.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier of the account.
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Specifies the type of account e.g. (BUSINESS_CURRENT).
     * @type {string}
     * @memberof Account
     */
    'type'?: string;
    /**
     * Product name as defined by the financial institution for this account
     * @type {string}
     * @memberof Account
     */
    'description'?: string;
    /**
     * Main / headline balance for the account. <br><br> Use of this field is recommended as fallback only. Instead, use of the typed balances (accountBalances) is recommended.
     * @type {number}
     * @memberof Account
     */
    'balance'?: number;
    /**
     * Currency the bank account balance is denoted in. <br><br> Specified as a 3-letter ISO 4217 currency code
     * @type {string}
     * @memberof Account
     */
    'currency'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof Account
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {AccountType}
     * @memberof Account
     */
    'accountType'?: AccountType;
    /**
     * Nickname of the account that was provided by the account owner. <br><br> May be used to aid identification of the account.
     * @type {string}
     * @memberof Account
     */
    'nickname'?: string;
    /**
     * Supplementary specifications that might be provided by the Bank. These provide further characteristics about the account.
     * @type {string}
     * @memberof Account
     */
    'details'?: string;
    /**
     * 
     * @type {Array<AccountName>}
     * @memberof Account
     */
    'accountNames'?: Array<AccountName>;
    /**
     * 
     * @type {Set<AccountIdentification>}
     * @memberof Account
     */
    'accountIdentifications'?: Set<AccountIdentification>;
    /**
     * 
     * @type {Array<AccountBalance>}
     * @memberof Account
     */
    'accountBalances'?: Array<AccountBalance>;
    /**
     * 
     * @type {ConsolidatedAccountInformation}
     * @memberof Account
     */
    'consolidatedAccountInformation'?: ConsolidatedAccountInformation;
}


/**
 * 
 * @export
 * @interface AccountApiListResponse
 */
export interface AccountApiListResponse {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof AccountApiListResponse
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountApiListResponse
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AccountApiListResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof AccountApiListResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof AccountApiListResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListAccount}
     * @memberof AccountApiListResponse
     */
    'paging'?: FilteredClientPayloadListAccount;
    /**
     * 
     * @type {string}
     * @memberof AccountApiListResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface AccountAuthorisationRequest
 */
export interface AccountAuthorisationRequest {
    /**
     * `User` for which the authorisation request was created.
     * @type {string}
     * @memberof AccountAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. User-friendly identifier of the `User` that provides authorisation. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof AccountAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof AccountAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof AccountAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user completes the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof AccountAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof AccountAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof AccountAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {AccountRequest}
     * @memberof AccountAuthorisationRequest
     */
    'accountRequest'?: AccountRequest;
}
/**
 * 
 * @export
 * @interface AccountAuthorisationResponse
 */
export interface AccountAuthorisationResponse {
    /**
     * Unique identifier for the account authorisation request.<br><br>The `consentID` used to [retrieve a consent](/api/reference/#operation/getConsentById).
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'id'?: string;
    /**
     * The `User` that the authorisation request was created for.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'userUuid'?: string;
    /**
     * The user-friendly reference to the `User` that the authorisation request was created for.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'referenceId'?: string;
    /**
     * The `Institution` the authorisation request was sent to.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof AccountAuthorisationResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time the consent was created.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'transactionTo'?: string;
    /**
     * Date and time the authorisation expires. Re-authorisation is needed to retain access.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountAuthorisationResponse
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'timeToExpire'?: string;
    /**
     * The set of features the consent provides access to.
     * @type {Set<FeatureEnum>}
     * @memberof AccountAuthorisationResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to access account information.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'consentToken'?: string;
    /**
     * Correlation ID used with the `Institution` during the authorisation process.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'state'?: string;
    /**
     * Date and time the request was authorised by the `Institution`.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'authorizedAt'?: string;
    /**
     * The time the PSU last confirmed access to their account information, either through full authentication with the institution, or through reconfirmation with the TPP.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'lastConfirmedAt'?: string;
    /**
     * The date and time the consent must be reconfirmed by to ensure continued access to the account information.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'reconfirmBy'?: string;
    /**
     * Unique identifier of the consent assigned by the `Institution`.
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'authorisationUrl'?: string;
    /**
     * The URL link for the QR code that may be scanned via a mobile device to make an authorisation redirect to the bank (authURL encoded).
     * @type {string}
     * @memberof AccountAuthorisationResponse
     */
    'qrCodeUrl'?: string;
}


/**
 * 
 * @export
 * @interface AccountBalance
 */
export interface AccountBalance {
    /**
     * 
     * @type {AccountBalanceType}
     * @memberof AccountBalance
     */
    'type'?: AccountBalanceType;
    /**
     * Date and time of the reported balance.
     * @type {string}
     * @memberof AccountBalance
     */
    'dateTime'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof AccountBalance
     */
    'balanceAmount'?: Amount;
    /**
     * _Optional_. Indicates whether any credit lines are included in the balance.
     * @type {boolean}
     * @memberof AccountBalance
     */
    'creditLineIncluded'?: boolean;
    /**
     * _Optional_. Specifies the type of balance.
     * @type {Array<CreditLine>}
     * @memberof AccountBalance
     */
    'creditLines'?: Array<CreditLine>;
}


/**
 * Specifies the type of the stated account balance.
 * @export
 * @enum {string}
 */

export const AccountBalanceType = {
    ClosingAvailable: 'CLOSING_AVAILABLE',
    ClosingBooked: 'CLOSING_BOOKED',
    ClosingCleared: 'CLOSING_CLEARED',
    Expected: 'EXPECTED',
    ForwardAvailable: 'FORWARD_AVAILABLE',
    Information: 'INFORMATION',
    InterimAvailable: 'INTERIM_AVAILABLE',
    InterimBooked: 'INTERIM_BOOKED',
    InterimCleared: 'INTERIM_CLEARED',
    OpeningAvailable: 'OPENING_AVAILABLE',
    OpeningBooked: 'OPENING_BOOKED',
    OpeningCleared: 'OPENING_CLEARED',
    PreviouslyClosedBooked: 'PREVIOUSLY_CLOSED_BOOKED',
    Authorised: 'AUTHORISED',
    Other: 'OTHER',
    Unknown: 'UNKNOWN'
} as const;

export type AccountBalanceType = typeof AccountBalanceType[keyof typeof AccountBalanceType];


/**
 * 
 * @export
 * @interface AccountIdentification
 */
export interface AccountIdentification {
    /**
     * 
     * @type {AccountIdentificationType}
     * @memberof AccountIdentification
     */
    'type': AccountIdentificationType;
    /**
     * __Mandatory__. The value associated with the account identification type.<br><br> See [Account Identification Combinations](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#account-identifications-combinations) for more information on the format of the values.
     * @type {string}
     * @memberof AccountIdentification
     */
    'identification': string;
}


/**
 * 
 * @export
 * @interface AccountIdentificationResponse
 */
export interface AccountIdentificationResponse {
    /**
     * 
     * @type {AccountIdentificationTypeResponse}
     * @memberof AccountIdentificationResponse
     */
    'type'?: AccountIdentificationTypeResponse;
    /**
     * The value associated with the account identification type.<br><br> See [Account Identification Combinations](https://docs.yapily.com/pages/payments/payments-resources/intro-to-payment-execution/#account-identifications-combinations) for more information on the format of the values.
     * @type {string}
     * @memberof AccountIdentificationResponse
     */
    'identification'?: string;
}


/**
 * __Mandatory__. Used to describe the format of the account.<br><br> See [Account Identification Combinations](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#account-identifications-combinations) for more information on when to specify each type.
 * @export
 * @enum {string}
 */

export const AccountIdentificationType = {
    SortCode: 'SORT_CODE',
    AccountNumber: 'ACCOUNT_NUMBER',
    Iban: 'IBAN',
    Bban: 'BBAN',
    Bic: 'BIC',
    Pan: 'PAN',
    MaskedPan: 'MASKED_PAN',
    Msisdn: 'MSISDN',
    Bsb: 'BSB',
    Ncc: 'NCC',
    Aba: 'ABA',
    AbaWire: 'ABA_WIRE',
    AbaAch: 'ABA_ACH',
    Email: 'EMAIL',
    RollNumber: 'ROLL_NUMBER',
    Blz: 'BLZ',
    Ifs: 'IFS',
    Clabe: 'CLABE',
    Ctn: 'CTN',
    BranchCode: 'BRANCH_CODE',
    VirtualAccountId: 'VIRTUAL_ACCOUNT_ID'
} as const;

export type AccountIdentificationType = typeof AccountIdentificationType[keyof typeof AccountIdentificationType];


/**
 * Used to describe the format of the account.<br><br> See [Account Identification Combinations](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#account-identifications-combinations) for more information.
 * @export
 * @enum {string}
 */

export const AccountIdentificationTypeResponse = {
    SortCode: 'SORT_CODE',
    AccountNumber: 'ACCOUNT_NUMBER',
    Iban: 'IBAN',
    Bban: 'BBAN',
    Bic: 'BIC',
    Pan: 'PAN',
    MaskedPan: 'MASKED_PAN',
    Msisdn: 'MSISDN',
    Bsb: 'BSB',
    Ncc: 'NCC',
    Aba: 'ABA',
    AbaWire: 'ABA_WIRE',
    AbaAch: 'ABA_ACH',
    Email: 'EMAIL',
    RollNumber: 'ROLL_NUMBER',
    Blz: 'BLZ',
    Ifs: 'IFS',
    Clabe: 'CLABE',
    Ctn: 'CTN',
    BranchCode: 'BRANCH_CODE',
    VirtualAccountId: 'VIRTUAL_ACCOUNT_ID'
} as const;

export type AccountIdentificationTypeResponse = typeof AccountIdentificationTypeResponse[keyof typeof AccountIdentificationTypeResponse];


/**
 * __Conditional__. Used to create a request for the balance of the account specified. Once the user authorises the request, only the balance can be obtained by executing [GET Account Balances](./#get-account-balances).<br><br> This can be specified in conjunction with `accountIdentifiersForTransaction` to generate a `Consent` that can both access the accounts balance and transactions.
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * __Conditional__. Unique identifier of the account.
     * @type {string}
     * @memberof AccountInfo
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountIdentification}
     * @memberof AccountInfo
     */
    'accountIdentification': AccountIdentification;
}
/**
 * 
 * @export
 * @interface AccountName
 */
export interface AccountName {
    /**
     * The bank account holder\'s name given by the account owner.
     * @type {string}
     * @memberof AccountName
     */
    'name'?: string;
}
/**
 * __Conditional__. Used to further specify details of the `Consent` to request <br><br>Conditions:<ol><li>Mandatory to specify the individual scopes to request from the user at the `Institution` for an account authorisation</li><li>Mandatory to specify an expiry time on the created `Consent` at which time will render it unusable</li><li>Mandatory to specify the date range that the created `Consent` will be able to access transactions for (given the range is support for the `Institution`)</li></ol>
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * __Optional__. Specifies the earliest date of the transaction records to be returned.<br><br> You must supply this field to retrieve transactions older than 90 days for banks accessed via the the [CBI Globe Gateway](https://docs.yapily.com/pages/data/financial-data-resources/data-restrictions/#cbi-globe-gateway).
     * @type {string}
     * @memberof AccountRequest
     */
    'transactionFrom'?: string;
    /**
     * __Optional__. Specifies the latest date of the transaction records to be returned.
     * @type {string}
     * @memberof AccountRequest
     */
    'transactionTo'?: string;
    /**
     * __Optional__. Used to set a hard date for when the user\'s associated `Consent` will expire.<br><br>**Note**: If this supported by the bank, specifying this is property is opting out of having a long-lived consent that can be perpetually re-authorised by the user. This will add an `expiresAt` field on the `Consent` object which will render it unusable after this date.<br><br>**Note**: This is not supported by every `Institution`. In such case, the request will not fail but the property will be ignored and the created `Consent` will not have an expiry date.
     * @type {string}
     * @memberof AccountRequest
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {AccountInfo}
     * @memberof AccountRequest
     */
    'accountIdentifiers'?: AccountInfo;
    /**
     * __Conditional__. Used to create a request for the transactions of the account specified. Once the user authorises the request, only the transactions can be obtained by executing [GET Account Transactions](./#get-account-transactions). <br><br>This can be specified in conjunction with `accountIdentifiersForBalance` to generate a `Consent` that can both access the accounts balance and transactions.
     * @type {Array<AccountInfo>}
     * @memberof AccountRequest
     */
    'accountIdentifiersForTransaction'?: Array<AccountInfo>;
    /**
     * __Conditional__. Used to create a request for the balance of the account specified. Once the user authorises the request, only the balance can be obtained by executing [GET Account Balances](./#get-account-balances).<br><br> This can be specified in conjunction with `accountIdentifiersForTransaction` to generate a `Consent` that can both access the accounts balance and transactions.
     * @type {Array<AccountInfo>}
     * @memberof AccountRequest
     */
    'accountIdentifiersForBalance'?: Array<AccountInfo>;
    /**
     * __Optional__. Used to granularly specify the set of features that the user will give their consent for when requesting access to their account information. Depending on the `Institution`, this may also populate a consent screen which list these scopes before the user authorises.<br><br>This endpoint accepts allow all [Financial Data Features](/guides/financial-data/features/#feature-list) that the `Institution` supports.To find out which scopes an `Institution` supports, check [GET Institution](./#get-institution).
     * @type {Set<FeatureEnum>}
     * @memberof AccountRequest
     */
    'featureScope'?: Set<FeatureEnum>;
}
/**
 * Statement information belonging to the account.
 * @export
 * @interface AccountStatement
 */
export interface AccountStatement {
    /**
     * Unique identifier for the statement.
     * @type {string}
     * @memberof AccountStatement
     */
    'id'?: string;
    /**
     * Date and time of when the statement period starts.
     * @type {string}
     * @memberof AccountStatement
     */
    'startDateTime'?: string;
    /**
     * Date and time of when the statement period ends.
     * @type {string}
     * @memberof AccountStatement
     */
    'endDateTime'?: string;
    /**
     * Date and time of when the statement was created.
     * @type {string}
     * @memberof AccountStatement
     */
    'creationDateTime'?: string;
}
/**
 * The type of account e.g. (Credit Card, Savings).
 * @export
 * @enum {string}
 */

export const AccountType = {
    CashTrading: 'CASH_TRADING',
    CashIncome: 'CASH_INCOME',
    CashPayment: 'CASH_PAYMENT',
    ChargeCard: 'CHARGE_CARD',
    Charges: 'CHARGES',
    Commission: 'COMMISSION',
    CreditCard: 'CREDIT_CARD',
    Current: 'CURRENT',
    EMoney: 'E_MONEY',
    LimitedLiquiditySavingsAccount: 'LIMITED_LIQUIDITY_SAVINGS_ACCOUNT',
    Loan: 'LOAN',
    MarginalLending: 'MARGINAL_LENDING',
    MoneyMarket: 'MONEY_MARKET',
    Mortgage: 'MORTGAGE',
    NonResidentExternal: 'NON_RESIDENT_EXTERNAL',
    Other: 'OTHER',
    Overdraft: 'OVERDRAFT',
    OvernightDeposit: 'OVERNIGHT_DEPOSIT',
    PrepaidCard: 'PREPAID_CARD',
    Salary: 'SALARY',
    Savings: 'SAVINGS',
    Settlement: 'SETTLEMENT',
    Tax: 'TAX',
    Unknown: 'UNKNOWN'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * __Conditional__. The address of the `Payee` or `Payer`.<ul><li>`payee.address` is mandatory when the `paymentType` is an `INTERNATIONAL` payment</li><li>An `Institution` may require you to specify the `country` when used in the context of the `Payee` to be able to make a payment.</li></ul>
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * __Optional__. The address line of the address
     * @type {Array<string>}
     * @memberof Address
     */
    'addressLines'?: Array<string>;
    /**
     * __Optional__. The street name of the address
     * @type {string}
     * @memberof Address
     */
    'streetName'?: string;
    /**
     * __Optional__. The building number of the address
     * @type {string}
     * @memberof Address
     */
    'buildingNumber'?: string;
    /**
     * __Optional__. The post code of the address
     * @type {string}
     * @memberof Address
     */
    'postCode'?: string;
    /**
     * __Optional__. The town name of the address
     * @type {string}
     * @memberof Address
     */
    'townName'?: string;
    /**
     * __Optional__. The list of counties for the address
     * @type {Array<string>}
     * @memberof Address
     */
    'county'?: Array<string>;
    /**
     * __Conditional__. The 2-letter country code for the address. <br><br>An `Institution` may require you to specify the `country` when used in the context of the `Payee` to be able to make a payment
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * __Optional__. The department for the address
     * @type {string}
     * @memberof Address
     */
    'department'?: string;
    /**
     * __Optional__. The sub-department for the address
     * @type {string}
     * @memberof Address
     */
    'subDepartment'?: string;
    /**
     * 
     * @type {AddressTypeEnum}
     * @memberof Address
     */
    'addressType'?: AddressTypeEnum;
}


/**
 * 
 * @export
 * @interface AddressDetails
 */
export interface AddressDetails {
    /**
     * Information, in free format text, that identifies a specific address.
     * @type {string}
     * @memberof AddressDetails
     */
    'addressLine'?: string;
}
/**
 * The address of the `Payee` or `Payer`.
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * The address line of the address
     * @type {Array<string>}
     * @memberof AddressResponse
     */
    'addressLines'?: Array<string>;
    /**
     * The street name of the address
     * @type {string}
     * @memberof AddressResponse
     */
    'streetName'?: string;
    /**
     * The building number of the address
     * @type {string}
     * @memberof AddressResponse
     */
    'buildingNumber'?: string;
    /**
     * The post code of the address
     * @type {string}
     * @memberof AddressResponse
     */
    'postCode'?: string;
    /**
     * The town name of the address
     * @type {string}
     * @memberof AddressResponse
     */
    'townName'?: string;
    /**
     * The list of counties for the address
     * @type {Array<string>}
     * @memberof AddressResponse
     */
    'county'?: Array<string>;
    /**
     * The 2-letter country code for the address.
     * @type {string}
     * @memberof AddressResponse
     */
    'country'?: string;
    /**
     * The department for the address
     * @type {string}
     * @memberof AddressResponse
     */
    'department'?: string;
    /**
     * The sub-department for the address
     * @type {string}
     * @memberof AddressResponse
     */
    'subDepartment'?: string;
    /**
     * 
     * @type {AddressTypeEnumResponse}
     * @memberof AddressResponse
     */
    'addressType'?: AddressTypeEnumResponse;
}


/**
 * __Optional__. The type of address
 * @export
 * @enum {string}
 */

export const AddressTypeEnum = {
    Business: 'BUSINESS',
    Correspondence: 'CORRESPONDENCE',
    DeliveryTo: 'DELIVERY_TO',
    MailTo: 'MAIL_TO',
    PoBox: 'PO_BOX',
    Postal: 'POSTAL',
    Residential: 'RESIDENTIAL',
    Statement: 'STATEMENT',
    Unknown: 'UNKNOWN'
} as const;

export type AddressTypeEnum = typeof AddressTypeEnum[keyof typeof AddressTypeEnum];


/**
 * The type of address
 * @export
 * @enum {string}
 */

export const AddressTypeEnumResponse = {
    Business: 'BUSINESS',
    Correspondence: 'CORRESPONDENCE',
    DeliveryTo: 'DELIVERY_TO',
    MailTo: 'MAIL_TO',
    PoBox: 'PO_BOX',
    Postal: 'POSTAL',
    Residential: 'RESIDENTIAL',
    Statement: 'STATEMENT',
    Unknown: 'UNKNOWN'
} as const;

export type AddressTypeEnumResponse = typeof AddressTypeEnumResponse[keyof typeof AddressTypeEnumResponse];


/**
 * __Mandatory__. Period alignment for which the payment limits are enforced. Allowed values are [CONSENT, CALENDAR]. If CONSENT, then period starts on consent creation date. If CALENDAR, then period lines up with the frequency e.g. WEEKLY period will begin at start of the week in question.
 * @export
 * @enum {string}
 */

export const AlignmentEnum = {
    Consent: 'CONSENT',
    Calendar: 'CALENDAR'
} as const;

export type AlignmentEnum = typeof AlignmentEnum[keyof typeof AlignmentEnum];


/**
 * __Mandatory__. Monetary Amount.
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * __Mandatory__. The monetary value
     * @type {number}
     * @memberof Amount
     */
    'amount': number;
    /**
     * __Mandatory__. The [ISO 4217](https://www.xe.com/iso4217.php) currency code
     * @type {string}
     * @memberof Amount
     */
    'currency': string;
}
/**
 * Monetary Amount.
 * @export
 * @interface AmountDetailsResponse
 */
export interface AmountDetailsResponse {
    /**
     * The monetary value
     * @type {number}
     * @memberof AmountDetailsResponse
     */
    'amount'?: number;
    /**
     * The [ISO 4217](https://www.xe.com/iso4217.php) currency code
     * @type {string}
     * @memberof AmountDetailsResponse
     */
    'currency'?: string;
}
/**
 * Provides details of the error that has occurred.
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * _Mandatory_. Numeric `HTTP` status code associated with the error.
     * @type {number}
     * @memberof ApiError
     */
    'code'?: number;
    /**
     * 
     * @type {InstitutionError}
     * @memberof ApiError
     */
    'institutionError'?: InstitutionError;
    /**
     * __Mandatory__. Description of the exact error that has been experienced.
     * @type {string}
     * @memberof ApiError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'source'?: string;
    /**
     * __Mandatory__. Textual description of the `HTTP` error status type.
     * @type {string}
     * @memberof ApiError
     */
    'status'?: string;
    /**
     * _Optional_.  A unique identifier assigned by Yapily for the request that can be used for support purposes.
     * @type {string}
     * @memberof ApiError
     */
    'tracingId'?: string;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof ApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof ApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * 
 * @export
 * @interface ApiListOfApplicationResponse
 */
export interface ApiListOfApplicationResponse {
    /**
     * 
     * @type {ApplicationResponseListMeta}
     * @memberof ApiListOfApplicationResponse
     */
    'meta'?: ApplicationResponseListMeta;
    /**
     * 
     * @type {Array<ApplicationResponse>}
     * @memberof ApiListOfApplicationResponse
     */
    'data'?: Array<ApplicationResponse>;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfAccountStatement
 */
export interface ApiListResponseOfAccountStatement {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfAccountStatement
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<AccountStatement>}
     * @memberof ApiListResponseOfAccountStatement
     */
    'data'?: Array<AccountStatement>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfAccountStatement
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfAccountStatement
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfAccountStatement
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListAccountStatement}
     * @memberof ApiListResponseOfAccountStatement
     */
    'paging'?: FilteredClientPayloadListAccountStatement;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfAccountStatement
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfBeneficiary
 */
export interface ApiListResponseOfBeneficiary {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfBeneficiary
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Beneficiary>}
     * @memberof ApiListResponseOfBeneficiary
     */
    'data'?: Array<Beneficiary>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfBeneficiary
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfBeneficiary
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfBeneficiary
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfBeneficiary
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfCategory
 */
export interface ApiListResponseOfCategory {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfCategory
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ApiListResponseOfCategory
     */
    'data'?: Array<Category>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfCategory
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfCategory
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfCategory
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListCategory}
     * @memberof ApiListResponseOfCategory
     */
    'paging'?: FilteredClientPayloadListCategory;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfCategory
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfConsent
 */
export interface ApiListResponseOfConsent {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfConsent
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Consent>}
     * @memberof ApiListResponseOfConsent
     */
    'data'?: Array<Consent>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfConsent
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfConsent
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfConsent
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListConsent}
     * @memberof ApiListResponseOfConsent
     */
    'paging'?: FilteredClientPayloadListConsent;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfConsent
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfDataConstraints
 */
export interface ApiListResponseOfDataConstraints {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiListResponseOfDataConstraints
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Array<DataConstraintsResponse>}
     * @memberof ApiListResponseOfDataConstraints
     */
    'data'?: Array<DataConstraintsResponse>;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfDirectDebitResponse
 */
export interface ApiListResponseOfDirectDebitResponse {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<DirectDebitResponse>}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'data'?: Array<DirectDebitResponse>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListDirectDebitResponse}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'paging'?: FilteredClientPayloadListDirectDebitResponse;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfDirectDebitResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfEventSubscriptionResponse
 */
export interface ApiListResponseOfEventSubscriptionResponse {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<EventSubscriptionResponse>}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'data'?: Array<EventSubscriptionResponse>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListTransaction}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'paging'?: FilteredClientPayloadListTransaction;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfEventSubscriptionResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfFeatureDetails
 */
export interface ApiListResponseOfFeatureDetails {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<FeatureDetails>}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'data'?: Array<FeatureDetails>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListFeatureDetails}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'paging'?: FilteredClientPayloadListFeatureDetails;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfFeatureDetails
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfInstitution
 */
export interface ApiListResponseOfInstitution {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfInstitution
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Institution>}
     * @memberof ApiListResponseOfInstitution
     */
    'data'?: Array<Institution>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfInstitution
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfInstitution
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfInstitution
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListInstitution}
     * @memberof ApiListResponseOfInstitution
     */
    'paging'?: FilteredClientPayloadListInstitution;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfInstitution
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfPaymentConstraints
 */
export interface ApiListResponseOfPaymentConstraints {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfPaymentConstraints
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<PaymentConstraintsResponse>}
     * @memberof ApiListResponseOfPaymentConstraints
     */
    'data'?: Array<PaymentConstraintsResponse>;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfPaymentResponse
 */
export interface ApiListResponseOfPaymentResponse {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<PaymentResponse>}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'data'?: Array<PaymentResponse>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListPaymentResponse}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'paging'?: FilteredClientPayloadListPaymentResponse;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfPaymentResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfRealTimeTransaction
 */
export interface ApiListResponseOfRealTimeTransaction {
    /**
     * 
     * @type {ResponseMetaWithCount}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'meta'?: ResponseMetaWithCount;
    /**
     * 
     * @type {Array<RealTimeTransaction>}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'data'?: Array<RealTimeTransaction>;
    /**
     * 
     * @type {ApiListResponseOfRealTimeTransactionLinks}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'links'?: ApiListResponseOfRealTimeTransactionLinks;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransaction
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfRealTimeTransactionLinks
 */
export interface ApiListResponseOfRealTimeTransactionLinks {
    /**
     * A cursor or link to the first page in the data set.
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransactionLinks
     */
    'first'?: string;
    /**
     * A cursor or link to the previous page in the data set.
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransactionLinks
     */
    'prev'?: string;
    /**
     * A cursor or link to the current page in the data set.
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransactionLinks
     */
    'self'?: string;
    /**
     * A cursor or link to the next page in the data set.
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransactionLinks
     */
    'next'?: string;
    /**
     * A cursor or link to the last page in the data set.
     * @type {string}
     * @memberof ApiListResponseOfRealTimeTransactionLinks
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfTransaction
 */
export interface ApiListResponseOfTransaction {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfTransaction
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof ApiListResponseOfTransaction
     */
    'data'?: Array<Transaction>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiListResponseOfTransaction
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfTransaction
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiListResponseOfTransaction
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {FilteredClientPayloadListTransaction}
     * @memberof ApiListResponseOfTransaction
     */
    'paging'?: FilteredClientPayloadListTransaction;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfTransaction
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccount
 */
export interface ApiListResponseOfVirtualAccount {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfVirtualAccount
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Links}
     * @memberof ApiListResponseOfVirtualAccount
     */
    'links'?: Links;
    /**
     * 
     * @type {Array<VirtualAccount>}
     * @memberof ApiListResponseOfVirtualAccount
     */
    'data'?: Array<VirtualAccount>;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfVirtualAccount
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccount
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccountBeneficiary
 */
export interface ApiListResponseOfVirtualAccountBeneficiary {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfVirtualAccountBeneficiary
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Links}
     * @memberof ApiListResponseOfVirtualAccountBeneficiary
     */
    'links'?: Links;
    /**
     * 
     * @type {Array<VirtualAccountBeneficiary>}
     * @memberof ApiListResponseOfVirtualAccountBeneficiary
     */
    'data'?: Array<VirtualAccountBeneficiary>;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfVirtualAccountBeneficiary
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccountBeneficiary
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccountClient
 */
export interface ApiListResponseOfVirtualAccountClient {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfVirtualAccountClient
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Array<VirtualAccountClient>}
     * @memberof ApiListResponseOfVirtualAccountClient
     */
    'data'?: Array<VirtualAccountClient>;
    /**
     * 
     * @type {Links}
     * @memberof ApiListResponseOfVirtualAccountClient
     */
    'links'?: Links;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfVirtualAccountClient
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccountClient
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccountPayment
 */
export interface ApiListResponseOfVirtualAccountPayment {
    /**
     * 
     * @type {ResponseListMeta}
     * @memberof ApiListResponseOfVirtualAccountPayment
     */
    'meta'?: ResponseListMeta;
    /**
     * 
     * @type {Links}
     * @memberof ApiListResponseOfVirtualAccountPayment
     */
    'links'?: Links;
    /**
     * 
     * @type {Array<VirtualAccountPayment>}
     * @memberof ApiListResponseOfVirtualAccountPayment
     */
    'data'?: Array<VirtualAccountPayment>;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfVirtualAccountPayment
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccountPayment
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccountRefund
 */
export interface ApiListResponseOfVirtualAccountRefund {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiListResponseOfVirtualAccountRefund
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {ApiListResponseOfVirtualAccountRefundLinks}
     * @memberof ApiListResponseOfVirtualAccountRefund
     */
    'links'?: ApiListResponseOfVirtualAccountRefundLinks;
    /**
     * 
     * @type {Array<VirtualAccountRefund>}
     * @memberof ApiListResponseOfVirtualAccountRefund
     */
    'data'?: Array<VirtualAccountRefund>;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiListResponseOfVirtualAccountRefund
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccountRefund
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiListResponseOfVirtualAccountRefundLinks
 */
export interface ApiListResponseOfVirtualAccountRefundLinks {
    /**
     * 
     * @type {string}
     * @memberof ApiListResponseOfVirtualAccountRefundLinks
     */
    'next'?: string;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/reference/#tag/Financial-Data) and any [Payments](https://docs.yapily.com/api/reference/#tag/Payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/reference/#operation/addUser)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/reference/#tag/Financial-Data) and any [Payments](https://docs.yapily.com/api/reference/#tag/Payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface ApiResponseError
 */
export interface ApiResponseError {
    /**
     * 
     * @type {ApiError}
     * @memberof ApiResponseError
     */
    'error'?: ApiError;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof ApiResponseError
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseError
     */
    'raw'?: Array<RawResponse>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfAccount
 */
export interface ApiResponseOfAccount {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfAccount
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Account}
     * @memberof ApiResponseOfAccount
     */
    'data'?: Account;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfAccount
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfAccount
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfAccount
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfAccount
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfAccountAuthorisationResponse
 */
export interface ApiResponseOfAccountAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {AccountAuthorisationResponse}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'data'?: AccountAuthorisationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfAccountAuthorisationResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfAccountStatement
 */
export interface ApiResponseOfAccountStatement {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfAccountStatement
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {AccountStatement}
     * @memberof ApiResponseOfAccountStatement
     */
    'data'?: AccountStatement;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfAccountStatement
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfAccountStatement
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfAccountStatement
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfAccountStatement
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfApplicationResponse
 */
export interface ApiResponseOfApplicationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfApplicationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {ApplicationResponse}
     * @memberof ApiResponseOfApplicationResponse
     */
    'data'?: ApplicationResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseOfBalances
 */
export interface ApiResponseOfBalances {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfBalances
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Balances}
     * @memberof ApiResponseOfBalances
     */
    'data'?: Balances;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfBalances
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfBalances
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfBalances
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfBalances
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfConsent
 */
export interface ApiResponseOfConsent {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfConsent
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Consent}
     * @memberof ApiResponseOfConsent
     */
    'data'?: Consent;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfConsent
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfConsent
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfConsent
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfConsent
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfConsentDeleteResponse
 */
export interface ApiResponseOfConsentDeleteResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {ConsentDeleteResponse}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'data'?: ConsentDeleteResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfConsentDeleteResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfCreateHostedPaymentRequest
 */
export interface ApiResponseOfCreateHostedPaymentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfCreateHostedPaymentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedPaymentRequestResponse}
     * @memberof ApiResponseOfCreateHostedPaymentRequest
     */
    'data'?: HostedPaymentRequestResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseOfCreateHostedPaymentRequestLink
 */
export interface ApiResponseOfCreateHostedPaymentRequestLink {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfCreateHostedPaymentRequestLink
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedPaymentRequestResponse}
     * @memberof ApiResponseOfCreateHostedPaymentRequestLink
     */
    'data'?: HostedPaymentRequestResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseOfCreateHostedVRPConsentRequest
 */
export interface ApiResponseOfCreateHostedVRPConsentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfCreateHostedVRPConsentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedVRPConsentRequestResponse}
     * @memberof ApiResponseOfCreateHostedVRPConsentRequest
     */
    'data'?: HostedVRPConsentRequestResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseOfCreateHostedVRPPaymentRequest
 */
export interface ApiResponseOfCreateHostedVRPPaymentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfCreateHostedVRPPaymentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedVRPPaymentResponse}
     * @memberof ApiResponseOfCreateHostedVRPPaymentRequest
     */
    'data'?: HostedVRPPaymentResponse;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfCreateHostedVRPPaymentRequest
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfEmbeddedAccountAuthorisationResponse
 */
export interface ApiResponseOfEmbeddedAccountAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {EmbeddedAccountAuthorisationResponse}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'data'?: EmbeddedAccountAuthorisationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfEmbeddedAccountAuthorisationResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfEventSubscriptionDeleteResponse
 */
export interface ApiResponseOfEventSubscriptionDeleteResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {EventSubscriptionDeleteResponse}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'data'?: EventSubscriptionDeleteResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfEventSubscriptionDeleteResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfEventSubscriptionResponse
 */
export interface ApiResponseOfEventSubscriptionResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {EventSubscriptionResponse}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'data'?: EventSubscriptionResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfEventSubscriptionResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfFinancialProfile
 */
export interface ApiResponseOfFinancialProfile {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFinancialProfile
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {FinancialProfile}
     * @memberof ApiResponseOfFinancialProfile
     */
    'data'?: FinancialProfile;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFinancialProfile
     */
    'links'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApiResponseOfFinancialProfileAuthorisationResponse
 */
export interface ApiResponseOfFinancialProfileAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFinancialProfileAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Array<ProfileConsent>}
     * @memberof ApiResponseOfFinancialProfileAuthorisationResponse
     */
    'data'?: Array<ProfileConsent>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFinancialProfileAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApiResponseOfFinancialProfileBalancePrediction
 */
export interface ApiResponseOfFinancialProfileBalancePrediction {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFinancialProfileBalancePrediction
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {BalancePredictionProfile}
     * @memberof ApiResponseOfFinancialProfileBalancePrediction
     */
    'data'?: BalancePredictionProfile;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFinancialProfileBalancePrediction
     */
    'links'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApiResponseOfFinancialProfileConsent
 */
export interface ApiResponseOfFinancialProfileConsent {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFinancialProfileConsent
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {ProfileConsent}
     * @memberof ApiResponseOfFinancialProfileConsent
     */
    'data'?: ProfileConsent;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFinancialProfileConsent
     */
    'links'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApiResponseOfFinancialProfileConsentRemoveResponse
 */
export interface ApiResponseOfFinancialProfileConsentRemoveResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFinancialProfileConsentRemoveResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFinancialProfileConsentRemoveResponse
     */
    'links'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ApiResponseOfFundsConfirmationResponse
 */
export interface ApiResponseOfFundsConfirmationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {FundsConfirmationResponse}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'data'?: FundsConfirmationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'tracingId'?: string;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfFundsConfirmationResponse
     */
    'raw'?: Array<RawResponse>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfGetHostedPaymentRequest
 */
export interface ApiResponseOfGetHostedPaymentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfGetHostedPaymentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedPaymentDetails}
     * @memberof ApiResponseOfGetHostedPaymentRequest
     */
    'data'?: HostedPaymentDetails;
}
/**
 * 
 * @export
 * @interface ApiResponseOfGetHostedVRPConsentRequest
 */
export interface ApiResponseOfGetHostedVRPConsentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfGetHostedVRPConsentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedVRPConsentDetails}
     * @memberof ApiResponseOfGetHostedVRPConsentRequest
     */
    'data'?: HostedVRPConsentDetails;
}
/**
 * 
 * @export
 * @interface ApiResponseOfGetHostedVRPConsentsRequest
 */
export interface ApiResponseOfGetHostedVRPConsentsRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfGetHostedVRPConsentsRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Array<GetHostedVRPConsentsResponseInner>}
     * @memberof ApiResponseOfGetHostedVRPConsentsRequest
     */
    'data'?: Array<GetHostedVRPConsentsResponseInner>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfGetHostedVRPPaymentRequest
 */
export interface ApiResponseOfGetHostedVRPPaymentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfGetHostedVRPPaymentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedVRPPaymentResponse}
     * @memberof ApiResponseOfGetHostedVRPPaymentRequest
     */
    'data'?: HostedVRPPaymentResponse;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfGetHostedVRPPaymentRequest
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfIdentity
 */
export interface ApiResponseOfIdentity {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfIdentity
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {Identity}
     * @memberof ApiResponseOfIdentity
     */
    'data'?: Identity;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfIdentity
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfIdentity
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfIdentity
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfIdentity
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfNonSweepingAuthorisationResponse
 */
export interface ApiResponseOfNonSweepingAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {NonSweepingAuthorisationResponse}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'data'?: NonSweepingAuthorisationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'tracingId'?: string;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfNonSweepingAuthorisationResponse
     */
    'raw'?: Array<RawResponse>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfPaymentAuthorisationRequestResponse
 */
export interface ApiResponseOfPaymentAuthorisationRequestResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {PaymentAuthorisationRequestResponse}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'data'?: PaymentAuthorisationRequestResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfPaymentAuthorisationRequestResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
 */
export interface ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {PaymentEmbeddedAuthorisationRequestResponse}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'data'?: PaymentEmbeddedAuthorisationRequestResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfPaymentResponse
 */
export interface ApiResponseOfPaymentResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfPaymentResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {PaymentResponse}
     * @memberof ApiResponseOfPaymentResponse
     */
    'data'?: PaymentResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfPaymentResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfPaymentResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfPaymentResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfPaymentResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfPaymentResponses
 */
export interface ApiResponseOfPaymentResponses {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfPaymentResponses
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {PaymentResponses}
     * @memberof ApiResponseOfPaymentResponses
     */
    'data'?: PaymentResponses;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfPaymentResponses
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfPaymentResponses
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfPaymentResponses
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfPaymentResponses
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfPreAuthorisationResponse
 */
export interface ApiResponseOfPreAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {PreAuthorisationResponse}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'data'?: PreAuthorisationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfPreAuthorisationResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfRevokeHostedVRPConsentRequest
 */
export interface ApiResponseOfRevokeHostedVRPConsentRequest {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfRevokeHostedVRPConsentRequest
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {HostedVRPConsentDetails}
     * @memberof ApiResponseOfRevokeHostedVRPConsentRequest
     */
    'data'?: HostedVRPConsentDetails;
}
/**
 * 
 * @export
 * @interface ApiResponseOfSubmissionResponse
 */
export interface ApiResponseOfSubmissionResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {SubmissionResponse}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'data'?: SubmissionResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'tracingId'?: string;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfSubmissionResponse
     */
    'raw'?: Array<RawResponse>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfSweepingAuthorisationResponse
 */
export interface ApiResponseOfSweepingAuthorisationResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {SweepingAuthorisationResponse}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'data'?: SweepingAuthorisationResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'tracingId'?: string;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfSweepingAuthorisationResponse
     */
    'raw'?: Array<RawResponse>;
}
/**
 * 
 * @export
 * @interface ApiResponseOfUserDeleteResponse
 */
export interface ApiResponseOfUserDeleteResponse {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {UserDeleteResponse}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'data'?: UserDeleteResponse;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {Array<RawResponse>}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'raw'?: Array<RawResponse>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfUserDeleteResponse
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccount
 */
export interface ApiResponseOfVirtualAccount {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccount
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {VirtualAccount}
     * @memberof ApiResponseOfVirtualAccount
     */
    'data'?: VirtualAccount;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccount
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccount
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccountBeneficiary
 */
export interface ApiResponseOfVirtualAccountBeneficiary {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccountBeneficiary
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {VirtualAccountBeneficiary}
     * @memberof ApiResponseOfVirtualAccountBeneficiary
     */
    'data'?: VirtualAccountBeneficiary;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccountBeneficiary
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccountBeneficiary
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccountClient
 */
export interface ApiResponseOfVirtualAccountClient {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccountClient
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {VirtualAccountClient}
     * @memberof ApiResponseOfVirtualAccountClient
     */
    'data'?: VirtualAccountClient;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccountClient
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccountClient
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccountPayInDetails
 */
export interface ApiResponseOfVirtualAccountPayInDetails {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccountPayInDetails
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiResponseOfVirtualAccountPayInDetails
     */
    'links'?: { [key: string]: string; };
    /**
     * 
     * @type {VirtualAccountPayInDetails}
     * @memberof ApiResponseOfVirtualAccountPayInDetails
     */
    'data'?: VirtualAccountPayInDetails;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccountPayInDetails
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccountPayInDetails
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccountPayment
 */
export interface ApiResponseOfVirtualAccountPayment {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccountPayment
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {VirtualAccountPayment}
     * @memberof ApiResponseOfVirtualAccountPayment
     */
    'data'?: VirtualAccountPayment;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccountPayment
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccountPayment
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseOfVirtualAccountRefund
 */
export interface ApiResponseOfVirtualAccountRefund {
    /**
     * 
     * @type {ResponseMeta}
     * @memberof ApiResponseOfVirtualAccountRefund
     */
    'meta'?: ResponseMeta;
    /**
     * 
     * @type {VirtualAccountRefund}
     * @memberof ApiResponseOfVirtualAccountRefund
     */
    'data'?: VirtualAccountRefund;
    /**
     * 
     * @type {Array<ResponseForwardedData>}
     * @memberof ApiResponseOfVirtualAccountRefund
     */
    'forwardedData'?: Array<ResponseForwardedData>;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseOfVirtualAccountRefund
     */
    'tracingId'?: string;
}
/**
 * Information about the application.
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * Unique identification for the `Application` as assigned by Yapily.
     * @type {string}
     * @memberof Application
     */
    'uuid'?: string;
    /**
     * The individual name of the `Application`.
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
    /**
     * States whether an `Application` is active.
     * @type {boolean}
     * @memberof Application
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Application
     */
    'authCallbacks'?: Array<string>;
    /**
     * 
     * @type {Set<Institution>}
     * @memberof Application
     */
    'institutions'?: Set<Institution>;
    /**
     * 
     * @type {Set<Media>}
     * @memberof Application
     */
    'media'?: Set<Media>;
    /**
     * Date and time of when the application was created.
     * @type {string}
     * @memberof Application
     */
    'created'?: string;
    /**
     * Date and time of when the application was last updated.
     * @type {string}
     * @memberof Application
     */
    'updated'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * The name of the application
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
    /**
     * The ISO-18245 merchant category code of the merchant the application is being created for.<br><br>Allowed values:<ul><li>`0742` (Veterinary Services)</li><li>`0763` (Agricultural Cooperatives)</li><li>`0780` (Landscaping and Horticultural Services)</li><li>`1520` (General Contractor/Residential Building)</li><li>`1711` (Heating, Plumbing, Air Conditioning Contractors)</li><li>`1731` (Electrical Contractors)</li><li>`1740` (Masonry, Stonework, Tile Setting, Plastering, Insulation Contractors)</li><li>`1750` (Carpentry)</li><li>`1761` (Roof, Siding, and Sheet Metal Work Contractors)</li><li>`1771` (Contractors, Concrete)</li><li>`1799` (Special Trade Contractor - Not Elsewhere Classified)</li><li>`2741` (Miscellaneous Publishing and Printing Services)</li><li>`2791` (Typesetting, Plate Making and Related Services (Business to Business MCC))</li><li>`2842` (Specialty Cleaning, Polishing and Sanitation Preparations (Business to Business MCC))</li><li>`3000` (United Airlines)</li><li>`3001` (American Airlines)</li><li>`3002` (Pan American)</li><li>`3003` (Eurofly Airlines)</li><li>`3004` (Dragon Airlines)</li><li>`3005` (British Airways)</li><li>`3006` (Japan Air Lines)</li><li>`3007` (Air France)</li><li>`3008` (Lufthansa)</li><li>`3009` (Air Canada)</li><li>`3010` (KLM)</li><li>`3011` (AeroFlot)</li><li>`3012` (Qantas)</li><li>`3013` (Alitalia)</li><li>`3014` (Saudi Arabian Airlines)</li><li>`3015` (SWISS)</li><li>`3016` (SAS)</li><li>`3017` (South African Airway)</li><li>`3018` (Varig (Brazil))</li><li>`3020` (Air India)</li><li>`3021` (Air Algerie)</li><li>`3022` (PAL AIR)</li><li>`3023` (Mexicana)</li><li>`3024` (Pakistan International)</li><li>`3025` (Air New Zealand Ltd.)</li><li>`3026` (Emirates Airlines)</li><li>`3027` (UTA/InterAir)</li><li>`3028` (Air Malta)</li><li>`3029` (SN Brussels Airlines - SN BRUSSELS)</li><li>`3030` (Aerolineas Argentinas)</li><li>`3031` (Olympic Airways)</li><li>`3032` (El Al)</li><li>`3033` (Ansett Airlines)</li><li>`3034` (ETIHADAIR)</li><li>`3035` (TAP (Portugal))</li><li>`3036` (VASP (Brazil))</li><li>`3037` (EgyptAir)</li><li>`3038` (Kuwait Airways)</li><li>`3039` (Avianca)</li><li>`3040` (GulfAir (Bahrain))</li><li>`3041` (Balkan-Bulgarian)</li><li>`3042` (FinnAir)</li><li>`3043` (Aer Lingus)</li><li>`3044` (Air Lanka)</li><li>`3045` (Nigeria Airways)</li><li>`3046` (Cruzeiro do Sul (Bra))</li><li>`3047` (THY (Turkey))</li><li>`3048` (Royal Air Maroc)</li><li>`3049` (Tunis Air)</li><li>`3050` (Icelandair)</li><li>`3051` (Austrian Airlines)</li><li>`3052` (LANAIR)</li><li>`3053` (AVIACO (Spain))</li><li>`3054` (Ladeco (Chile))</li><li>`3055` (LAB (Bolivia))</li><li>`3056` (JetAir)</li><li>`3057` (Virgin America  VIR AMER)</li><li>`3058` (Delta)</li><li>`3059` (DBA Airlines-DBA AIR)</li><li>`3060` (NWA Air)</li><li>`3061` (Continental)</li><li>`3062` (Hapag-Lloyd Express - HLX)</li><li>`3063` (US Airways)</li><li>`3064` (Adria Airways)</li><li>`3065` (Airinter (AirInternational))</li><li>`3066` (Southwest)</li><li>`3068` (AIR STANA)</li><li>`3069` (Sun Country Air)</li><li>`3070` (Pacific Southwest Airlines (PSA))</li><li>`3071` (Air British Columbia)</li><li>`3072` (CEBU PAC)</li><li>`3073` (Air Cal)</li><li>`3075` (Singapore Airlines)</li><li>`3076` (Aeromexico)</li><li>`3077` (Thai Airways)</li><li>`3078` (China Airlines)</li><li>`3079` (Jetstar Airways - Jetstar)</li><li>`3081` (NordAir)</li><li>`3082` (Korean Airlines)</li><li>`3083` (Air Afrique)</li><li>`3084` (Eva Airlines)</li><li>`3085` (Midwest Express Airlines, Inc)</li><li>`3087` (Metro Airlines)</li><li>`3088` (Croatia Airlines)</li><li>`3089` (Tans Saero)</li><li>`3090` (Uni Airways)</li><li>`3094` (Zambia Airways)</li><li>`3096` (Air Zimbabwe)</li><li>`3097` (Spanair (abbreviation: SPANAIR))</li><li>`3098` (Asiana Airlines)</li><li>`3099` (Cathay Pacific)</li><li>`3100` (Malaysian Airline Sys)</li><li>`3102` (Iberia)</li><li>`3103` (Garuda (Indonesia))</li><li>`3105` (Piedmont)</li><li>`3106` (Braathens S.A.F.E. (Norway))</li><li>`3110` (Wings Airways)</li><li>`3111` (British Midland)</li><li>`3112` (Windward Island)</li><li>`3117` (Venezolana Int de Aviacion)</li><li>`3118` (Valley Airlines)</li><li>`3125` (Tan Airlines)</li><li>`3126` (Talair PTY Ltd.)</li><li>`3127` (Taca International)</li><li>`3129` (Surinam Airways)</li><li>`3130` (Sunworld International Airways)</li><li>`3131` (VLM Air)</li><li>`3132` (Frontier Airlines)</li><li>`3133` (Sunbelt Airlines)</li><li>`3135` (Sudan Airlines)</li><li>`3136` (Qatar Air)</li><li>`3137` (Singleton)</li><li>`3138` (Simmons Airlines)</li><li>`3141` (Seair Alaska)</li><li>`3143` (Scenic Airlines)</li><li>`3144` (Virgin Atlantic)</li><li>`3145` (San Juan)</li><li>`3146` (Luxair)</li><li>`3148` (Air Littoral SA)</li><li>`3151` (Air Laire)</li><li>`3154` (Princeville)</li><li>`3156` (Go Fly)</li><li>`3159` (PBA-Provincetwn-Bstn Air)</li><li>`3161` (All Nippon Airways)</li><li>`3164` (Norontair)</li><li>`3165` (New York Helicopter)</li><li>`3167` (Aero Continente - AEROCONTINENTE)</li><li>`3170` (Mount Cook)</li><li>`3171` (Canadian Airlines)</li><li>`3172` (Nation Air)</li><li>`3174` (JetBlue Airways)</li><li>`3175` (Middle East Air)</li><li>`3176` (Metroflight Airlines)</li><li>`3177` (AirTran Airways)</li><li>`3178` (Mesa Air)</li><li>`3180` (Westjet Airlines-WESTJET)</li><li>`3181` (Malev Hungarian Airlines)</li><li>`3182` (LOT (Poland))</li><li>`3183` (Oman Aviation - OMAN AIR)</li><li>`3184` (LIAT)</li><li>`3185` (LAV (Venezuela))</li><li>`3186` (LAP (Paraguay))</li><li>`3187` (LACSA (Costa Rica))</li><li>`3188` (Virgin Express - VIR EXP)</li><li>`3190` (Jugoslav Air)</li><li>`3191` (Island Airlines)</li><li>`3192` (Iran Air)</li><li>`3193` (Indian Airlines)</li><li>`3195` (Holiday Airlines)</li><li>`3196` (Hawaiian Air)</li><li>`3197` (Havasu Airlines)</li><li>`3198` (Harbor Airlines)</li><li>`3199` (Servicios Aereos Militares)</li><li>`3200` (Guyana Airways)</li><li>`3203` (Golden Pacific Air)</li><li>`3204` (Freedom Airlines)</li><li>`3206` (China Eastern Airlines (Abbr: China East Air))</li><li>`3207` (Empresa Ecuatoriana)</li><li>`3211` (Norwegian Air Shuttle - NORWEGIANAIR)</li><li>`3212` (Dominicana de Aviacion)</li><li>`3213` (Malmo Aviation - MALMO AV)</li><li>`3215` (Dan Air Services)</li><li>`3216` (Cumberland Airlines)</li><li>`3217` (CSA-Ceskoslovenske Aeroln)</li><li>`3218` (Crown Air)</li><li>`3219` (Copa)</li><li>`3220` (Compania Faucett)</li><li>`3221` (Transportes Aeros Mil)</li><li>`3222` (Command Airways)</li><li>`3223` (Comair)</li><li>`3226` (Skyways Air- SKYWAYS)</li><li>`3228` (Cayman Airways)</li><li>`3229` (SAETA)</li><li>`3231` (SAHSA)</li><li>`3233` (Capitol Air)</li><li>`3234` (CARIBAIR)</li><li>`3235` (Brockway Air)</li><li>`3236` (Air Arabia Airlines - Air Arab)</li><li>`3238` (Bemidji Aviation)</li><li>`3239` (Bar Harbor Airlines)</li><li>`3240` (Bahamasair)</li><li>`3241` (Aviateca (Guatemala))</li><li>`3242` (Avensa)</li><li>`3243` (Austrian Air Service)</li><li>`3245` (Easy Jet - EASYJET)</li><li>`3246` (Ryan Air - RYANAIR)</li><li>`3247` (Gol Airlines - GOL)</li><li>`3248` (Tam Airlines - TAM)</li><li>`3251` (Aloha Airlines)</li><li>`3252` (ALM-Antilean Airlines)</li><li>`3253` (America West)</li><li>`3254` (U.S. Air Shuttle)</li><li>`3256` (Alaska Airlines Inc.)</li><li>`3259` (American Trans Air)</li><li>`3260` (Spirit Airlines - SPIRIT)</li><li>`3261` (Air China)</li><li>`3262` (Reno Air)</li><li>`3263` (Aero Servicio Carabobo)</li><li>`3266` (Air Seychelles)</li><li>`3267` (Air Panama International)</li><li>`3268` (Air Pacific)</li><li>`3275` (Air Nevada)</li><li>`3276` (Air Midwest)</li><li>`3277` (Air Madagascar)</li><li>`3279` (Air LA)</li><li>`3280` (Air Jamaica)</li><li>`3282` (Air Djibouti)</li><li>`3284` (Aero Virgin Islands)</li><li>`3285` (AeroPeru)</li><li>`3286` (Aero Nicaraguensis)</li><li>`3287` (Aero Coach Aviation)</li><li>`3291` (Ariana Afghan)</li><li>`3292` (Cyprus Airways)</li><li>`3293` (Ecuatoriana)</li><li>`3294` (Ethiopian Airlines)</li><li>`3295` (Kenya Airways)</li><li>`3296` (Air Berlin-AIRBERLIN)</li><li>`3297` (Tarom Romanian Air Transport)</li><li>`3298` (Air Mauritius)</li><li>`3299` (Wideroe\'s Flyveselskap)</li><li>`3351` (Affiliated Auto Rental)</li><li>`3352` (American International)</li><li>`3353` (Brooks Rent a Car)</li><li>`3354` (Action Auto Rental)</li><li>`3355` (SIXT Car Rental)</li><li>`3357` (Hertz)</li><li>`3359` (Payless Car Rental)</li><li>`3360` (Snappy Car Rental)</li><li>`3361` (Airways Rent a Car)</li><li>`3362` (Altra Auto Rental)</li><li>`3364` (Agency Rent a Car)</li><li>`3366` (Budget Rent a Car)</li><li>`3368` (Holiday R-A-C)</li><li>`3370` (Rent-a-Wreck)</li><li>`3374` (Accent Rent-A-Car)</li><li>`3376` (Ajax R-A-C)</li><li>`3380` (Triangle Rent a Car)</li><li>`3381` (Europ Car)</li><li>`3385` (Tropical R-A-C)</li><li>`3386` (Showcase Rental Cars)</li><li>`3387` (Alamo Rent a Car)</li><li>`3388` (Merchants Rent-A-Car, Inc)</li><li>`3389` (Avis R-A-C)</li><li>`3390` (Dollar R-A-C)</li><li>`3391` (Europe by Car)</li><li>`3393` (National Car Rental)</li><li>`3394` (Kemwell Group R-A-C)</li><li>`3395` (Thrify Car Rental)</li><li>`3396` (Tilden R-A-C)</li><li>`3398` (Econo Car R-A-C)</li><li>`3400` (Auto Host Car Rentals)</li><li>`3405` (Enterprise R-A-C)</li><li>`3409` (General Rent-a-Car)</li><li>`3412` (A-1 R-A-C)</li><li>`3414` (Godfrey National)</li><li>`3420` (ANSA International)</li><li>`3421` (Allstate Rent-a-Car)</li><li>`3423` (Avcar Rent-a-Car)</li><li>`3425` (Automate Rent-a-Car)</li><li>`3427` (Avon Rent-a-Car)</li><li>`3428` (Carey Rent-a-Car)</li><li>`3429` (Insurance Rent-a-Car)</li><li>`3430` (Major Rent-a-Car)</li><li>`3431` (Replacement Rent-a-Car)</li><li>`3432` (Reserve Rent-a-Car)</li><li>`3433` (Ugly Duckling R-A-C)</li><li>`3434` (USA Rent-a-Car)</li><li>`3435` (Value Rent-a-Car)</li><li>`3436` (Autohansa Rent-a-Car)</li><li>`3437` (Cite)</li><li>`3438` (Interenet Rent-a-Car)</li><li>`3439` (Millville Rent-a-Car)</li><li>`3441` (Advantage Rent A Car)</li><li>`3501` (Holiday Inns)</li><li>`3502` (Best Western Hotels)</li><li>`3503` (Sheraton)</li><li>`3504` (Hilton)</li><li>`3505` (Forte Hotels)</li><li>`3506` (Golden Tulip Hotels)</li><li>`3507` (Friendship Inns)</li><li>`3508` (Quality Inns)</li><li>`3509` (Marriott)</li><li>`3510` (Days Inn Colonial Resort)</li><li>`3511` (Arabella Hotels)</li><li>`3512` (Intercontinental Hotels)</li><li>`3513` (Westin)</li><li>`3514` (Amerisuites)</li><li>`3515` (Rodeway Inn)</li><li>`3516` (LaQuinta Motor Inns)</li><li>`3517` (Americana Hotels)</li><li>`3518` (Sol Hotels)</li><li>`3519` (Pullman International Hotels)</li><li>`3520` (Meridien Hotels)</li><li>`3521` (Royal Lahaina Resort)</li><li>`3522` (Tokyo Group)</li><li>`3523` (Peninsula Hotels)</li><li>`3524` (WelcomGroup Hotels)</li><li>`3525` (Dunfey Hotels)</li><li>`3526` (Prince Hotels)</li><li>`3527` (Downtowner Passport)</li><li>`3528` (Red Lion Inns)</li><li>`3529` (CP (Canadian Pacific))</li><li>`3530` (Renaissance Hotels)</li><li>`3531` (Kauai Coconut Beach Resort)</li><li>`3532` (Royal Kona Resort)</li><li>`3533` (Hotel Ibis)</li><li>`3534` (Southern Pacific)</li><li>`3535` (Hilton International)</li><li>`3536` (AMFAC Hotels)</li><li>`3537` (ANA Hotels)</li><li>`3538` (Concorde Hotels)</li><li>`3539` (Summerfield Suites Hotel)</li><li>`3540` (Iberotel Hotels)</li><li>`3541` (Hotel Okura)</li><li>`3542` (Royal Hotels)</li><li>`3543` (Four Seasons)</li><li>`3544` (Cigna Hotels)</li><li>`3545` (Shangri-La International)</li><li>`3546` (Hotel Sierra)</li><li>`3548` (Hotels Melia)</li><li>`3549` (Auberge des Governeurs)</li><li>`3550` (Regal 8 Inns)</li><li>`3551` (Mirage Hotel and Casino)</li><li>`3552` (Coast Hotel)</li><li>`3553` (Park Inn by Radisson)</li><li>`3554` (Pinehurst Resort)</li><li>`3555` (Treasure Island Hotel and Casino)</li><li>`3556` (Barton Creek Resort)</li><li>`3557` (Manhattan East Suite Hotels)</li><li>`3558` (Jolly Hotels)</li><li>`3559` (Candlewood Suites)</li><li>`3560` (Aladdin Resort and Casino)</li><li>`3561` (Golden Nugget)</li><li>`3562` (Comfort Inns)</li><li>`3563` (Journey\'s End Motels)</li><li>`3564` (Sam\'s Town Hotel and Casino)</li><li>`3565` (Relax Inns)</li><li>`3566` (Garden Place Hotel)</li><li>`3567` (Soho Grand Hotel)</li><li>`3568` (Ladbroke Hotels)</li><li>`3569` (Tribeca Grand Hotel)</li><li>`3570` (Forum Hotels)</li><li>`3571` (Grand Wailea Resort)</li><li>`3572` (Miyako Hotel)</li><li>`3573` (Sandman Hotels)</li><li>`3574` (Venture Inn)</li><li>`3575` (Vagabond Hotels)</li><li>`3576` (La Quinta Resort)</li><li>`3577` (Mandarin Oriental Hotel)</li><li>`3578` (Frankenmuth Bavarian)</li><li>`3579` (Hotel Mercure)</li><li>`3580` (Hotel Del Coronado)</li><li>`3581` (Delta Hotels)</li><li>`3582` (California Hotel and Casino)</li><li>`3583` (Radisson BLU)</li><li>`3584` (Princess Hotels International)</li><li>`3585` (Hungar Hotels)</li><li>`3586` (Sokos Hotels)</li><li>`3587` (Doral Hotels)</li><li>`3588` (Helmsley Hotels)</li><li>`3589` (Doral Golf Resort)</li><li>`3590` (Fairmont Hotel)</li><li>`3591` (Sonesta Hotels)</li><li>`3592` (Omni Hotels)</li><li>`3593` (Cunard Hotels)</li><li>`3594` (Arizona Biltmore)</li><li>`3595` (Hospitality Inns)</li><li>`3596` (Wynn Las Vegas)</li><li>`3597` (Riverside Resort and Casino)</li><li>`3598` (Regent International Hotels)</li><li>`3599` (Pannonia Hotels)</li><li>`3600` (Saddlebrook Resort - Tampa)</li><li>`3601` (Trade Winds Resorts)</li><li>`3602` (Hudson Hotel)</li><li>`3603` (Noah\'s Hotel)</li><li>`3604` (Hilton Garden Inn)</li><li>`3605` (Jurys Doyle Hotel Group)</li><li>`3606` (Jefferson Hotel)</li><li>`3607` (Fountainebleau Resort)</li><li>`3608` (Gaylord Opryland)</li><li>`3609` (Gaylord Palms)</li><li>`3610` (Gaylord Texan)</li><li>`3611` (C MON INN)</li><li>`3612` (Movenpick Hotels)</li><li>`3613` (Microtel Inns & Suites)</li><li>`3614` (Americinn)</li><li>`3615` (Travelodge Motels)</li><li>`3617` (America\'s Best Value Inn)</li><li>`3618` (Great Wolf)</li><li>`3619` (Aloft)</li><li>`3620` (Binion\'s Horseshoe Club)</li><li>`3621` (Extended Stay)</li><li>`3622` (Merlin Hotel)</li><li>`3623` (Dorint Hotels)</li><li>`3624` (Lady Luck Hotel and Casino)</li><li>`3625` (Hotel Universale)</li><li>`3626` (Studio Plus)</li><li>`3627` (Extended Stay America)</li><li>`3628` (Excalibur Hotel and Casino)</li><li>`3629` (Dan Hotels)</li><li>`3630` (Extended Stay Deluxe)</li><li>`3631` (Sleep Inn)</li><li>`3632` (The Phoenician)</li><li>`3633` (Rank Hotels)</li><li>`3634` (Swissotel)</li><li>`3635` (Reso Hotel)</li><li>`3636` (Sarova Hotels)</li><li>`3637` (Ramada Inns)</li><li>`3638` (Howard Johnson)</li><li>`3639` (Mount Charlotte Thistle)</li><li>`3640` (Hyatt Motels)</li><li>`3641` (Sofitel Hotels)</li><li>`3642` (Novotel)</li><li>`3643` (Steigenberger Hotels)</li><li>`3644` (EconoLodges)</li><li>`3645` (Queens Moat Houses)</li><li>`3646` (Swallow Hotels)</li><li>`3647` (Husa Hotels)</li><li>`3648` (De Vere Hotels)</li><li>`3649` (Radisson)</li><li>`3650` (Red Roof Inns)</li><li>`3651` (Imperial London Hotel)</li><li>`3652` (Embassy Hotels)</li><li>`3653` (Penta Hotels)</li><li>`3654` (Loews Hotels)</li><li>`3655` (Scandic Hotels)</li><li>`3656` (Sara Hotels)</li><li>`3657` (Oberoi Hotels)</li><li>`3658` (New Otani Hotels)</li><li>`3659` (Taj Hotels International)</li><li>`3660` (Knights Inn)</li><li>`3661` (Metropole Hotels)</li><li>`3662` (Circus Circus Hotel and Casino)</li><li>`3663` (Hoteles El Presidente)</li><li>`3664` (Flag Inns)</li><li>`3665` (Hampton Inn Hotels)</li><li>`3666` (Stakis Hotels)</li><li>`3667` (Luxor Hotel and Casino)</li><li>`3668` (Maritim Hotels)</li><li>`3669` (Eldorado Hotel and Casino)</li><li>`3670` (Arcade Hotels)</li><li>`3671` (Arctia Hotels)</li><li>`3672` (Campanile Hotels)</li><li>`3673` (IBUSZ Hotels)</li><li>`3674` (Rantasipi Hotels)</li><li>`3675` (Interhotel CEDOK)</li><li>`3676` (Monte Carlo Hotel and Casino)</li><li>`3677` (Climat de France Hotels)</li><li>`3678` (Cumulus Hotels)</li><li>`3679` (Silver Legacy Hotel and Casino)</li><li>`3680` (Hoteis Othan)</li><li>`3681` (Adams Mark Hotels)</li><li>`3682` (Sahara Hotel and Casino)</li><li>`3683` (Bradbury Suites)</li><li>`3684` (Budget Hosts Inns)</li><li>`3685` (Budgetel Hotels)</li><li>`3686` (Suisse Chalet)</li><li>`3687` (Clarion Hotels)</li><li>`3688` (Compri Hotels)</li><li>`3689` (Consort Hotels)</li><li>`3690` (Courtyard Inns)</li><li>`3691` (Dillon Inn)</li><li>`3692` (Doubletree)</li><li>`3693` (Drury Inn)</li><li>`3694` (Economy Inns of America)</li><li>`3695` (Embassy Suites)</li><li>`3696` (Excel Inn)</li><li>`3697` (Fairfield Hotels)</li><li>`3698` (Harley Hotels)</li><li>`3699` (Midway Motor Lodge)</li><li>`3700` (Motel 6)</li><li>`3701` (La Mansion Del Rio)</li><li>`3702` (The Registry Hotels)</li><li>`3703` (Residence Inn)</li><li>`3704` (Royce Hotels)</li><li>`3705` (Sandman Inn)</li><li>`3706` (Shilo Inn)</li><li>`3707` (Shoney\'s Inn)</li><li>`3708` (Virgin River Hotel and Casino)</li><li>`3709` (Super 8 Motels)</li><li>`3710` (The Ritz Carlton Hotels)</li><li>`3711` (Flag Inns (Australia))</li><li>`3712` (Buffalo Bill\'s Hotel and Casino)</li><li>`3713` (Quality Pacific Hotel)</li><li>`3714` (Four Seasons Hotels-Austr)</li><li>`3715` (Fairfield Inn)</li><li>`3716` (Carlton Hotels)</li><li>`3717` (City Lodge Hotels)</li><li>`3718` (Karos Hotels)</li><li>`3719` (Protea Hotels)</li><li>`3720` (Southern Sun Hotels)</li><li>`3721` (Hilton Conrad Hotels)</li><li>`3722` (Wyndham Hotels)</li><li>`3723` (Rica Hotels)</li><li>`3724` (Inter Nor Hotels)</li><li>`3725` (SeaPines Plantation)</li><li>`3726` (Rio Suites)</li><li>`3727` (Broadmoor Hotel)</li><li>`3728` (Bally\'s Hotel and Casino)</li><li>`3729` (John Ascuaga\'s Nugget)</li><li>`3730` (MGM Grand Hotel)</li><li>`3731` (Harrah\'s Hotels and Casinos)</li><li>`3732` (Opryland Hotel)</li><li>`3733` (Boca Raton Resort)</li><li>`3734` (Harvey/Bristol Hotels)</li><li>`3735` (Master Economy Inns)</li><li>`3736` (Colorado Belle/Edgewater Resort)</li><li>`3737` (Riviera Hotel and Casino)</li><li>`3738` (Tropicana Resort & Casino)</li><li>`3739` (Woodside Hotels & Resorts)</li><li>`3740` (Towneplace Suites)</li><li>`3741` (Millennium Hotel)</li><li>`3742` (Club Med)</li><li>`3743` (Biltmore Hotel and Suites)</li><li>`3744` (Carefree Resorts)</li><li>`3745` (St. Regis Hotel)</li><li>`3746` (The Eliot Hotel)</li><li>`3747` (ClubCorp/ClubResorts)</li><li>`3748` (Wellesley Inns)</li><li>`3749` (The Beverly Hills Hotel)</li><li>`3750` (Crown Plaza Hotels)</li><li>`3751` (Homewood Suites)</li><li>`3752` (Peabody Hotels)</li><li>`3753` (Greenbriar Resorts)</li><li>`3754` (Amelia Island Plantation)</li><li>`3755` (The Homestead)</li><li>`3757` (Canyon Ranch)</li><li>`3758` (Kahala Mandarion Oriental Hotel)</li><li>`3759` (The Orchid at Mauna Lani)</li><li>`3760` (Halekulani Hotel/Waikiki Parc)</li><li>`3761` (Primadonna Hotel and Casino)</li><li>`3762` (Whisky Pete\'s Hotel and Casino)</li><li>`3763` (Chateau Elan Winery and Resort)</li><li>`3764` (Beau Rivage Hotel and Casino)</li><li>`3765` (Bellagio)</li><li>`3766` (Fremont Hotel and Casino)</li><li>`3767` (Main Street Hotel and Casino)</li><li>`3768` (Silver Star Hotel and Casino)</li><li>`3769` (Stratosphere Hotel and Casino)</li><li>`3770` (SpringHill Suites)</li><li>`3771` (Caesar\'s Resort)</li><li>`3772` (Nemacolin Woodlands)</li><li>`3773` (The Venetian Resort Hotel and Casino)</li><li>`3774` (New York-New York Hotel and Casino)</li><li>`3775` (Sands Resort)</li><li>`3776` (Nevele Grande Resort and Country Club)</li><li>`3777` (Mandalay Bay Resort)</li><li>`3778` (Four Points Hotels)</li><li>`3779` (W Hotels)</li><li>`3780` (Disney Resorts)</li><li>`3781` (Patricia Grand Resort Hotels)</li><li>`3782` (Rosen Hotels & Resort)</li><li>`3783` (Town and Country Resort and Convention Center)</li><li>`3784` (First Hospitality Hotel)</li><li>`3785` (Outrigger Hotels and Resorts)</li><li>`3786` (Ohana Hotel of Hawaii)</li><li>`3787` (Caribe Royale Resort Suites & Villas)</li><li>`3788` (Ala Moana Hotel / Ala Moana Hotels)</li><li>`3789` (Smugglers\' Notch Resort)</li><li>`3790` (Raffles Hotels)</li><li>`3791` (Staybridge Suites)</li><li>`3792` (Claridge Casino Hotel)</li><li>`3793` (The Flamingo Hotels)</li><li>`3794` (Grand Casino Hotels)</li><li>`3795` (Paris Las Vegas Hotel)</li><li>`3796` (Peppermill Hotel Casino)</li><li>`3797` (Atlantic City Hilton)</li><li>`3798` (Embassy Vacation Resort)</li><li>`3799` (Hale Koa Hotel)</li><li>`3800` (Homestead)</li><li>`3801` (Wilderness Hotel and Golf Resort)</li><li>`3802` (The Palace Hotel)</li><li>`3807` (Element)</li><li>`3808` (LXR)</li><li>`3810` (La Costa Resort)</li><li>`3811` (Premier Travel Inn)</li><li>`3812` (Hyatt Place)</li><li>`3813` (Hotel Indigo)</li><li>`3814` (The Roosevelt Hotel NY)</li><li>`3815` (Holiday Inn Nickelodeon)</li><li>`3816` (Home2 Suites)</li><li>`3817` (Affinia)</li><li>`3818` (Mainstay Suites)</li><li>`3819` (Oxford Suites)</li><li>`3820` (Jumeirah Essex House)</li><li>`3821` (Caribe Royale)</li><li>`3822` (Crossland)</li><li>`3823` (Grand Sierra Resort)</li><li>`3824` (Aria)</li><li>`3825` (Vdara)</li><li>`3826` (Autograph)</li><li>`3827` (Galt House)</li><li>`3828` (Cosmopolitan of Las Vegas)</li><li>`3829` (Country Inn by Carlson)</li><li>`3830` (Park Plaza Hotel)</li><li>`3831` (Waldorf)</li><li>`4011` (Railroads)</li><li>`4111` (Local and Suburban Commuter Passenger Transportation, including Ferries)</li><li>`4112` (Passenger Rail (train))</li><li>`4119` (Ambulance Services)</li><li>`4121` (Taxicabs and Limousines)</li><li>`4131` (Bus Lines, includes Charters/Tour Buses)</li><li>`4214` (Motor Freight Carriers and Trucking-Local and Long Distance, Moving & Storage Companies, and Local Delivery)</li><li>`4215` (Courier Services-Air and Ground, and Freight Forwarders)</li><li>`4225` (Public Warehousing-Farm products, Refrigerated Goods, Household Goods, and Storage)</li><li>`4411` (Steamship and Cruise Lines)</li><li>`4457` (Boat Rentals and Leasing)</li><li>`4468` (Marinas, Marine Service, and Supplies)</li><li>`4511` (Airlines and Air Carriers)</li><li>`4582` (Airports, Flying Fields, and Airport Terminals)</li><li>`4722` (Travel Agencies)</li><li>`4723` (Package Tour Operators (Germany Only))</li><li>`4761` (Telemarketing of Travel Related Services and Vitamins)</li><li>`4784` (Bridge and Road Fees, Tolls)</li><li>`4789` (Transportation Services-not elsewhere classified)</li><li>`4812` (Telecommunication Equipment and Telephone Sales)</li><li>`4813` (Special Telecom Merchant)</li><li>`4814` (Telecommunication Services, Including Local and Long Distance Calls, Credit Card Calls, Call Through Use of Magnetic-Strip-Reading Telephones, and Fax Services)</li><li>`4815` (Monthly Summary Telephone Charges)</li><li>`4816` (Computer Network/Information Services and other Online Services such as electronic bulletin board, e-mail, web site hosting services, or Internet access)</li><li>`4821` (Telegraph Services)</li><li>`4829` (Quasi Cash - Money Transfer)</li><li>`4899` (Cable, Satellite, and Other Pay Television and Radio Services)</li><li>`4900` (Utilities-Electric, Gas, Water, and Sanitary)</li><li>`5013` (Motor Vehicle Supplies and New Parts (Business to Business MCC))</li><li>`5021` (Office Furniture (Business to Business MCC))</li><li>`5039` (Construction Materials Not Elsewhere Classified (Business to Business MCC))</li><li>`5044` (Photographic, Photocopy, Microfilm Equipment and Supplies (Business to Business MCC))</li><li>`5045` (Computers, Computer Peripheral Equipment, and Software)</li><li>`5046` (Commercial Equipment Not Elsewhere Classified (Business to Business MCC))</li><li>`5047` (Dental/Laboratory/Medical/Ophthalmic Hospital Equipment and Supplies)</li><li>`5051` (Metal Service Centers and Offices (Business to Business MCC))</li><li>`5065` (Electrical Parts and Equipment (Business to Business MCC))</li><li>`5072` (Hardware, Plumbing, Heat Equipment and Supplies (Business to Business MCC))</li><li>`5074` (Plumbing and Heating Equipment and Supplies (Business to Business MCC))</li><li>`5085` (Industrial Supplies Not Elsewhere Classified (Business to Business MCC))</li><li>`5094` (Precious Stones, Metals, Watches and Jewelry (Business to Business MCC))</li><li>`5099` (Durable Goods Not Elsewhere Classified (Business to Business MCC))</li><li>`5111` (Stationery, Office Supplies, and Printing and Writing Paper)</li><li>`5122` (Drugs, Drug Proprietary\'s, and Druggists\' Sundries)</li><li>`5131` (Piece Goods, Notions and Other Dry Goods (Business to Business MCC))</li><li>`5137` (Men\'s, Women\'s and Children\'s Uniforms (Business to Business MCC))</li><li>`5139` (Commercial Footwear (Business to Business MCC))</li><li>`5169` (Chemicals and Allied Products Not Elsewhere Classified (Business to Business MCC))</li><li>`5172` (Petroleum and Products (Business to Business MCC))</li><li>`5192` (Books, Periodicals and Newspapers (Business to Business MCC))</li><li>`5193` (Florist Suppliers, Nursery Stock & Flowers (Business to Business MCC))</li><li>`5198` (Paints, Varnishes and Supplies (Business to Business MCC))</li><li>`5199` (Non-durable Goods Not Elsewhere Classified (Business to Business MCC))</li><li>`5200` (Home Supply Warehouse)</li><li>`5211` (Lumber & Building Materials Stores)</li><li>`5231` (Glass, Paint, and Wallpaper Stores)</li><li>`5251` (Hardware Stores, Equipment Utilities Regulated)</li><li>`5261` (Nurseries and Lawn and Garden Supply Stores)</li><li>`5271` (Mobile Home Dealer)</li><li>`5300` (Wholesale Club with or without membership fee)</li><li>`5309` (Duty Free Stores)</li><li>`5310` (Discount Store)</li><li>`5311` (Department Stores)</li><li>`5331` (Variety Stores)</li><li>`5399` (Miscellaneous General Merchandise)</li><li>`5411` (Grocery Stores and Supermarkets)</li><li>`5422` (Freezer & Locker Meat Provisions)</li><li>`5441` (Candy, Nut, and Confectionary Stores)</li><li>`5451` (Dairy Product Stores)</li><li>`5462` (Bakeries)</li><li>`5499` (Miscellaneous Food Stores-Convenience Stores and Specialty Markets)</li><li>`5511` (Car and Truck Dealers (New and Used)- Sales, Service, Repairs, Parts, and Leasing)</li><li>`5521` (Car and Truck Dealers (Used)- Sales, Service, Repairs, Parts, and Leasing)</li><li>`5532` (Automotive Tire Stores)</li><li>`5531` (Auto and Home Supply Stores)</li><li>`5533` (Automotive Parts and Accessories Stores)</li><li>`5541` (Service Stations (with or without Ancillary Services))</li><li>`5542` (Automated Fuel Dispensers)</li><li>`5551` (Boat Dealers)</li><li>`5561` (Camper, Recreational and Utility Trailer Dealers)</li><li>`5571` (Motorcycle Dealers)</li><li>`5592` (Motor Home Dealers)</li><li>`5598` (Snowmobile Dealers)</li><li>`5599` (Miscellaneous Automotive, Aircraft, and Farm Equipment Dealers --Not Elsewhere Classified)</li><li>`5611` (Men\'s & Boys\' Clothing and Accessory Stores)</li><li>`5621` (Women\'s Ready-to-Wear Stores)</li><li>`5631` (Women\'s Accessory and Specialty Stores)</li><li>`5641` (Children\'s and Infants\' Wear Stores)</li><li>`5651` (Family Clothing Stores)</li><li>`5655` (Sports and Riding Apparel Stores)</li><li>`5661` (Shoe Stores)</li><li>`5681` (Furriers & Fur Shops)</li><li>`5691` (Men\'s and Women\'s Clothing Stores)</li><li>`5697` (Tailors, Seamstresses, Mending, Alterations)</li><li>`5698` (Wig & Toupee Shops)</li><li>`5699` (Miscellaneous Apparel and Accessory Stores)</li><li>`5712` (Furniture, Home Furnishings, and Equipment Stores, except Appliances)</li><li>`5713` (Floor coverings, Rugs)</li><li>`5714` (Drapery, Window Covering, and Upholstery Stores)</li><li>`5718` (Fireplaces, Fireplace Screens and Accessories Stores)</li><li>`5719` (Miscellaneous Home Furnishing Specialty Stores)</li><li>`5722` (Household Appliance Stores)</li><li>`5732` (Electronics Stores)</li><li>`5733` (Music Stores-Musical Instruments, Pianos, and Sheet Music)</li><li>`5734` (Computer Software Stores)</li><li>`5735` (Record Stores)</li><li>`5811` (Caterers - Prepare & Delivery)</li><li>`5812` (Eating Places and Restaurants)</li><li>`5813` (Drinking Places (Alcoholic Beverages) - Bars, Taverns, Nightclubs, Cocktail Lounges, and Discotheques)</li><li>`5814` (Quick Payment Service-Fast Food Restaurants)</li><li>`5815` (Digital Goods  Media, Books, Movies, Music)</li><li>`5816` (Digital Goods  Games)</li><li>`5817` (Digital Goods  Applications (Excludes Games))</li><li>`5818` (Large Digital Goods Merchant)</li><li>`5912` (Drug Stores and Pharmacies)</li><li>`5921` (Package Stores--Beer, Wine, and Liquor)</li><li>`5931` (Used Merchandise and Secondhand Stores)</li><li>`5932` (Antique Shop)</li><li>`5933` (Pawn Shop)</li><li>`5935` (Wrecking and Salvage Yards)</li><li>`5937` (Antique Reproduction Stores)</li><li>`5940` (Bicycle Shop-Sales and Services)</li><li>`5941` (Sporting Goods Stores)</li><li>`5942` (Book Stores)</li><li>`5943` (Stationery, Office and School Supply Stores)</li><li>`5944` (Jewelry, Watch, Clock, and Silverware Stores)</li><li>`5945` (Hobby, Toy and Game Stores)</li><li>`5946` (Camera and Photographic Supply Stores)</li><li>`5947` (Gift, Card, Novelty, and Souvenir Stores)</li><li>`5948` (Luggage and Leather Goods Stores)</li><li>`5949` (Sewing, Needlework, Fabric, and Piece Good Stores)</li><li>`5950` (Glassware and Crystal Stores)</li><li>`5960` (Direct Marketing Insurance Services)</li><li>`5961` (Mail Order)</li><li>`5962` (Direct Marketing -- Travel Related Arrangement Services)</li><li>`5963` (Direct Selling Establishments/Door to Door Sales)</li><li>`5964` (Catalog Merchant)</li><li>`5965` (Combined Catalog and Retail Merchant)</li><li>`5966` (Outbound Telemarketing Merchant)</li><li>`5967` (Direct Marketing -- Inbound Telemarketing Merchants)</li><li>`5968` (Continuity/Subscription Merchants)</li><li>`5969` (Direct Marketing/Direct Marketers--Not Elsewhere Classified)</li><li>`5970` (Artist Supply and Craft Stores)</li><li>`5971` (Art Dealers and Galleries)</li><li>`5972` (Stamp and Coin Stores)</li><li>`5973` (Religious Goods Stores)</li><li>`5975` (Hearing Aids--Sales, Service, and Supplies)</li><li>`5976` (Orthopedic Goods and Prosthetic Devices)</li><li>`5977` (Cosmetic Stores)</li><li>`5978` (Typewriter Stores--Sales, Service, and Rentals)</li><li>`5983` (Fuel Dealers--Fuel Oil, Wood, Coal, and Liquefied Petroleum)</li><li>`5992` (Florists)</li><li>`5993` (Cigar Stores & Stands)</li><li>`5994` (News Dealers & Newsstands)</li><li>`5995` (Pet Shops, Pet Food, and Supplies)</li><li>`5996` (Swimming Pools--Sales, Supplies, and Services)</li><li>`5997` (Electric Razor Stores Sales & Services)</li><li>`5998` (Tent and Awning Stores)</li><li>`5999` (Miscellaneous & Specialty Retail Stores)</li><li>`6010` (Financial Institutions--Manual Cash Disbursements)</li><li>`6011` (Financial Institutions--Automated Cash Disbursements)</li><li>`6012` (Quasi Cash - Financial Institution - Merchandise and Services)</li><li>`6050` (Quasi Cash - Member Financial Institution)</li><li>`6051` (MasterCard - Quasi Cash-Merchant)</li><li>`6211` (Securities - Brokers and Dealers)</li><li>`6300` (Insurance Sales and Underwriting)</li><li>`6381` (Insurance - Premiums)</li><li>`6399` (Insurance - Not Elsewhere Classified)</li><li>`6513` (Real Estate Agents and Managers - Rentals; Property Management)</li><li>`6529` (Remote Stored Value Load - Member Financial Institution)</li><li>`6530` (Remote Stored Value Load - Merchant)</li><li>`6531` (Payment Service Provider)</li><li>`6532` (Payment Transaction - Member)</li><li>`6533` (Payment Transaction - Merchant)</li><li>`6534` (Money Transfer - Member Financial Institution)</li><li>`6535` (Value Purchase - Member Financial Institution)</li><li>`6536` (MoneySend Intracountry)</li><li>`6537` (MoneySend Intercountry)</li><li>`6538` (MoneySend Funding)</li><li>`6540` (POI Funding Transactions (Excluding MoneySend))</li><li>`7011` (Lodging - Hotels, Motels, and Resorts)</li><li>`7012` (Timeshares)</li><li>`7032` (Sporting and Recreational Camps)</li><li>`7033` (Trailer Parks and Campgrounds)</li><li>`7210` (Laundry, Cleaning, and Garment Services)</li><li>`7211` (Laundry Services - Family and Commercial)</li><li>`7216` (Dry Cleaners)</li><li>`7217` (Carpet and Upholstery Cleaning)</li><li>`7221` (Photographic Studios)</li><li>`7230` (Beauty and Barber Shops)</li><li>`7251` (Shoe Repair Shops, Shoe Shine Parlors, and Hat Cleaning Shops)</li><li>`7261` (Funeral Services and Crematories)</li><li>`7273` (Dating Services)</li><li>`7276` (Tax Preparation Services)</li><li>`7277` (Counseling Services - Debt, Marriage, and Personal)</li><li>`7278` (Buying and Shopping Services and Clubs)</li><li>`7296` (Clothing Rental - Costumes, Uniforms and Formal Wear)</li><li>`7297` (Massage Parlors)</li><li>`7298` (Health and Beauty Spas)</li><li>`7299` (Miscellaneous Personal Services - Not Elsewhere Classified)</li><li>`7311` (Advertising Services)</li><li>`7321` (Consumer Credit Reporting Agencies)</li><li>`7332` (Blueprinting and Photocopying Services)</li><li>`7333` (Commercial Photography, Art, and Graphics)</li><li>`7338` (Quick Copy, Reproduction Service)</li><li>`7339` (Stenographic Service)</li><li>`7342` (Exterminating and Disinfecting Services)</li><li>`7349` (Cleaning, Maintenance & Janitorial Services)</li><li>`7361` (Employment Agencies and Temporary Help Services)</li><li>`7372` (Computer Programming, Data Processing, and Integrated Systems Design Services)</li><li>`7375` (Information Retrieval Services (Business to Business MCC))</li><li>`7379` (Computer Maintenance, Repair and Services (Business to Business MCC))</li><li>`7392` (Management, Consulting, and Public Relations Services)</li><li>`7393` (Detective Agencies, Protective Agencies, and Security Services, including Armored Cars and Guard Dogs)</li><li>`7394` (Equipment, Tool, Furniture, and Appliance Rental and Leasing)</li><li>`7395` (Photofinishing Laboratories and Photo Developing)</li><li>`7399` (Business Services)</li><li>`7511` (Truck Stops)</li><li>`7512` (Automobile Rental Agency)</li><li>`7513` (Truck and Utility Trailer Rentals)</li><li>`7519` (Motor Home and Recreational Vehicle Rentals)</li><li>`7523` (Parking Lots and Garages)</li><li>`7524` (Express Payment Service Mechants - Parking Lots and Garages)</li><li>`7531` (Automotive Top & Body Shops)</li><li>`7534` (Tire Retreading & Repair)</li><li>`7535` (Automotive Paint Shops)</li><li>`7538` (Automotive Service Shops (Non-Dealer))</li><li>`7542` (Car Washes)</li><li>`7549` (Towing Services)</li><li>`7622` (Electronic Repair Shops)</li><li>`7623` (Air Conditioning and Refrigeration Repair Shops)</li><li>`7629` (Electrical and Small Appliance Repair Shops)</li><li>`7631` (Watch, Clock, and Jewelry Repair Shops)</li><li>`7641` (Furniture - Reupholster, Repair, and Refinishing)</li><li>`7692` (Welding Services)</li><li>`7699` (Miscellaneous Repair Shops and Related Services)</li><li>`7778` (Citishare Cash Advance)</li><li>`7800` (Government-Owned Lotteries)</li><li>`7801` (Government-Licensed Casinos (Online Gambling))</li><li>`7802` (Government-Licensed Horse/Dog Racing)</li><li>`7829` (Motion Picture & Video Tape Production and Distribution (Business to Business MCC))</li><li>`7832` (Motion Picture Theater)</li><li>`7841` (DVD/Video Tape Rental Stores)</li><li>`7911` (Dance Halls, Studios & Schools)</li><li>`7922` (Theatrical Producers (except Motion Pictures) and Ticket Agencies)</li><li>`7929` (Bands, Orchestras & Misc Entertainment)</li><li>`7932` (Billiards & Pool Establishments)</li><li>`7933` (Bowling Alleys)</li><li>`7941` (Commercial Sports, Professional Sports Clubs, Athletic Fields, and Sports Promoters)</li><li>`7991` (Tourist Attractions and Exhibits)</li><li>`7992` (Public Golf Courses)</li><li>`7993` (Video Amusement Game Supply)</li><li>`7994` (Video Game Arcades and Establishments)</li><li>`7995` (Betting, including Lottery Tickets, Casino Gaming Chips, Off- Track Betting, and Wagers at Race Track)</li><li>`7996` (Amusement Parks, Circuses, Carnivals, and Fortune Tellers)</li><li>`7997` (Membership Clubs (Sports, Recreation, Athletic), Country Clubs, and Private Golf Courses)</li><li>`7998` (Aquarium, Seaquarium, Dolphinariums)</li><li>`7999` (Recreation Services - Not Elsewhere Classified)</li><li>`8011` (Doctors and Physicians - Not Elsewhere Classified)</li><li>`8021` (Dentists and Orthodontists)</li><li>`8031` (Osteopathic Physicians)</li><li>`8041` (Chiropractors)</li><li>`8042` (Optometrists and Ophthalmologists)</li><li>`8043` (Opticians, Optical Goods and Eyeglasses)</li><li>`8049` (Podiatrists and Chiropodists)</li><li>`8050` (Nursing and Personal Care Facilities)</li><li>`8062` (Hospitals)</li><li>`8071` (Medical and Dental Laboratories)</li><li>`8099` (Medical Services Health Practitioners - No Elsewhere Classified)</li><li>`8111` (Legal Services and Attorneys)</li><li>`8211` (Elementary and Secondary Schools)</li><li>`8220` (Colleges, Universities, Professional Schools, and Junior Colleges)</li><li>`8241` (Correspondence Schools)</li><li>`8244` (Business and Secretarial Schools)</li><li>`8249` (Trade and Vocational Schools)</li><li>`8299` (Schools and Educational Services - Not Elsewhere Classified)</li><li>`8351` (Child Care Services)</li><li>`8398` (Charitable and Social Service Organizations)</li><li>`8641` (Civic, Social, and Fraternal Associations)</li><li>`8651` (Political Organizations)</li><li>`8661` (Religious Organizations)</li><li>`8675` (Automobile Associations)</li><li>`8699` (Membership Organizations - Not Elsewhere Classified)</li><li>`8734` (Testing Laboratories (Not Medical) - (Business to Business MCC))</li><li>`8911` (Architectural, Engineering, and Surveying Services)</li><li>`8931` (Accounting, Auditing, and Bookkeeping Services)</li><li>`8999` (Professional Services - Not Elsewhere Classified)</li><li>`9211` (Court Costs, including Alimony and Child Support)</li><li>`9222` (Fines)</li><li>`9223` (Bail & Bond Payments)</li><li>`9311` (Tax Payments)</li><li>`9399` (Government Services - Not Elsewhere Classified)</li><li>`9401` (i-Purchasing)</li><li>`9402` (Postal Services)</li><li>`9405` (U.S. Fed Government Agencies)</li><li>`9700` (Automated Referral Service)</li><li>`9701` (Visa Credential Server)</li><li>`9702` (GCAS Emergency Services)</li><li>`9751` (U.K. Supermarkets, Electronic Hot File)</li><li>`9752` (U.K. Petrol Stations, Electronic Hot File)</li><li>`9753` (Consumer Electronics/Furniture Store)</li><li>`9754` (Quasi Cash - Gambling-Horse Racing, Dog Racing, State Lotteries)</li><li>`9950` (Intra-Company Purchases)</li></ul>
     * @type {string}
     * @memberof ApplicationRequest
     */
    'merchantCategoryCode': string;
    /**
     * The payment user group from the purpose code list for the application.<br><br>Allowed values:<ul><li>WHOLESALE_FI_FI</li><li>COMMERCIAL</li><li>CONSUMER_GOODS_SERVICES</li><li>FINANCE</li><li>INSURANCE</li><li>PROPERTY</li><li>UTILITIES</li><li>TAX</li><li>SALARIES_INCOMES</li><li>INVESTMENTS</li><li>FOREIGN_EXCHANGE</li><li>GOVERNMENT</li><li>BENEFIT_PAYMENTS</li><li>MEDICAL</li><li>PENSIONS</li></ul>
     * @type {string}
     * @memberof ApplicationRequest
     */
    'ppcUserGroup': string;
    /**
     * The application callback URLs
     * @type {Array<string>}
     * @memberof ApplicationRequest
     */
    'callbackUrls'?: Array<string>;
    /**
     * Indicates if a contract is in place with the merchant and a KYB process has been completed
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'isContractPresent': boolean;
}
/**
 * 
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * The id of the application returned
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id'?: string;
    /**
     * The id of the root application
     * @type {string}
     * @memberof ApplicationResponse
     */
    'rootApplicationId'?: string;
    /**
     * The name of the application
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name'?: string;
    /**
     * The ISO-18245 merchant category code of the merchant the application is being created for.<br><br>Allowed values:<ul><li>`0742` (Veterinary Services)</li><li>`0763` (Agricultural Cooperatives)</li><li>`0780` (Landscaping and Horticultural Services)</li><li>`1520` (General Contractor/Residential Building)</li><li>`1711` (Heating, Plumbing, Air Conditioning Contractors)</li><li>`1731` (Electrical Contractors)</li><li>`1740` (Masonry, Stonework, Tile Setting, Plastering, Insulation Contractors)</li><li>`1750` (Carpentry)</li><li>`1761` (Roof, Siding, and Sheet Metal Work Contractors)</li><li>`1771` (Contractors, Concrete)</li><li>`1799` (Special Trade Contractor - Not Elsewhere Classified)</li><li>`2741` (Miscellaneous Publishing and Printing Services)</li><li>`2791` (Typesetting, Plate Making and Related Services (Business to Business MCC))</li><li>`2842` (Specialty Cleaning, Polishing and Sanitation Preparations (Business to Business MCC))</li><li>`3000` (United Airlines)</li><li>`3001` (American Airlines)</li><li>`3002` (Pan American)</li><li>`3003` (Eurofly Airlines)</li><li>`3004` (Dragon Airlines)</li><li>`3005` (British Airways)</li><li>`3006` (Japan Air Lines)</li><li>`3007` (Air France)</li><li>`3008` (Lufthansa)</li><li>`3009` (Air Canada)</li><li>`3010` (KLM)</li><li>`3011` (AeroFlot)</li><li>`3012` (Qantas)</li><li>`3013` (Alitalia)</li><li>`3014` (Saudi Arabian Airlines)</li><li>`3015` (SWISS)</li><li>`3016` (SAS)</li><li>`3017` (South African Airway)</li><li>`3018` (Varig (Brazil))</li><li>`3020` (Air India)</li><li>`3021` (Air Algerie)</li><li>`3022` (PAL AIR)</li><li>`3023` (Mexicana)</li><li>`3024` (Pakistan International)</li><li>`3025` (Air New Zealand Ltd.)</li><li>`3026` (Emirates Airlines)</li><li>`3027` (UTA/InterAir)</li><li>`3028` (Air Malta)</li><li>`3029` (SN Brussels Airlines - SN BRUSSELS)</li><li>`3030` (Aerolineas Argentinas)</li><li>`3031` (Olympic Airways)</li><li>`3032` (El Al)</li><li>`3033` (Ansett Airlines)</li><li>`3034` (ETIHADAIR)</li><li>`3035` (TAP (Portugal))</li><li>`3036` (VASP (Brazil))</li><li>`3037` (EgyptAir)</li><li>`3038` (Kuwait Airways)</li><li>`3039` (Avianca)</li><li>`3040` (GulfAir (Bahrain))</li><li>`3041` (Balkan-Bulgarian)</li><li>`3042` (FinnAir)</li><li>`3043` (Aer Lingus)</li><li>`3044` (Air Lanka)</li><li>`3045` (Nigeria Airways)</li><li>`3046` (Cruzeiro do Sul (Bra))</li><li>`3047` (THY (Turkey))</li><li>`3048` (Royal Air Maroc)</li><li>`3049` (Tunis Air)</li><li>`3050` (Icelandair)</li><li>`3051` (Austrian Airlines)</li><li>`3052` (LANAIR)</li><li>`3053` (AVIACO (Spain))</li><li>`3054` (Ladeco (Chile))</li><li>`3055` (LAB (Bolivia))</li><li>`3056` (JetAir)</li><li>`3057` (Virgin America  VIR AMER)</li><li>`3058` (Delta)</li><li>`3059` (DBA Airlines-DBA AIR)</li><li>`3060` (NWA Air)</li><li>`3061` (Continental)</li><li>`3062` (Hapag-Lloyd Express - HLX)</li><li>`3063` (US Airways)</li><li>`3064` (Adria Airways)</li><li>`3065` (Airinter (AirInternational))</li><li>`3066` (Southwest)</li><li>`3068` (AIR STANA)</li><li>`3069` (Sun Country Air)</li><li>`3070` (Pacific Southwest Airlines (PSA))</li><li>`3071` (Air British Columbia)</li><li>`3072` (CEBU PAC)</li><li>`3073` (Air Cal)</li><li>`3075` (Singapore Airlines)</li><li>`3076` (Aeromexico)</li><li>`3077` (Thai Airways)</li><li>`3078` (China Airlines)</li><li>`3079` (Jetstar Airways - Jetstar)</li><li>`3081` (NordAir)</li><li>`3082` (Korean Airlines)</li><li>`3083` (Air Afrique)</li><li>`3084` (Eva Airlines)</li><li>`3085` (Midwest Express Airlines, Inc)</li><li>`3087` (Metro Airlines)</li><li>`3088` (Croatia Airlines)</li><li>`3089` (Tans Saero)</li><li>`3090` (Uni Airways)</li><li>`3094` (Zambia Airways)</li><li>`3096` (Air Zimbabwe)</li><li>`3097` (Spanair (abbreviation: SPANAIR))</li><li>`3098` (Asiana Airlines)</li><li>`3099` (Cathay Pacific)</li><li>`3100` (Malaysian Airline Sys)</li><li>`3102` (Iberia)</li><li>`3103` (Garuda (Indonesia))</li><li>`3105` (Piedmont)</li><li>`3106` (Braathens S.A.F.E. (Norway))</li><li>`3110` (Wings Airways)</li><li>`3111` (British Midland)</li><li>`3112` (Windward Island)</li><li>`3117` (Venezolana Int de Aviacion)</li><li>`3118` (Valley Airlines)</li><li>`3125` (Tan Airlines)</li><li>`3126` (Talair PTY Ltd.)</li><li>`3127` (Taca International)</li><li>`3129` (Surinam Airways)</li><li>`3130` (Sunworld International Airways)</li><li>`3131` (VLM Air)</li><li>`3132` (Frontier Airlines)</li><li>`3133` (Sunbelt Airlines)</li><li>`3135` (Sudan Airlines)</li><li>`3136` (Qatar Air)</li><li>`3137` (Singleton)</li><li>`3138` (Simmons Airlines)</li><li>`3141` (Seair Alaska)</li><li>`3143` (Scenic Airlines)</li><li>`3144` (Virgin Atlantic)</li><li>`3145` (San Juan)</li><li>`3146` (Luxair)</li><li>`3148` (Air Littoral SA)</li><li>`3151` (Air Laire)</li><li>`3154` (Princeville)</li><li>`3156` (Go Fly)</li><li>`3159` (PBA-Provincetwn-Bstn Air)</li><li>`3161` (All Nippon Airways)</li><li>`3164` (Norontair)</li><li>`3165` (New York Helicopter)</li><li>`3167` (Aero Continente - AEROCONTINENTE)</li><li>`3170` (Mount Cook)</li><li>`3171` (Canadian Airlines)</li><li>`3172` (Nation Air)</li><li>`3174` (JetBlue Airways)</li><li>`3175` (Middle East Air)</li><li>`3176` (Metroflight Airlines)</li><li>`3177` (AirTran Airways)</li><li>`3178` (Mesa Air)</li><li>`3180` (Westjet Airlines-WESTJET)</li><li>`3181` (Malev Hungarian Airlines)</li><li>`3182` (LOT (Poland))</li><li>`3183` (Oman Aviation - OMAN AIR)</li><li>`3184` (LIAT)</li><li>`3185` (LAV (Venezuela))</li><li>`3186` (LAP (Paraguay))</li><li>`3187` (LACSA (Costa Rica))</li><li>`3188` (Virgin Express - VIR EXP)</li><li>`3190` (Jugoslav Air)</li><li>`3191` (Island Airlines)</li><li>`3192` (Iran Air)</li><li>`3193` (Indian Airlines)</li><li>`3195` (Holiday Airlines)</li><li>`3196` (Hawaiian Air)</li><li>`3197` (Havasu Airlines)</li><li>`3198` (Harbor Airlines)</li><li>`3199` (Servicios Aereos Militares)</li><li>`3200` (Guyana Airways)</li><li>`3203` (Golden Pacific Air)</li><li>`3204` (Freedom Airlines)</li><li>`3206` (China Eastern Airlines (Abbr: China East Air))</li><li>`3207` (Empresa Ecuatoriana)</li><li>`3211` (Norwegian Air Shuttle - NORWEGIANAIR)</li><li>`3212` (Dominicana de Aviacion)</li><li>`3213` (Malmo Aviation - MALMO AV)</li><li>`3215` (Dan Air Services)</li><li>`3216` (Cumberland Airlines)</li><li>`3217` (CSA-Ceskoslovenske Aeroln)</li><li>`3218` (Crown Air)</li><li>`3219` (Copa)</li><li>`3220` (Compania Faucett)</li><li>`3221` (Transportes Aeros Mil)</li><li>`3222` (Command Airways)</li><li>`3223` (Comair)</li><li>`3226` (Skyways Air- SKYWAYS)</li><li>`3228` (Cayman Airways)</li><li>`3229` (SAETA)</li><li>`3231` (SAHSA)</li><li>`3233` (Capitol Air)</li><li>`3234` (CARIBAIR)</li><li>`3235` (Brockway Air)</li><li>`3236` (Air Arabia Airlines - Air Arab)</li><li>`3238` (Bemidji Aviation)</li><li>`3239` (Bar Harbor Airlines)</li><li>`3240` (Bahamasair)</li><li>`3241` (Aviateca (Guatemala))</li><li>`3242` (Avensa)</li><li>`3243` (Austrian Air Service)</li><li>`3245` (Easy Jet - EASYJET)</li><li>`3246` (Ryan Air - RYANAIR)</li><li>`3247` (Gol Airlines - GOL)</li><li>`3248` (Tam Airlines - TAM)</li><li>`3251` (Aloha Airlines)</li><li>`3252` (ALM-Antilean Airlines)</li><li>`3253` (America West)</li><li>`3254` (U.S. Air Shuttle)</li><li>`3256` (Alaska Airlines Inc.)</li><li>`3259` (American Trans Air)</li><li>`3260` (Spirit Airlines - SPIRIT)</li><li>`3261` (Air China)</li><li>`3262` (Reno Air)</li><li>`3263` (Aero Servicio Carabobo)</li><li>`3266` (Air Seychelles)</li><li>`3267` (Air Panama International)</li><li>`3268` (Air Pacific)</li><li>`3275` (Air Nevada)</li><li>`3276` (Air Midwest)</li><li>`3277` (Air Madagascar)</li><li>`3279` (Air LA)</li><li>`3280` (Air Jamaica)</li><li>`3282` (Air Djibouti)</li><li>`3284` (Aero Virgin Islands)</li><li>`3285` (AeroPeru)</li><li>`3286` (Aero Nicaraguensis)</li><li>`3287` (Aero Coach Aviation)</li><li>`3291` (Ariana Afghan)</li><li>`3292` (Cyprus Airways)</li><li>`3293` (Ecuatoriana)</li><li>`3294` (Ethiopian Airlines)</li><li>`3295` (Kenya Airways)</li><li>`3296` (Air Berlin-AIRBERLIN)</li><li>`3297` (Tarom Romanian Air Transport)</li><li>`3298` (Air Mauritius)</li><li>`3299` (Wideroe\'s Flyveselskap)</li><li>`3351` (Affiliated Auto Rental)</li><li>`3352` (American International)</li><li>`3353` (Brooks Rent a Car)</li><li>`3354` (Action Auto Rental)</li><li>`3355` (SIXT Car Rental)</li><li>`3357` (Hertz)</li><li>`3359` (Payless Car Rental)</li><li>`3360` (Snappy Car Rental)</li><li>`3361` (Airways Rent a Car)</li><li>`3362` (Altra Auto Rental)</li><li>`3364` (Agency Rent a Car)</li><li>`3366` (Budget Rent a Car)</li><li>`3368` (Holiday R-A-C)</li><li>`3370` (Rent-a-Wreck)</li><li>`3374` (Accent Rent-A-Car)</li><li>`3376` (Ajax R-A-C)</li><li>`3380` (Triangle Rent a Car)</li><li>`3381` (Europ Car)</li><li>`3385` (Tropical R-A-C)</li><li>`3386` (Showcase Rental Cars)</li><li>`3387` (Alamo Rent a Car)</li><li>`3388` (Merchants Rent-A-Car, Inc)</li><li>`3389` (Avis R-A-C)</li><li>`3390` (Dollar R-A-C)</li><li>`3391` (Europe by Car)</li><li>`3393` (National Car Rental)</li><li>`3394` (Kemwell Group R-A-C)</li><li>`3395` (Thrify Car Rental)</li><li>`3396` (Tilden R-A-C)</li><li>`3398` (Econo Car R-A-C)</li><li>`3400` (Auto Host Car Rentals)</li><li>`3405` (Enterprise R-A-C)</li><li>`3409` (General Rent-a-Car)</li><li>`3412` (A-1 R-A-C)</li><li>`3414` (Godfrey National)</li><li>`3420` (ANSA International)</li><li>`3421` (Allstate Rent-a-Car)</li><li>`3423` (Avcar Rent-a-Car)</li><li>`3425` (Automate Rent-a-Car)</li><li>`3427` (Avon Rent-a-Car)</li><li>`3428` (Carey Rent-a-Car)</li><li>`3429` (Insurance Rent-a-Car)</li><li>`3430` (Major Rent-a-Car)</li><li>`3431` (Replacement Rent-a-Car)</li><li>`3432` (Reserve Rent-a-Car)</li><li>`3433` (Ugly Duckling R-A-C)</li><li>`3434` (USA Rent-a-Car)</li><li>`3435` (Value Rent-a-Car)</li><li>`3436` (Autohansa Rent-a-Car)</li><li>`3437` (Cite)</li><li>`3438` (Interenet Rent-a-Car)</li><li>`3439` (Millville Rent-a-Car)</li><li>`3441` (Advantage Rent A Car)</li><li>`3501` (Holiday Inns)</li><li>`3502` (Best Western Hotels)</li><li>`3503` (Sheraton)</li><li>`3504` (Hilton)</li><li>`3505` (Forte Hotels)</li><li>`3506` (Golden Tulip Hotels)</li><li>`3507` (Friendship Inns)</li><li>`3508` (Quality Inns)</li><li>`3509` (Marriott)</li><li>`3510` (Days Inn Colonial Resort)</li><li>`3511` (Arabella Hotels)</li><li>`3512` (Intercontinental Hotels)</li><li>`3513` (Westin)</li><li>`3514` (Amerisuites)</li><li>`3515` (Rodeway Inn)</li><li>`3516` (LaQuinta Motor Inns)</li><li>`3517` (Americana Hotels)</li><li>`3518` (Sol Hotels)</li><li>`3519` (Pullman International Hotels)</li><li>`3520` (Meridien Hotels)</li><li>`3521` (Royal Lahaina Resort)</li><li>`3522` (Tokyo Group)</li><li>`3523` (Peninsula Hotels)</li><li>`3524` (WelcomGroup Hotels)</li><li>`3525` (Dunfey Hotels)</li><li>`3526` (Prince Hotels)</li><li>`3527` (Downtowner Passport)</li><li>`3528` (Red Lion Inns)</li><li>`3529` (CP (Canadian Pacific))</li><li>`3530` (Renaissance Hotels)</li><li>`3531` (Kauai Coconut Beach Resort)</li><li>`3532` (Royal Kona Resort)</li><li>`3533` (Hotel Ibis)</li><li>`3534` (Southern Pacific)</li><li>`3535` (Hilton International)</li><li>`3536` (AMFAC Hotels)</li><li>`3537` (ANA Hotels)</li><li>`3538` (Concorde Hotels)</li><li>`3539` (Summerfield Suites Hotel)</li><li>`3540` (Iberotel Hotels)</li><li>`3541` (Hotel Okura)</li><li>`3542` (Royal Hotels)</li><li>`3543` (Four Seasons)</li><li>`3544` (Cigna Hotels)</li><li>`3545` (Shangri-La International)</li><li>`3546` (Hotel Sierra)</li><li>`3548` (Hotels Melia)</li><li>`3549` (Auberge des Governeurs)</li><li>`3550` (Regal 8 Inns)</li><li>`3551` (Mirage Hotel and Casino)</li><li>`3552` (Coast Hotel)</li><li>`3553` (Park Inn by Radisson)</li><li>`3554` (Pinehurst Resort)</li><li>`3555` (Treasure Island Hotel and Casino)</li><li>`3556` (Barton Creek Resort)</li><li>`3557` (Manhattan East Suite Hotels)</li><li>`3558` (Jolly Hotels)</li><li>`3559` (Candlewood Suites)</li><li>`3560` (Aladdin Resort and Casino)</li><li>`3561` (Golden Nugget)</li><li>`3562` (Comfort Inns)</li><li>`3563` (Journey\'s End Motels)</li><li>`3564` (Sam\'s Town Hotel and Casino)</li><li>`3565` (Relax Inns)</li><li>`3566` (Garden Place Hotel)</li><li>`3567` (Soho Grand Hotel)</li><li>`3568` (Ladbroke Hotels)</li><li>`3569` (Tribeca Grand Hotel)</li><li>`3570` (Forum Hotels)</li><li>`3571` (Grand Wailea Resort)</li><li>`3572` (Miyako Hotel)</li><li>`3573` (Sandman Hotels)</li><li>`3574` (Venture Inn)</li><li>`3575` (Vagabond Hotels)</li><li>`3576` (La Quinta Resort)</li><li>`3577` (Mandarin Oriental Hotel)</li><li>`3578` (Frankenmuth Bavarian)</li><li>`3579` (Hotel Mercure)</li><li>`3580` (Hotel Del Coronado)</li><li>`3581` (Delta Hotels)</li><li>`3582` (California Hotel and Casino)</li><li>`3583` (Radisson BLU)</li><li>`3584` (Princess Hotels International)</li><li>`3585` (Hungar Hotels)</li><li>`3586` (Sokos Hotels)</li><li>`3587` (Doral Hotels)</li><li>`3588` (Helmsley Hotels)</li><li>`3589` (Doral Golf Resort)</li><li>`3590` (Fairmont Hotel)</li><li>`3591` (Sonesta Hotels)</li><li>`3592` (Omni Hotels)</li><li>`3593` (Cunard Hotels)</li><li>`3594` (Arizona Biltmore)</li><li>`3595` (Hospitality Inns)</li><li>`3596` (Wynn Las Vegas)</li><li>`3597` (Riverside Resort and Casino)</li><li>`3598` (Regent International Hotels)</li><li>`3599` (Pannonia Hotels)</li><li>`3600` (Saddlebrook Resort - Tampa)</li><li>`3601` (Trade Winds Resorts)</li><li>`3602` (Hudson Hotel)</li><li>`3603` (Noah\'s Hotel)</li><li>`3604` (Hilton Garden Inn)</li><li>`3605` (Jurys Doyle Hotel Group)</li><li>`3606` (Jefferson Hotel)</li><li>`3607` (Fountainebleau Resort)</li><li>`3608` (Gaylord Opryland)</li><li>`3609` (Gaylord Palms)</li><li>`3610` (Gaylord Texan)</li><li>`3611` (C MON INN)</li><li>`3612` (Movenpick Hotels)</li><li>`3613` (Microtel Inns & Suites)</li><li>`3614` (Americinn)</li><li>`3615` (Travelodge Motels)</li><li>`3617` (America\'s Best Value Inn)</li><li>`3618` (Great Wolf)</li><li>`3619` (Aloft)</li><li>`3620` (Binion\'s Horseshoe Club)</li><li>`3621` (Extended Stay)</li><li>`3622` (Merlin Hotel)</li><li>`3623` (Dorint Hotels)</li><li>`3624` (Lady Luck Hotel and Casino)</li><li>`3625` (Hotel Universale)</li><li>`3626` (Studio Plus)</li><li>`3627` (Extended Stay America)</li><li>`3628` (Excalibur Hotel and Casino)</li><li>`3629` (Dan Hotels)</li><li>`3630` (Extended Stay Deluxe)</li><li>`3631` (Sleep Inn)</li><li>`3632` (The Phoenician)</li><li>`3633` (Rank Hotels)</li><li>`3634` (Swissotel)</li><li>`3635` (Reso Hotel)</li><li>`3636` (Sarova Hotels)</li><li>`3637` (Ramada Inns)</li><li>`3638` (Howard Johnson)</li><li>`3639` (Mount Charlotte Thistle)</li><li>`3640` (Hyatt Motels)</li><li>`3641` (Sofitel Hotels)</li><li>`3642` (Novotel)</li><li>`3643` (Steigenberger Hotels)</li><li>`3644` (EconoLodges)</li><li>`3645` (Queens Moat Houses)</li><li>`3646` (Swallow Hotels)</li><li>`3647` (Husa Hotels)</li><li>`3648` (De Vere Hotels)</li><li>`3649` (Radisson)</li><li>`3650` (Red Roof Inns)</li><li>`3651` (Imperial London Hotel)</li><li>`3652` (Embassy Hotels)</li><li>`3653` (Penta Hotels)</li><li>`3654` (Loews Hotels)</li><li>`3655` (Scandic Hotels)</li><li>`3656` (Sara Hotels)</li><li>`3657` (Oberoi Hotels)</li><li>`3658` (New Otani Hotels)</li><li>`3659` (Taj Hotels International)</li><li>`3660` (Knights Inn)</li><li>`3661` (Metropole Hotels)</li><li>`3662` (Circus Circus Hotel and Casino)</li><li>`3663` (Hoteles El Presidente)</li><li>`3664` (Flag Inns)</li><li>`3665` (Hampton Inn Hotels)</li><li>`3666` (Stakis Hotels)</li><li>`3667` (Luxor Hotel and Casino)</li><li>`3668` (Maritim Hotels)</li><li>`3669` (Eldorado Hotel and Casino)</li><li>`3670` (Arcade Hotels)</li><li>`3671` (Arctia Hotels)</li><li>`3672` (Campanile Hotels)</li><li>`3673` (IBUSZ Hotels)</li><li>`3674` (Rantasipi Hotels)</li><li>`3675` (Interhotel CEDOK)</li><li>`3676` (Monte Carlo Hotel and Casino)</li><li>`3677` (Climat de France Hotels)</li><li>`3678` (Cumulus Hotels)</li><li>`3679` (Silver Legacy Hotel and Casino)</li><li>`3680` (Hoteis Othan)</li><li>`3681` (Adams Mark Hotels)</li><li>`3682` (Sahara Hotel and Casino)</li><li>`3683` (Bradbury Suites)</li><li>`3684` (Budget Hosts Inns)</li><li>`3685` (Budgetel Hotels)</li><li>`3686` (Suisse Chalet)</li><li>`3687` (Clarion Hotels)</li><li>`3688` (Compri Hotels)</li><li>`3689` (Consort Hotels)</li><li>`3690` (Courtyard Inns)</li><li>`3691` (Dillon Inn)</li><li>`3692` (Doubletree)</li><li>`3693` (Drury Inn)</li><li>`3694` (Economy Inns of America)</li><li>`3695` (Embassy Suites)</li><li>`3696` (Excel Inn)</li><li>`3697` (Fairfield Hotels)</li><li>`3698` (Harley Hotels)</li><li>`3699` (Midway Motor Lodge)</li><li>`3700` (Motel 6)</li><li>`3701` (La Mansion Del Rio)</li><li>`3702` (The Registry Hotels)</li><li>`3703` (Residence Inn)</li><li>`3704` (Royce Hotels)</li><li>`3705` (Sandman Inn)</li><li>`3706` (Shilo Inn)</li><li>`3707` (Shoney\'s Inn)</li><li>`3708` (Virgin River Hotel and Casino)</li><li>`3709` (Super 8 Motels)</li><li>`3710` (The Ritz Carlton Hotels)</li><li>`3711` (Flag Inns (Australia))</li><li>`3712` (Buffalo Bill\'s Hotel and Casino)</li><li>`3713` (Quality Pacific Hotel)</li><li>`3714` (Four Seasons Hotels-Austr)</li><li>`3715` (Fairfield Inn)</li><li>`3716` (Carlton Hotels)</li><li>`3717` (City Lodge Hotels)</li><li>`3718` (Karos Hotels)</li><li>`3719` (Protea Hotels)</li><li>`3720` (Southern Sun Hotels)</li><li>`3721` (Hilton Conrad Hotels)</li><li>`3722` (Wyndham Hotels)</li><li>`3723` (Rica Hotels)</li><li>`3724` (Inter Nor Hotels)</li><li>`3725` (SeaPines Plantation)</li><li>`3726` (Rio Suites)</li><li>`3727` (Broadmoor Hotel)</li><li>`3728` (Bally\'s Hotel and Casino)</li><li>`3729` (John Ascuaga\'s Nugget)</li><li>`3730` (MGM Grand Hotel)</li><li>`3731` (Harrah\'s Hotels and Casinos)</li><li>`3732` (Opryland Hotel)</li><li>`3733` (Boca Raton Resort)</li><li>`3734` (Harvey/Bristol Hotels)</li><li>`3735` (Master Economy Inns)</li><li>`3736` (Colorado Belle/Edgewater Resort)</li><li>`3737` (Riviera Hotel and Casino)</li><li>`3738` (Tropicana Resort & Casino)</li><li>`3739` (Woodside Hotels & Resorts)</li><li>`3740` (Towneplace Suites)</li><li>`3741` (Millennium Hotel)</li><li>`3742` (Club Med)</li><li>`3743` (Biltmore Hotel and Suites)</li><li>`3744` (Carefree Resorts)</li><li>`3745` (St. Regis Hotel)</li><li>`3746` (The Eliot Hotel)</li><li>`3747` (ClubCorp/ClubResorts)</li><li>`3748` (Wellesley Inns)</li><li>`3749` (The Beverly Hills Hotel)</li><li>`3750` (Crown Plaza Hotels)</li><li>`3751` (Homewood Suites)</li><li>`3752` (Peabody Hotels)</li><li>`3753` (Greenbriar Resorts)</li><li>`3754` (Amelia Island Plantation)</li><li>`3755` (The Homestead)</li><li>`3757` (Canyon Ranch)</li><li>`3758` (Kahala Mandarion Oriental Hotel)</li><li>`3759` (The Orchid at Mauna Lani)</li><li>`3760` (Halekulani Hotel/Waikiki Parc)</li><li>`3761` (Primadonna Hotel and Casino)</li><li>`3762` (Whisky Pete\'s Hotel and Casino)</li><li>`3763` (Chateau Elan Winery and Resort)</li><li>`3764` (Beau Rivage Hotel and Casino)</li><li>`3765` (Bellagio)</li><li>`3766` (Fremont Hotel and Casino)</li><li>`3767` (Main Street Hotel and Casino)</li><li>`3768` (Silver Star Hotel and Casino)</li><li>`3769` (Stratosphere Hotel and Casino)</li><li>`3770` (SpringHill Suites)</li><li>`3771` (Caesar\'s Resort)</li><li>`3772` (Nemacolin Woodlands)</li><li>`3773` (The Venetian Resort Hotel and Casino)</li><li>`3774` (New York-New York Hotel and Casino)</li><li>`3775` (Sands Resort)</li><li>`3776` (Nevele Grande Resort and Country Club)</li><li>`3777` (Mandalay Bay Resort)</li><li>`3778` (Four Points Hotels)</li><li>`3779` (W Hotels)</li><li>`3780` (Disney Resorts)</li><li>`3781` (Patricia Grand Resort Hotels)</li><li>`3782` (Rosen Hotels & Resort)</li><li>`3783` (Town and Country Resort and Convention Center)</li><li>`3784` (First Hospitality Hotel)</li><li>`3785` (Outrigger Hotels and Resorts)</li><li>`3786` (Ohana Hotel of Hawaii)</li><li>`3787` (Caribe Royale Resort Suites & Villas)</li><li>`3788` (Ala Moana Hotel / Ala Moana Hotels)</li><li>`3789` (Smugglers\' Notch Resort)</li><li>`3790` (Raffles Hotels)</li><li>`3791` (Staybridge Suites)</li><li>`3792` (Claridge Casino Hotel)</li><li>`3793` (The Flamingo Hotels)</li><li>`3794` (Grand Casino Hotels)</li><li>`3795` (Paris Las Vegas Hotel)</li><li>`3796` (Peppermill Hotel Casino)</li><li>`3797` (Atlantic City Hilton)</li><li>`3798` (Embassy Vacation Resort)</li><li>`3799` (Hale Koa Hotel)</li><li>`3800` (Homestead)</li><li>`3801` (Wilderness Hotel and Golf Resort)</li><li>`3802` (The Palace Hotel)</li><li>`3807` (Element)</li><li>`3808` (LXR)</li><li>`3810` (La Costa Resort)</li><li>`3811` (Premier Travel Inn)</li><li>`3812` (Hyatt Place)</li><li>`3813` (Hotel Indigo)</li><li>`3814` (The Roosevelt Hotel NY)</li><li>`3815` (Holiday Inn Nickelodeon)</li><li>`3816` (Home2 Suites)</li><li>`3817` (Affinia)</li><li>`3818` (Mainstay Suites)</li><li>`3819` (Oxford Suites)</li><li>`3820` (Jumeirah Essex House)</li><li>`3821` (Caribe Royale)</li><li>`3822` (Crossland)</li><li>`3823` (Grand Sierra Resort)</li><li>`3824` (Aria)</li><li>`3825` (Vdara)</li><li>`3826` (Autograph)</li><li>`3827` (Galt House)</li><li>`3828` (Cosmopolitan of Las Vegas)</li><li>`3829` (Country Inn by Carlson)</li><li>`3830` (Park Plaza Hotel)</li><li>`3831` (Waldorf)</li><li>`4011` (Railroads)</li><li>`4111` (Local and Suburban Commuter Passenger Transportation, including Ferries)</li><li>`4112` (Passenger Rail (train))</li><li>`4119` (Ambulance Services)</li><li>`4121` (Taxicabs and Limousines)</li><li>`4131` (Bus Lines, includes Charters/Tour Buses)</li><li>`4214` (Motor Freight Carriers and Trucking-Local and Long Distance, Moving & Storage Companies, and Local Delivery)</li><li>`4215` (Courier Services-Air and Ground, and Freight Forwarders)</li><li>`4225` (Public Warehousing-Farm products, Refrigerated Goods, Household Goods, and Storage)</li><li>`4411` (Steamship and Cruise Lines)</li><li>`4457` (Boat Rentals and Leasing)</li><li>`4468` (Marinas, Marine Service, and Supplies)</li><li>`4511` (Airlines and Air Carriers)</li><li>`4582` (Airports, Flying Fields, and Airport Terminals)</li><li>`4722` (Travel Agencies)</li><li>`4723` (Package Tour Operators (Germany Only))</li><li>`4761` (Telemarketing of Travel Related Services and Vitamins)</li><li>`4784` (Bridge and Road Fees, Tolls)</li><li>`4789` (Transportation Services-not elsewhere classified)</li><li>`4812` (Telecommunication Equipment and Telephone Sales)</li><li>`4813` (Special Telecom Merchant)</li><li>`4814` (Telecommunication Services, Including Local and Long Distance Calls, Credit Card Calls, Call Through Use of Magnetic-Strip-Reading Telephones, and Fax Services)</li><li>`4815` (Monthly Summary Telephone Charges)</li><li>`4816` (Computer Network/Information Services and other Online Services such as electronic bulletin board, e-mail, web site hosting services, or Internet access)</li><li>`4821` (Telegraph Services)</li><li>`4829` (Quasi Cash - Money Transfer)</li><li>`4899` (Cable, Satellite, and Other Pay Television and Radio Services)</li><li>`4900` (Utilities-Electric, Gas, Water, and Sanitary)</li><li>`5013` (Motor Vehicle Supplies and New Parts (Business to Business MCC))</li><li>`5021` (Office Furniture (Business to Business MCC))</li><li>`5039` (Construction Materials Not Elsewhere Classified (Business to Business MCC))</li><li>`5044` (Photographic, Photocopy, Microfilm Equipment and Supplies (Business to Business MCC))</li><li>`5045` (Computers, Computer Peripheral Equipment, and Software)</li><li>`5046` (Commercial Equipment Not Elsewhere Classified (Business to Business MCC))</li><li>`5047` (Dental/Laboratory/Medical/Ophthalmic Hospital Equipment and Supplies)</li><li>`5051` (Metal Service Centers and Offices (Business to Business MCC))</li><li>`5065` (Electrical Parts and Equipment (Business to Business MCC))</li><li>`5072` (Hardware, Plumbing, Heat Equipment and Supplies (Business to Business MCC))</li><li>`5074` (Plumbing and Heating Equipment and Supplies (Business to Business MCC))</li><li>`5085` (Industrial Supplies Not Elsewhere Classified (Business to Business MCC))</li><li>`5094` (Precious Stones, Metals, Watches and Jewelry (Business to Business MCC))</li><li>`5099` (Durable Goods Not Elsewhere Classified (Business to Business MCC))</li><li>`5111` (Stationery, Office Supplies, and Printing and Writing Paper)</li><li>`5122` (Drugs, Drug Proprietary\'s, and Druggists\' Sundries)</li><li>`5131` (Piece Goods, Notions and Other Dry Goods (Business to Business MCC))</li><li>`5137` (Men\'s, Women\'s and Children\'s Uniforms (Business to Business MCC))</li><li>`5139` (Commercial Footwear (Business to Business MCC))</li><li>`5169` (Chemicals and Allied Products Not Elsewhere Classified (Business to Business MCC))</li><li>`5172` (Petroleum and Products (Business to Business MCC))</li><li>`5192` (Books, Periodicals and Newspapers (Business to Business MCC))</li><li>`5193` (Florist Suppliers, Nursery Stock & Flowers (Business to Business MCC))</li><li>`5198` (Paints, Varnishes and Supplies (Business to Business MCC))</li><li>`5199` (Non-durable Goods Not Elsewhere Classified (Business to Business MCC))</li><li>`5200` (Home Supply Warehouse)</li><li>`5211` (Lumber & Building Materials Stores)</li><li>`5231` (Glass, Paint, and Wallpaper Stores)</li><li>`5251` (Hardware Stores, Equipment Utilities Regulated)</li><li>`5261` (Nurseries and Lawn and Garden Supply Stores)</li><li>`5271` (Mobile Home Dealer)</li><li>`5300` (Wholesale Club with or without membership fee)</li><li>`5309` (Duty Free Stores)</li><li>`5310` (Discount Store)</li><li>`5311` (Department Stores)</li><li>`5331` (Variety Stores)</li><li>`5399` (Miscellaneous General Merchandise)</li><li>`5411` (Grocery Stores and Supermarkets)</li><li>`5422` (Freezer & Locker Meat Provisions)</li><li>`5441` (Candy, Nut, and Confectionary Stores)</li><li>`5451` (Dairy Product Stores)</li><li>`5462` (Bakeries)</li><li>`5499` (Miscellaneous Food Stores-Convenience Stores and Specialty Markets)</li><li>`5511` (Car and Truck Dealers (New and Used)- Sales, Service, Repairs, Parts, and Leasing)</li><li>`5521` (Car and Truck Dealers (Used)- Sales, Service, Repairs, Parts, and Leasing)</li><li>`5532` (Automotive Tire Stores)</li><li>`5531` (Auto and Home Supply Stores)</li><li>`5533` (Automotive Parts and Accessories Stores)</li><li>`5541` (Service Stations (with or without Ancillary Services))</li><li>`5542` (Automated Fuel Dispensers)</li><li>`5551` (Boat Dealers)</li><li>`5561` (Camper, Recreational and Utility Trailer Dealers)</li><li>`5571` (Motorcycle Dealers)</li><li>`5592` (Motor Home Dealers)</li><li>`5598` (Snowmobile Dealers)</li><li>`5599` (Miscellaneous Automotive, Aircraft, and Farm Equipment Dealers --Not Elsewhere Classified)</li><li>`5611` (Men\'s & Boys\' Clothing and Accessory Stores)</li><li>`5621` (Women\'s Ready-to-Wear Stores)</li><li>`5631` (Women\'s Accessory and Specialty Stores)</li><li>`5641` (Children\'s and Infants\' Wear Stores)</li><li>`5651` (Family Clothing Stores)</li><li>`5655` (Sports and Riding Apparel Stores)</li><li>`5661` (Shoe Stores)</li><li>`5681` (Furriers & Fur Shops)</li><li>`5691` (Men\'s and Women\'s Clothing Stores)</li><li>`5697` (Tailors, Seamstresses, Mending, Alterations)</li><li>`5698` (Wig & Toupee Shops)</li><li>`5699` (Miscellaneous Apparel and Accessory Stores)</li><li>`5712` (Furniture, Home Furnishings, and Equipment Stores, except Appliances)</li><li>`5713` (Floor coverings, Rugs)</li><li>`5714` (Drapery, Window Covering, and Upholstery Stores)</li><li>`5718` (Fireplaces, Fireplace Screens and Accessories Stores)</li><li>`5719` (Miscellaneous Home Furnishing Specialty Stores)</li><li>`5722` (Household Appliance Stores)</li><li>`5732` (Electronics Stores)</li><li>`5733` (Music Stores-Musical Instruments, Pianos, and Sheet Music)</li><li>`5734` (Computer Software Stores)</li><li>`5735` (Record Stores)</li><li>`5811` (Caterers - Prepare & Delivery)</li><li>`5812` (Eating Places and Restaurants)</li><li>`5813` (Drinking Places (Alcoholic Beverages) - Bars, Taverns, Nightclubs, Cocktail Lounges, and Discotheques)</li><li>`5814` (Quick Payment Service-Fast Food Restaurants)</li><li>`5815` (Digital Goods  Media, Books, Movies, Music)</li><li>`5816` (Digital Goods  Games)</li><li>`5817` (Digital Goods  Applications (Excludes Games))</li><li>`5818` (Large Digital Goods Merchant)</li><li>`5912` (Drug Stores and Pharmacies)</li><li>`5921` (Package Stores--Beer, Wine, and Liquor)</li><li>`5931` (Used Merchandise and Secondhand Stores)</li><li>`5932` (Antique Shop)</li><li>`5933` (Pawn Shop)</li><li>`5935` (Wrecking and Salvage Yards)</li><li>`5937` (Antique Reproduction Stores)</li><li>`5940` (Bicycle Shop-Sales and Services)</li><li>`5941` (Sporting Goods Stores)</li><li>`5942` (Book Stores)</li><li>`5943` (Stationery, Office and School Supply Stores)</li><li>`5944` (Jewelry, Watch, Clock, and Silverware Stores)</li><li>`5945` (Hobby, Toy and Game Stores)</li><li>`5946` (Camera and Photographic Supply Stores)</li><li>`5947` (Gift, Card, Novelty, and Souvenir Stores)</li><li>`5948` (Luggage and Leather Goods Stores)</li><li>`5949` (Sewing, Needlework, Fabric, and Piece Good Stores)</li><li>`5950` (Glassware and Crystal Stores)</li><li>`5960` (Direct Marketing Insurance Services)</li><li>`5961` (Mail Order)</li><li>`5962` (Direct Marketing -- Travel Related Arrangement Services)</li><li>`5963` (Direct Selling Establishments/Door to Door Sales)</li><li>`5964` (Catalog Merchant)</li><li>`5965` (Combined Catalog and Retail Merchant)</li><li>`5966` (Outbound Telemarketing Merchant)</li><li>`5967` (Direct Marketing -- Inbound Telemarketing Merchants)</li><li>`5968` (Continuity/Subscription Merchants)</li><li>`5969` (Direct Marketing/Direct Marketers--Not Elsewhere Classified)</li><li>`5970` (Artist Supply and Craft Stores)</li><li>`5971` (Art Dealers and Galleries)</li><li>`5972` (Stamp and Coin Stores)</li><li>`5973` (Religious Goods Stores)</li><li>`5975` (Hearing Aids--Sales, Service, and Supplies)</li><li>`5976` (Orthopedic Goods and Prosthetic Devices)</li><li>`5977` (Cosmetic Stores)</li><li>`5978` (Typewriter Stores--Sales, Service, and Rentals)</li><li>`5983` (Fuel Dealers--Fuel Oil, Wood, Coal, and Liquefied Petroleum)</li><li>`5992` (Florists)</li><li>`5993` (Cigar Stores & Stands)</li><li>`5994` (News Dealers & Newsstands)</li><li>`5995` (Pet Shops, Pet Food, and Supplies)</li><li>`5996` (Swimming Pools--Sales, Supplies, and Services)</li><li>`5997` (Electric Razor Stores Sales & Services)</li><li>`5998` (Tent and Awning Stores)</li><li>`5999` (Miscellaneous & Specialty Retail Stores)</li><li>`6010` (Financial Institutions--Manual Cash Disbursements)</li><li>`6011` (Financial Institutions--Automated Cash Disbursements)</li><li>`6012` (Quasi Cash - Financial Institution - Merchandise and Services)</li><li>`6050` (Quasi Cash - Member Financial Institution)</li><li>`6051` (MasterCard - Quasi Cash-Merchant)</li><li>`6211` (Securities - Brokers and Dealers)</li><li>`6300` (Insurance Sales and Underwriting)</li><li>`6381` (Insurance - Premiums)</li><li>`6399` (Insurance - Not Elsewhere Classified)</li><li>`6513` (Real Estate Agents and Managers - Rentals; Property Management)</li><li>`6529` (Remote Stored Value Load - Member Financial Institution)</li><li>`6530` (Remote Stored Value Load - Merchant)</li><li>`6531` (Payment Service Provider)</li><li>`6532` (Payment Transaction - Member)</li><li>`6533` (Payment Transaction - Merchant)</li><li>`6534` (Money Transfer - Member Financial Institution)</li><li>`6535` (Value Purchase - Member Financial Institution)</li><li>`6536` (MoneySend Intracountry)</li><li>`6537` (MoneySend Intercountry)</li><li>`6538` (MoneySend Funding)</li><li>`6540` (POI Funding Transactions (Excluding MoneySend))</li><li>`7011` (Lodging - Hotels, Motels, and Resorts)</li><li>`7012` (Timeshares)</li><li>`7032` (Sporting and Recreational Camps)</li><li>`7033` (Trailer Parks and Campgrounds)</li><li>`7210` (Laundry, Cleaning, and Garment Services)</li><li>`7211` (Laundry Services - Family and Commercial)</li><li>`7216` (Dry Cleaners)</li><li>`7217` (Carpet and Upholstery Cleaning)</li><li>`7221` (Photographic Studios)</li><li>`7230` (Beauty and Barber Shops)</li><li>`7251` (Shoe Repair Shops, Shoe Shine Parlors, and Hat Cleaning Shops)</li><li>`7261` (Funeral Services and Crematories)</li><li>`7273` (Dating Services)</li><li>`7276` (Tax Preparation Services)</li><li>`7277` (Counseling Services - Debt, Marriage, and Personal)</li><li>`7278` (Buying and Shopping Services and Clubs)</li><li>`7296` (Clothing Rental - Costumes, Uniforms and Formal Wear)</li><li>`7297` (Massage Parlors)</li><li>`7298` (Health and Beauty Spas)</li><li>`7299` (Miscellaneous Personal Services - Not Elsewhere Classified)</li><li>`7311` (Advertising Services)</li><li>`7321` (Consumer Credit Reporting Agencies)</li><li>`7332` (Blueprinting and Photocopying Services)</li><li>`7333` (Commercial Photography, Art, and Graphics)</li><li>`7338` (Quick Copy, Reproduction Service)</li><li>`7339` (Stenographic Service)</li><li>`7342` (Exterminating and Disinfecting Services)</li><li>`7349` (Cleaning, Maintenance & Janitorial Services)</li><li>`7361` (Employment Agencies and Temporary Help Services)</li><li>`7372` (Computer Programming, Data Processing, and Integrated Systems Design Services)</li><li>`7375` (Information Retrieval Services (Business to Business MCC))</li><li>`7379` (Computer Maintenance, Repair and Services (Business to Business MCC))</li><li>`7392` (Management, Consulting, and Public Relations Services)</li><li>`7393` (Detective Agencies, Protective Agencies, and Security Services, including Armored Cars and Guard Dogs)</li><li>`7394` (Equipment, Tool, Furniture, and Appliance Rental and Leasing)</li><li>`7395` (Photofinishing Laboratories and Photo Developing)</li><li>`7399` (Business Services)</li><li>`7511` (Truck Stops)</li><li>`7512` (Automobile Rental Agency)</li><li>`7513` (Truck and Utility Trailer Rentals)</li><li>`7519` (Motor Home and Recreational Vehicle Rentals)</li><li>`7523` (Parking Lots and Garages)</li><li>`7524` (Express Payment Service Mechants - Parking Lots and Garages)</li><li>`7531` (Automotive Top & Body Shops)</li><li>`7534` (Tire Retreading & Repair)</li><li>`7535` (Automotive Paint Shops)</li><li>`7538` (Automotive Service Shops (Non-Dealer))</li><li>`7542` (Car Washes)</li><li>`7549` (Towing Services)</li><li>`7622` (Electronic Repair Shops)</li><li>`7623` (Air Conditioning and Refrigeration Repair Shops)</li><li>`7629` (Electrical and Small Appliance Repair Shops)</li><li>`7631` (Watch, Clock, and Jewelry Repair Shops)</li><li>`7641` (Furniture - Reupholster, Repair, and Refinishing)</li><li>`7692` (Welding Services)</li><li>`7699` (Miscellaneous Repair Shops and Related Services)</li><li>`7778` (Citishare Cash Advance)</li><li>`7800` (Government-Owned Lotteries)</li><li>`7801` (Government-Licensed Casinos (Online Gambling))</li><li>`7802` (Government-Licensed Horse/Dog Racing)</li><li>`7829` (Motion Picture & Video Tape Production and Distribution (Business to Business MCC))</li><li>`7832` (Motion Picture Theater)</li><li>`7841` (DVD/Video Tape Rental Stores)</li><li>`7911` (Dance Halls, Studios & Schools)</li><li>`7922` (Theatrical Producers (except Motion Pictures) and Ticket Agencies)</li><li>`7929` (Bands, Orchestras & Misc Entertainment)</li><li>`7932` (Billiards & Pool Establishments)</li><li>`7933` (Bowling Alleys)</li><li>`7941` (Commercial Sports, Professional Sports Clubs, Athletic Fields, and Sports Promoters)</li><li>`7991` (Tourist Attractions and Exhibits)</li><li>`7992` (Public Golf Courses)</li><li>`7993` (Video Amusement Game Supply)</li><li>`7994` (Video Game Arcades and Establishments)</li><li>`7995` (Betting, including Lottery Tickets, Casino Gaming Chips, Off- Track Betting, and Wagers at Race Track)</li><li>`7996` (Amusement Parks, Circuses, Carnivals, and Fortune Tellers)</li><li>`7997` (Membership Clubs (Sports, Recreation, Athletic), Country Clubs, and Private Golf Courses)</li><li>`7998` (Aquarium, Seaquarium, Dolphinariums)</li><li>`7999` (Recreation Services - Not Elsewhere Classified)</li><li>`8011` (Doctors and Physicians - Not Elsewhere Classified)</li><li>`8021` (Dentists and Orthodontists)</li><li>`8031` (Osteopathic Physicians)</li><li>`8041` (Chiropractors)</li><li>`8042` (Optometrists and Ophthalmologists)</li><li>`8043` (Opticians, Optical Goods and Eyeglasses)</li><li>`8049` (Podiatrists and Chiropodists)</li><li>`8050` (Nursing and Personal Care Facilities)</li><li>`8062` (Hospitals)</li><li>`8071` (Medical and Dental Laboratories)</li><li>`8099` (Medical Services Health Practitioners - No Elsewhere Classified)</li><li>`8111` (Legal Services and Attorneys)</li><li>`8211` (Elementary and Secondary Schools)</li><li>`8220` (Colleges, Universities, Professional Schools, and Junior Colleges)</li><li>`8241` (Correspondence Schools)</li><li>`8244` (Business and Secretarial Schools)</li><li>`8249` (Trade and Vocational Schools)</li><li>`8299` (Schools and Educational Services - Not Elsewhere Classified)</li><li>`8351` (Child Care Services)</li><li>`8398` (Charitable and Social Service Organizations)</li><li>`8641` (Civic, Social, and Fraternal Associations)</li><li>`8651` (Political Organizations)</li><li>`8661` (Religious Organizations)</li><li>`8675` (Automobile Associations)</li><li>`8699` (Membership Organizations - Not Elsewhere Classified)</li><li>`8734` (Testing Laboratories (Not Medical) - (Business to Business MCC))</li><li>`8911` (Architectural, Engineering, and Surveying Services)</li><li>`8931` (Accounting, Auditing, and Bookkeeping Services)</li><li>`8999` (Professional Services - Not Elsewhere Classified)</li><li>`9211` (Court Costs, including Alimony and Child Support)</li><li>`9222` (Fines)</li><li>`9223` (Bail & Bond Payments)</li><li>`9311` (Tax Payments)</li><li>`9399` (Government Services - Not Elsewhere Classified)</li><li>`9401` (i-Purchasing)</li><li>`9402` (Postal Services)</li><li>`9405` (U.S. Fed Government Agencies)</li><li>`9700` (Automated Referral Service)</li><li>`9701` (Visa Credential Server)</li><li>`9702` (GCAS Emergency Services)</li><li>`9751` (U.K. Supermarkets, Electronic Hot File)</li><li>`9752` (U.K. Petrol Stations, Electronic Hot File)</li><li>`9753` (Consumer Electronics/Furniture Store)</li><li>`9754` (Quasi Cash - Gambling-Horse Racing, Dog Racing, State Lotteries)</li><li>`9950` (Intra-Company Purchases)</li></ul>
     * @type {string}
     * @memberof ApplicationResponse
     */
    'merchantCategoryCode'?: string;
    /**
     * The payment user group from the purpose code list for the application.<br><br>Allowed values:<ul><li>WHOLESALE_FI_FI</li><li>COMMERCIAL</li><li>CONSUMER_GOODS_SERVICES</li><li>FINANCE</li><li>INSURANCE</li><li>PROPERTY</li><li>UTILITIES</li><li>TAX</li><li>SALARIES_INCOMES</li><li>INVESTMENTS</li><li>FOREIGN_EXCHANGE</li><li>GOVERNMENT</li><li>BENEFIT_PAYMENTS</li><li>MEDICAL</li><li>PENSIONS</li></ul>
     * @type {string}
     * @memberof ApplicationResponse
     */
    'ppcUserGroup'?: string;
    /**
     * The application callback URLs
     * @type {Array<string>}
     * @memberof ApplicationResponse
     */
    'callbackUrls'?: Array<string>;
    /**
     * Indicates if a contract is in place with the merchant and a KYB process has been completed
     * @type {boolean}
     * @memberof ApplicationResponse
     */
    'isContractPresent'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationResponseListMeta
 */
export interface ApplicationResponseListMeta {
    /**
     * 
     * @type {string}
     * @memberof ApplicationResponseListMeta
     */
    'tracingId'?: string;
    /**
     * The number of applications in the current page.
     * @type {number}
     * @memberof ApplicationResponseListMeta
     */
    'count'?: number;
    /**
     * 
     * @type {ApplicationResponseListMetaPagination}
     * @memberof ApplicationResponseListMeta
     */
    'pagination'?: ApplicationResponseListMetaPagination;
}
/**
 * 
 * @export
 * @interface ApplicationResponseListMetaPagination
 */
export interface ApplicationResponseListMetaPagination {
    /**
     * 
     * @type {ApplicationResponseListMetaPaginationSelf}
     * @memberof ApplicationResponseListMetaPagination
     */
    'self'?: ApplicationResponseListMetaPaginationSelf;
    /**
     * The total number of applications that match the given filter.
     * @type {number}
     * @memberof ApplicationResponseListMetaPagination
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationResponseListMetaPaginationSelf
 */
export interface ApplicationResponseListMetaPaginationSelf {
    /**
     * The number of skipped applications.
     * @type {number}
     * @memberof ApplicationResponseListMetaPaginationSelf
     */
    'offset'?: number;
    /**
     * The maximum number of applications for the current page.
     * @type {number}
     * @memberof ApplicationResponseListMetaPaginationSelf
     */
    'limit'?: number;
    /**
     * The field by which results are sorted by. Default direction is ascending, descending is identified by a \"-\" prefix.
     * @type {string}
     * @memberof ApplicationResponseListMetaPaginationSelf
     */
    'sort'?: string;
}
/**
 * Information about a user of an application.
 * @export
 * @interface ApplicationUser
 */
export interface ApplicationUser {
    /**
     * A unique identifier for the \'User\' assigned by Yapily.
     * @type {string}
     * @memberof ApplicationUser
     */
    'uuid'?: string;
    /**
     * Unique identifier of the application the user is associated with.
     * @type {string}
     * @memberof ApplicationUser
     */
    'applicationUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User`.
     * @type {string}
     * @memberof ApplicationUser
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    'referenceId'?: string;
    /**
     * Date and time of when the user was created.
     * @type {string}
     * @memberof ApplicationUser
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<InstitutionConsent>}
     * @memberof ApplicationUser
     */
    'institutionConsents'?: Array<InstitutionConsent>;
}
/**
 * Current status of the embedded authorisation request in code form.
 * @export
 * @enum {string}
 */

export const AuthorisationStatus = {
    AwaitingAuthorization: 'AWAITING_AUTHORIZATION',
    AwaitingFurtherAuthorization: 'AWAITING_FURTHER_AUTHORIZATION',
    AwaitingReAuthorization: 'AWAITING_RE_AUTHORIZATION',
    Authorized: 'AUTHORIZED',
    Consumed: 'CONSUMED',
    Rejected: 'REJECTED',
    Revoked: 'REVOKED',
    Failed: 'FAILED',
    Expired: 'EXPIRED',
    Unknown: 'UNKNOWN',
    Invalid: 'INVALID',
    AwaitingDecoupledPreAuthorization: 'AWAITING_DECOUPLED_PRE_AUTHORIZATION',
    AwaitingPreAuthorization: 'AWAITING_PRE_AUTHORIZATION',
    PreAuthorized: 'PRE_AUTHORIZED',
    AwaitingDecoupledAuthorization: 'AWAITING_DECOUPLED_AUTHORIZATION',
    AwaitingScaMethod: 'AWAITING_SCA_METHOD',
    AwaitingScaCode: 'AWAITING_SCA_CODE'
} as const;

export type AuthorisationStatus = typeof AuthorisationStatus[keyof typeof AuthorisationStatus];


/**
 * A Balance Prediction profile for a User.
 * @export
 * @interface BalancePredictionProfile
 */
export interface BalancePredictionProfile {
    /**
     * The status, will be COMPLETED which represents successful retreival of profile.
     * @type {string}
     * @memberof BalancePredictionProfile
     */
    'status'?: string;
    /**
     * A list of ProfileConsents used in the Balance Prediction profile.
     * @type {Array<ProfileConsent>}
     * @memberof BalancePredictionProfile
     */
    'profileConsents'?: Array<ProfileConsent>;
    /**
     * A list of Balances returned by Balance Prediction profile.
     * @type {Array<EnrichedBalances>}
     * @memberof BalancePredictionProfile
     */
    'enrichedBalances'?: Array<EnrichedBalances>;
}
/**
 * 
 * @export
 * @interface Balances
 */
export interface Balances {
    /**
     * 
     * @type {Amount}
     * @memberof Balances
     */
    'mainBalanceAmount'?: Amount;
    /**
     * 
     * @type {Array<AccountBalance>}
     * @memberof Balances
     */
    'balances'?: Array<AccountBalance>;
}
/**
 * Account information belonging to the target beneficiary (person/ business).
 * @export
 * @interface Beneficiary
 */
export interface Beneficiary {
    /**
     * Unique identifier of the `beneficiary`.
     * @type {string}
     * @memberof Beneficiary
     */
    'id'?: string;
    /**
     * A creditor reference that is requested to be used for all payment instructions to this beneficiary.
     * @type {string}
     * @memberof Beneficiary
     */
    'reference'?: string;
    /**
     * 
     * @type {BeneficiaryPayee}
     * @memberof Beneficiary
     */
    'payee'?: BeneficiaryPayee;
    /**
     * Indicates whether the account owner has stated that this beneficiary should be trusted. This often results in reduced authentication and authorisation requirements on payments to the beneficiary.
     * @type {boolean}
     * @memberof Beneficiary
     */
    'trusted'?: boolean;
}
/**
 * __Mandatory__. Account details belonging to the `Beneficiary Payee` (person/ business). You must define this in your payment request along with all of the nested mandatory properties.
 * @export
 * @interface BeneficiaryPayee
 */
export interface BeneficiaryPayee {
    /**
     * The account holder name of the beneficiary.
     * @type {string}
     * @memberof BeneficiaryPayee
     */
    'name'?: string;
    /**
     * __Mandatory__. The account identifications that identify the `BeneficiaryPayee` bank account.
     * @type {Set<AccountIdentification>}
     * @memberof BeneficiaryPayee
     */
    'accountIdentifications': Set<AccountIdentification>;
    /**
     * 
     * @type {Address}
     * @memberof BeneficiaryPayee
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface BulkPaymentAuthorisationRequest
 */
export interface BulkPaymentAuthorisationRequest {
    /**
     * __Conditional__. The reference to the `User` that will authorise the authorisation request using the Yapily generated UUID. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {BulkPaymentRequest}
     * @memberof BulkPaymentAuthorisationRequest
     */
    'paymentRequest'?: BulkPaymentRequest;
}
/**
 * The request body containing a `BulkPaymentEmbeddedAuthorisationRequest` json payload
 * @export
 * @interface BulkPaymentEmbeddedAuthorisationRequest
 */
export interface BulkPaymentEmbeddedAuthorisationRequest {
    /**
     * __Conditional__. The reference to the `User` that will authorise the authorisation request using the Yapily generated UUID. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {BulkPaymentRequest}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'paymentRequest'?: BulkPaymentRequest;
    /**
     * 
     * @type {UserCredentials}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'userCredentials'?: UserCredentials;
    /**
     * 
     * @type {ScaMethod}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'selectedScaMethod'?: ScaMethod;
    /**
     * __Conditional__. Used to update the authorisation with the sca code received by the user from the `Institution` using the embedded payment authorisation flow.<br><br>This is the penultimate step required in the embedded payment authorisation flow to authorise the `Consent`. After sending the sca code, to obtain an authorised consent, the last step is to poll [Get Consent](https://docs.yapily.com/api/reference/#operation/getConsentById) until the `Institution` authorises the request and the `Consent` `status` transitions to `AUTHORIZED`.
     * @type {string}
     * @memberof BulkPaymentEmbeddedAuthorisationRequest
     */
    'scaCode'?: string;
}
/**
 * The payment request object defining the details of the bulk payment
 * @export
 * @interface BulkPaymentRequest
 */
export interface BulkPaymentRequest {
    /**
     * __Mandatory__. The array of `PaymentRequest` objects to initiate in the bulk payment.
     * @type {Array<PaymentRequest>}
     * @memberof BulkPaymentRequest
     */
    'payments': Array<PaymentRequest>;
    /**
     * __Conditional__. The identification number of the originator.<ul><li>Mandatory for AIB bulk payments</li></ul>
     * @type {string}
     * @memberof BulkPaymentRequest
     */
    'originatorIdentificationNumber'?: string;
    /**
     * __Optional__. Used to schedule the bulk payment to be executed at a future date if supported by the `Institution`.
     * @type {string}
     * @memberof BulkPaymentRequest
     */
    'executionDateTime'?: string;
}
/**
 * Income and Expense categorisation that the Yapily categorisation engine has determined for the transaction.
 * @export
 * @interface Categorisation
 */
export interface Categorisation {
    /**
     * 
     * @type {Array<string>}
     * @memberof Categorisation
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Categorisation
     */
    'source'?: string;
}
/**
 * Income and Expense `Category` in which the transaction resides.
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Unique identifier of the category
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * Descriptive identifier of the category.
     * @type {string}
     * @memberof Category
     */
    'label'?: string;
    /**
     * The country code of where the category transaction took place, denoted as a 3-digit character code - ISO 3166.
     * @type {string}
     * @memberof Category
     */
    'country'?: string;
    /**
     * 
     * @type {Array<Subcategory>}
     * @memberof Category
     */
    'subcategories'?: Array<Subcategory>;
}
/**
 * __Optional__. Specifies which party/parties will bear the charges associated with the processing of the payment transaction. Valid values are:<ul><li>`DEBT` - All transaction charges are to be borne by the debtor.</li><li>`CRED` - All transaction charges are to be borne by the creditor.</li><li>`SHAR` - In a credit transfer context, means that transaction charges on the sender side are to be borne by the debtor, transaction charges on the receiver side are to be borne by the creditor</li><li>`SLEV` - Charges are to be applied following the rules agreed in the service level and/or scheme.</li></ul>
 * @export
 * @enum {string}
 */

export const ChargeBearerType = {
    Debt: 'DEBT',
    Cred: 'CRED',
    Shar: 'SHAR',
    Slev: 'SLEV'
} as const;

export type ChargeBearerType = typeof ChargeBearerType[keyof typeof ChargeBearerType];


/**
 * __Conditional__. Information needed to complete compliance checks. Mandatory for Yapily Connect customers.
 * @export
 * @interface ComplianceData
 */
export interface ComplianceData {
    /**
     * 
     * @type {ComplianceDataPayer}
     * @memberof ComplianceData
     */
    'payer'?: ComplianceDataPayer;
}
/**
 * This is the registered company or trading address of your end user.
 * @export
 * @interface ComplianceDataAddress
 */
export interface ComplianceDataAddress {
    /**
     * __Mandatory__. AddressLine1 of the business.
     * @type {string}
     * @memberof ComplianceDataAddress
     */
    'addressLine1': string;
    /**
     * __Optional__. AddressLine2 of the business.
     * @type {string}
     * @memberof ComplianceDataAddress
     */
    'addressLine2'?: string;
    /**
     * __Mandatory__. Town name of the business.
     * @type {string}
     * @memberof ComplianceDataAddress
     */
    'townName': string;
    /**
     * __Mandatory__. Post code of the business.
     * @type {string}
     * @memberof ComplianceDataAddress
     */
    'postCode': string;
    /**
     * __Mandatory__. Country of the business.
     * @type {string}
     * @memberof ComplianceDataAddress
     */
    'country': string;
}
/**
 * __Conditional__. Mandatory if the type is BUSINESS.
 * @export
 * @interface ComplianceDataBusiness
 */
export interface ComplianceDataBusiness {
    /**
     * This is the registered company name of your end user.
     * @type {string}
     * @memberof ComplianceDataBusiness
     */
    'name': string;
    /**
     * This is the registered company number of the business.
     * @type {string}
     * @memberof ComplianceDataBusiness
     */
    'registrationNumber': string;
    /**
     * 
     * @type {ComplianceDataAddress}
     * @memberof ComplianceDataBusiness
     */
    'registeredAddress': ComplianceDataAddress;
    /**
     * 
     * @type {ComplianceDataAddress}
     * @memberof ComplianceDataBusiness
     */
    'tradingAddress'?: ComplianceDataAddress;
}
/**
 * __Conditional__. Mandatory if the type is INDIVIDUAL.
 * @export
 * @interface ComplianceDataIndividual
 */
export interface ComplianceDataIndividual {
    /**
     * This is the first and last name of your end user.
     * @type {string}
     * @memberof ComplianceDataIndividual
     */
    'name': string;
    /**
     * This is the date of birth of your end user.
     * @type {string}
     * @memberof ComplianceDataIndividual
     */
    'birthDate': string;
}
/**
 * __Conditional__. Payer details required for compliance checks.
 * @export
 * @interface ComplianceDataPayer
 */
export interface ComplianceDataPayer {
    /**
     * The payer type. Allowed values: INDIVIDUAL, BUSINESS. The corresponding object must be included.
     * @type {string}
     * @memberof ComplianceDataPayer
     */
    'type': string;
    /**
     * 
     * @type {ComplianceDataIndividual}
     * @memberof ComplianceDataPayer
     */
    'individual'?: ComplianceDataIndividual;
    /**
     * 
     * @type {ComplianceDataBusiness}
     * @memberof ComplianceDataPayer
     */
    'business'?: ComplianceDataBusiness;
}
/**
 * Consent detailing the requested authorisation from a user to a specific `Institution`.
 * @export
 * @interface Consent
 */
export interface Consent {
    /**
     * Unique identifier of the consent.
     * @type {string}
     * @memberof Consent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Consent
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof Consent
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Consent
     */
    'referenceId'?: string;
    /**
     * __Mandatory__. The `Institution` the authorisation request is sent to.
     * @type {string}
     * @memberof Consent
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof Consent
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time of when the consent was created.
     * @type {string}
     * @memberof Consent
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof Consent
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof Consent
     */
    'transactionTo'?: string;
    /**
     * Date and time of when the authorisation will expire by. Reauthorisation will be needed to retain access.
     * @type {string}
     * @memberof Consent
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Consent
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof Consent
     */
    'timeToExpire'?: string;
    /**
     * The set of features that the consent will provide access to.
     * @type {Set<FeatureEnum>}
     * @memberof Consent
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to access account information or make a payment request.
     * @type {string}
     * @memberof Consent
     */
    'consentToken'?: string;
    /**
     * Correlation ID used with the `Institution` during the authorisation process.
     * @type {string}
     * @memberof Consent
     */
    'state'?: string;
    /**
     * Date and time of when the request was authorised by the Institution.
     * @type {string}
     * @memberof Consent
     */
    'authorizedAt'?: string;
    /**
     * The time that the PSU last confirmed access to their account information, either through full authentication with the institution, or through reconfirmation with the TPP.
     * @type {string}
     * @memberof Consent
     */
    'lastConfirmedAt'?: string;
    /**
     * The time by which the consent should be reconfirmed to ensure continued access to the account information.
     * @type {string}
     * @memberof Consent
     */
    'reconfirmBy'?: string;
    /**
     * Identification of the consent at the Institution.
     * @type {string}
     * @memberof Consent
     */
    'institutionConsentId'?: string;
    /**
     * Denotes whether the consent has been deleted on the institution side or not when a DELETE method is executed on a Yapily consent if that functionality is provided by the institution
     * @type {boolean}
     * @memberof Consent
     */
    'isDeletedByInstitution'?: boolean;
}


/**
 * The request body containing the `ConsentAuthCodeRequest` json payload
 * @export
 * @interface ConsentAuthCodeRequest
 */
export interface ConsentAuthCodeRequest {
    /**
     * __Mandatory__. The authorisation code
     * @type {string}
     * @memberof ConsentAuthCodeRequest
     */
    'authCode': string;
    /**
     * __Mandatory__. The authorisation state
     * @type {string}
     * @memberof ConsentAuthCodeRequest
     */
    'authState': string;
}
/**
 * 
 * @export
 * @interface ConsentDeleteResponse
 */
export interface ConsentDeleteResponse {
    /**
     * __Conditional__. User-friendly identifier of the `User` that provides authorisation. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof ConsentDeleteResponse
     */
    'id'?: string;
    /**
     * 
     * @type {DeleteStatusEnum}
     * @memberof ConsentDeleteResponse
     */
    'deleteStatus'?: DeleteStatusEnum;
    /**
     * __Mandatory__. The `Institution` the authorisation request is sent to.
     * @type {string}
     * @memberof ConsentDeleteResponse
     */
    'institutionId'?: string;
    /**
     * Identification of the consent at the Institution.
     * @type {string}
     * @memberof ConsentDeleteResponse
     */
    'institutionConsentId'?: string;
    /**
     * Date and time of when the consent was authorised.
     * @type {string}
     * @memberof ConsentDeleteResponse
     */
    'creationDate'?: string;
}


/**
 * Summary information regarding account balances of the overall account provided by the bank
 * @export
 * @interface ConsolidatedAccountInformation
 */
export interface ConsolidatedAccountInformation {
    /**
     * Identifier of the consolidated account. When used in Get Account Transactions calls, the transactions between the sub-accounts will not be reported
     * @type {string}
     * @memberof ConsolidatedAccountInformation
     */
    'id'?: string;
    /**
     * 
     * @type {Array<AccountBalance>}
     * @memberof ConsolidatedAccountInformation
     */
    'accountBalances'?: Array<AccountBalance>;
}
/**
 * An array of `Country` denoting which regions the `Institution` provides coverage for
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Country name.
     * @type {string}
     * @memberof Country
     */
    'displayName'?: string;
    /**
     * Two character ISO 3166 country code.
     * @type {string}
     * @memberof Country
     */
    'countryCode2'?: string;
}
/**
 * 
 * @export
 * @interface CreateHostedPaymentRequest
 */
export interface CreateHostedPaymentRequest {
    /**
     * __Conditional__. Yapily Identifier for the `User` returned by the create user step POST /users. You must provide either a `userId` or `applicationUserId`.
     * @type {string}
     * @memberof CreateHostedPaymentRequest
     */
    'userId'?: string;
    /**
     * __Conditional__. Your own `User` reference. This field allows you to use your own unique references for individual users. Where the `User` reference doesn\'t have an associated Yapily `userId`, a new `userId` is created and linked to it. You must provide either a `userId` or `applicationUserId`.
     * @type {string}
     * @memberof CreateHostedPaymentRequest
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof CreateHostedPaymentRequest
     */
    'institutionIdentifiers': InstitutionIdentifiers;
    /**
     * 
     * @type {UserSettings}
     * @memberof CreateHostedPaymentRequest
     */
    'userSettings'?: UserSettings;
    /**
     * URL of your server to redirect the user after completion of the payment flow.
     * @type {string}
     * @memberof CreateHostedPaymentRequest
     */
    'redirectUrl': string;
    /**
     * 
     * @type {HostedPaymentRequestDetails}
     * @memberof CreateHostedPaymentRequest
     */
    'paymentRequestDetails': HostedPaymentRequestDetails;
}
/**
 * 
 * @export
 * @interface CreateHostedPaymentRequestLink
 */
export interface CreateHostedPaymentRequestLink {
    /**
     * __Conditional__. Yapily Identifier for the `User` returned by the create user step POST /users. You must either provide `userId` or `applicationUserId`.
     * @type {string}
     * @memberof CreateHostedPaymentRequestLink
     */
    'userId'?: string;
    /**
     * __Conditional__. Your own `User` reference. If you want to work with their own unique references for individual PSUs then you can use the `applicationUserId` property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied `applicationUserId`, then a new Yapily userId is created automatically and linked to the `applicationUserId` value. You must either provide userId or `applicationUserId`.
     * @type {string}
     * @memberof CreateHostedPaymentRequestLink
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof CreateHostedPaymentRequestLink
     */
    'institutionIdentifiers': InstitutionIdentifiers;
    /**
     * 
     * @type {UserSettings}
     * @memberof CreateHostedPaymentRequestLink
     */
    'userSettings'?: UserSettings;
    /**
     * URL of your server to redirect the user after completion of the payment flow.
     * @type {string}
     * @memberof CreateHostedPaymentRequestLink
     */
    'redirectUrl': string;
    /**
     * The date and time that the authorisation expires. Must be between 10 minutes and 30 days in the future. If not specified, the authorisation URL will expire 10 minutes after creation.
     * @type {string}
     * @memberof CreateHostedPaymentRequestLink
     */
    'authorisationExpiresAt'?: string;
    /**
     * 
     * @type {HostedPaymentRequestDetailsLink}
     * @memberof CreateHostedPaymentRequestLink
     */
    'paymentRequestDetails': HostedPaymentRequestDetailsLink;
}
/**
 * 
 * @export
 * @interface CreateHostedVRPConsentRequest
 */
export interface CreateHostedVRPConsentRequest {
    /**
     * __Conditional__. Yapily Identifier for the `User` returned by the create user step POST /users. Clients must either provide userId or applicationUserId.
     * @type {string}
     * @memberof CreateHostedVRPConsentRequest
     */
    'userId'?: string;
    /**
     * __Conditional__. Client\'s own `User` reference. If the client wants to work with their own unique references for individual PSUs then they can use the applicationUserId property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied applicationUserId, then a new Yapily userId is created automatically and linked to the applicationUserId value. Clients must either provide userId or applicationUserId.
     * @type {string}
     * @memberof CreateHostedVRPConsentRequest
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof CreateHostedVRPConsentRequest
     */
    'institutionIdentifiers': InstitutionIdentifiers;
    /**
     * 
     * @type {UserSettings}
     * @memberof CreateHostedVRPConsentRequest
     */
    'userSettings'?: UserSettings;
    /**
     * URL of client\'s server to redirect the PSU after completion of the consent authorisation.
     * @type {string}
     * @memberof CreateHostedVRPConsentRequest
     */
    'redirectUrl': string;
    /**
     * Used to receive a oneTimeToken rather than a consentToken at the redirectUrl for additional security. This can only be used when the redirectUrl is set.
     * @type {boolean}
     * @memberof CreateHostedVRPConsentRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {VRPSetupRequest}
     * @memberof CreateHostedVRPConsentRequest
     */
    'vrpSetup': VRPSetupRequest;
}
/**
 * __Mandatory__. The payment request object defining the details of the payment for execution under the Variable Recurring Payment consent.
 * @export
 * @interface CreateHostedVRPPaymentRequest
 */
export interface CreateHostedVRPPaymentRequest {
    /**
     * __Mandatory__. A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof CreateHostedVRPPaymentRequest
     */
    'paymentIdempotencyId': string;
    /**
     * 
     * @type {Amount}
     * @memberof CreateHostedVRPPaymentRequest
     */
    'amount': Amount;
}
/**
 * The type of credentials required to register the `Institution`
 * @export
 * @enum {string}
 */

export const CredentialsType = {
    Oauth1: 'OAUTH1',
    Oauth2: 'OAUTH2',
    Oauth2Nosecret: 'OAUTH2_NOSECRET',
    Oauth2Signature: 'OAUTH2_SIGNATURE',
    OpenBankingUkManual: 'OPEN_BANKING_UK_MANUAL',
    OpenBankingUkAuto: 'OPEN_BANKING_UK_AUTO',
    OpenBankingIbm: 'OPEN_BANKING_IBM',
    OpenBankingAuto: 'OPEN_BANKING_AUTO',
    OpenBankingAutoEmail: 'OPEN_BANKING_AUTO_EMAIL',
    OpenBankingManual: 'OPEN_BANKING_MANUAL',
    OpenBankingWithTppIdAndSecret: 'OPEN_BANKING_WITH_TPP_ID_AND_SECRET',
    ApiKey: 'API_KEY',
    OpenBankingNoKey: 'OPEN_BANKING_NO_KEY',
    OpenBankingNoTransport: 'OPEN_BANKING_NO_TRANSPORT',
    TokenIo: 'TOKEN_IO'
} as const;

export type CredentialsType = typeof CredentialsType[keyof typeof CredentialsType];


/**
 * __Mandatory__. Details whether the account has access to a credit line from an `Institution`.
 * @export
 * @interface CreditLine
 */
export interface CreditLine {
    /**
     * 
     * @type {CreditLineType}
     * @memberof CreditLine
     */
    'type'?: CreditLineType;
    /**
     * 
     * @type {Amount}
     * @memberof CreditLine
     */
    'creditLineAmount'?: Amount;
}


/**
 * __Mandatory__. The type of credit that has been provided.
 * @export
 * @enum {string}
 */

export const CreditLineType = {
    Available: 'AVAILABLE',
    Credit: 'CREDIT',
    Emergency: 'EMERGENCY',
    PreAgreed: 'PRE_AGREED',
    Temporary: 'TEMPORARY',
    Other: 'OTHER',
    Unknown: 'UNKNOWN'
} as const;

export type CreditLineType = typeof CreditLineType[keyof typeof CreditLineType];


/**
 * Provides details on the currrency exchange.
 * @export
 * @interface CurrencyExchange
 */
export interface CurrencyExchange {
    /**
     * Currency from which an amount is to be converted.
     * @type {string}
     * @memberof CurrencyExchange
     */
    'sourceCurrency'?: string;
    /**
     * Currency to which an amount is to be converted.
     * @type {string}
     * @memberof CurrencyExchange
     */
    'targetCurrency'?: string;
    /**
     * The currency in which the rate of exchange is expressed in a currency exchange. In the example 1GBP = xxxCUR, the unit currency is GBP.
     * @type {string}
     * @memberof CurrencyExchange
     */
    'unitCurrency'?: string;
    /**
     * The factor used for conversion of an amount from one currency to another. This reflects the price at which one currency was bought with another currency.
     * @type {number}
     * @memberof CurrencyExchange
     */
    'exchangeRate'?: number;
}
/**
 * 
 * @export
 * @interface DataConstraintsResponse
 */
export interface DataConstraintsResponse {
    /**
     * The id to represent the `Institution`.
     * @type {string}
     * @memberof DataConstraintsResponse
     */
    'institutionId': string;
    /**
     * 2 letter ISO Country code of the `Institution`.
     * @type {string}
     * @memberof DataConstraintsResponse
     */
    'institutionCountryCode'?: string;
    /**
     * Define the applicable API end point.
     * @type {string}
     * @memberof DataConstraintsResponse
     */
    'endpointPath'?: string;
    /**
     * Https Method for the endpoint.
     * @type {string}
     * @memberof DataConstraintsResponse
     */
    'endpointMethod'?: string;
    /**
     * 
     * @type {RequestConstraints}
     * @memberof DataConstraintsResponse
     */
    'request': RequestConstraints;
}
/**
 * Indicates the outcome of the delete request.
 * @export
 * @enum {string}
 */

export const DeleteStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type DeleteStatusEnum = typeof DeleteStatusEnum[keyof typeof DeleteStatusEnum];


/**
 * 
 * @export
 * @interface DirectDebitPayee
 */
export interface DirectDebitPayee {
    /**
     * __Mandatory__. The account holder name.
     * @type {string}
     * @memberof DirectDebitPayee
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DirectDebitResponse
 */
export interface DirectDebitResponse {
    /**
     * 
     * @type {string}
     * @memberof DirectDebitResponse
     */
    'id'?: string;
    /**
     * 
     * @type {PaymentStatusDetails}
     * @memberof DirectDebitResponse
     */
    'statusDetails'?: PaymentStatusDetails;
    /**
     * 
     * @type {DirectDebitPayee}
     * @memberof DirectDebitResponse
     */
    'payeeDetails'?: DirectDebitPayee;
    /**
     * 
     * @type {string}
     * @memberof DirectDebitResponse
     */
    'reference'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof DirectDebitResponse
     */
    'previousPaymentAmount'?: Amount;
    /**
     * 
     * @type {string}
     * @memberof DirectDebitResponse
     */
    'previousPaymentDateTime'?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountAuthorisationRequest
 */
export interface EmbeddedAccountAuthorisationRequest {
    /**
     * `User` for which the authorisation request was created.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/) for more information.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {UserCredentials}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'userCredentials'?: UserCredentials;
    /**
     * 
     * @type {ScaMethod}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'selectedScaMethod'?: ScaMethod;
    /**
     * __Conditional__. Used to update the authorisation with the sca code received by the user from the `Institution` using the embedded account authorisation flow.<br><br>This is the penultimate step required in the embedded account authorisation flow to authorise the `Consent`. After sending the sca code, to obtain an authorised consent, the last step is to poll [Get Consent](https://docs.yapily.com/api/reference/#operation/getConsentById) until the `Institution` authorises the request and the `Consent` `status` transitions to `AUTHORIZED`.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'scaCode'?: string;
    /**
     * 
     * @type {AccountRequest}
     * @memberof EmbeddedAccountAuthorisationRequest
     */
    'accountRequest'?: AccountRequest;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountAuthorisationResponse
 */
export interface EmbeddedAccountAuthorisationResponse {
    /**
     * Unique identifier for the embedded account authorisation request.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'id'?: string;
    /**
     * The `User` that the authorisation request was created for.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'userUuid'?: string;
    /**
     * The user-friendly reference to the `User` that the authorisation request was created for.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'referenceId'?: string;
    /**
     * The `Institution` the authorisation request was sent to.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time the embedded authorisation was created by the application user.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'transactionTo'?: string;
    /**
     * Date and time the embedded authorisation expires. Re-authorisation is needed to retain access.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountAuthorisationResponse
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'timeToExpire'?: string;
    /**
     * The set of features the consent provides access to.
     * @type {Set<FeatureEnum>}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to access account information.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'consentToken'?: string;
    /**
     * Correlation ID used when handshaking with a new institution via OAuth2 registration.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'state'?: string;
    /**
     * Date and time the request was authorised by the `Institution`.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'authorizedAt'?: string;
    /**
     * Identification of the consent at the `Institution`.
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'authorisationUrl'?: string;
    /**
     * The URL link for the QR code that may be scanned via a mobile device to make an authorisation redirect to the bank (authURL encoded).
     * @type {string}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'qrCodeUrl'?: string;
    /**
     * List of `SCA methods` that the `Institution` supports and are available for selection.
     * @type {Array<ScaMethod>}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'scaMethods'?: Array<ScaMethod>;
    /**
     * 
     * @type {ScaMethod}
     * @memberof EmbeddedAccountAuthorisationResponse
     */
    'selectedScaMethod'?: ScaMethod;
}


/**
 * Enriched Balance information generated which include historic aggregated balances and predicted balances
 * @export
 * @interface EnrichedBalances
 */
export interface EnrichedBalances {
    /**
     * A list of Account Ids used to generate Balance Prediction Profile.
     * @type {Array<string>}
     * @memberof EnrichedBalances
     */
    'accountIds'?: Array<string>;
    /**
     * A list of Institution Ids associated with the accounts used to generate Balance Prediction Profile.
     * @type {Array<string>}
     * @memberof EnrichedBalances
     */
    'institutions'?: Array<string>;
    /**
     * A list of historic balances. Each balance in the list is an aggregation (sum) of the reported balance for each account within the profile at a point in time.
     * @type {Array<EnrichedHistoricBalance>}
     * @memberof EnrichedBalances
     */
    'historic'?: Array<EnrichedHistoricBalance>;
    /**
     * A list of predicted balances. Each balance in the list is a projected balance of the profile at a future point in time.
     * @type {Array<EnrichedPredictedBalance>}
     * @memberof EnrichedBalances
     */
    'predicted'?: Array<EnrichedPredictedBalance>;
}
/**
 * A list of Aggregated Account Balances for historic date range.
 * @export
 * @interface EnrichedHistoricBalance
 */
export interface EnrichedHistoricBalance {
    /**
     * The date for which Aggregated Balance amount across Bank accounts is calculated.
     * @type {string}
     * @memberof EnrichedHistoricBalance
     */
    'date'?: string;
    /**
     * The Aggregated Balance amount for a specific date.
     * @type {number}
     * @memberof EnrichedHistoricBalance
     */
    'balance'?: number;
}
/**
 * A list of Predicted Account Balances for future date range.
 * @export
 * @interface EnrichedPredictedBalance
 */
export interface EnrichedPredictedBalance {
    /**
     * The date for which Balance amount is predicted.
     * @type {string}
     * @memberof EnrichedPredictedBalance
     */
    'date'?: string;
    /**
     * The median Balance amount for a future date.
     * @type {number}
     * @memberof EnrichedPredictedBalance
     */
    'medianBalance'?: number;
    /**
     * The 90th percentile Balance amount for a future date.
     * @type {number}
     * @memberof EnrichedPredictedBalance
     */
    '90percentileBalance'?: number;
    /**
     * The 10th percentile Balance amount for a future date.
     * @type {number}
     * @memberof EnrichedPredictedBalance
     */
    '10percentileBalance'?: number;
}
/**
 * Details of the transaction, identified by Yapily data services.
 * @export
 * @interface EnrichedTransaction
 */
export interface EnrichedTransaction {
    /**
     * Unique identifier of the transaction
     * @type {string}
     * @memberof EnrichedTransaction
     */
    'transactionId'?: string;
    /**
     * Information for the transaction
     * @type {string}
     * @memberof EnrichedTransaction
     */
    'transactionInformation'?: string;
    /**
     * Monetary amount.
     * @type {number}
     * @memberof EnrichedTransaction
     */
    'amount'?: number;
    /**
     * The `Institution` that the transaction is sent to.
     * @type {string}
     * @memberof EnrichedTransaction
     */
    'institution'?: string;
    /**
     * Date and time of when a transaction entry occured and was posted to the account servicer\'s books.
     * @type {string}
     * @memberof EnrichedTransaction
     */
    'bookingDateTime'?: string;
}
/**
 * Details of income and expenditure streams, identified by Yapily data services.
 * @export
 * @interface EnrichedWrapper
 */
export interface EnrichedWrapper {
    /**
     * Lists all possible income streams identified for the `Application User`.
     * @type {Array<TransactionStream>}
     * @memberof EnrichedWrapper
     */
    'incomeStreams': Array<TransactionStream>;
    /**
     * Lists all possible expenditure streams identified for the `Application User`.
     * @type {Array<TransactionStream>}
     * @memberof EnrichedWrapper
     */
    'expenditureStreams': Array<TransactionStream>;
    /**
     * A list of terminated transaction income streams
     * @type {Array<TerminatedTransactionStream>}
     * @memberof EnrichedWrapper
     */
    'recentlyTerminatedIncomeStreams': Array<TerminatedTransactionStream>;
    /**
     * A list of terminated transaction expenditure streams
     * @type {Array<TerminatedTransactionStream>}
     * @memberof EnrichedWrapper
     */
    'recentlyTerminatedExpenditureStreams': Array<TerminatedTransactionStream>;
}
/**
 * Enriched data that has been derived by Yapily using it\'s data processing and machine learning techniques.
 * @export
 * @interface Enrichment
 */
export interface Enrichment {
    /**
     * 
     * @type {Categorisation}
     * @memberof Enrichment
     */
    'categorisation'?: Categorisation;
    /**
     * 
     * @type {TransactionHash}
     * @memberof Enrichment
     */
    'transactionHash'?: TransactionHash;
    /**
     * Cleaned version of the `Transaction Description` that removes miscellaneous, generic and unhelpful text.
     * @type {string}
     * @memberof Enrichment
     */
    'cleansedDescription'?: string;
    /**
     * 
     * @type {EnrichmentMerchant}
     * @memberof Enrichment
     */
    'merchant'?: EnrichmentMerchant;
    /**
     * The location of where the transaction took place.
     * @type {string}
     * @memberof Enrichment
     */
    'location'?: string;
    /**
     * A payment provider that manages (credit/debit) transactions between the `Institution` and the merchant.
     * @type {string}
     * @memberof Enrichment
     */
    'paymentProcessor'?: string;
    /**
     * The likely date and time on which the transaction took place. This is distinct from `Booking Date Time` which usually refers to the post-clearing value.
     * @type {string}
     * @memberof Enrichment
     */
    'correctedDate'?: string;
}
/**
 * Details of the merchant, identified by Yapily data services.
 * @export
 * @interface EnrichmentMerchant
 */
export interface EnrichmentMerchant {
    /**
     * The name of the indivdual merchant involved in the transaction e.g. (TESCO Petrol).
     * @type {string}
     * @memberof EnrichmentMerchant
     */
    'merchantName'?: string;
    /**
     * The parent organisation that the merchant belongs to e.g. (TESCO).
     * @type {string}
     * @memberof EnrichmentMerchant
     */
    'parentGroup'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EnumError = {
    Mandatory: 'MANDATORY',
    InvalidFormat: 'INVALID_FORMAT'
} as const;

export type EnumError = typeof EnumError[keyof typeof EnumError];


/**
 * The environment type. <br><br>See [Institution Configuration](https://docs.yapily.com/pages/key-concepts/institutions/#configuration) for more information
 * @export
 * @enum {string}
 */

export const EnvironmentType = {
    Sandbox: 'SANDBOX',
    Mock: 'MOCK',
    Live: 'LIVE'
} as const;

export type EnvironmentType = typeof EnvironmentType[keyof typeof EnvironmentType];


/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * Unique identifier of the request, used by Yapily for support purposes
     * @type {string}
     * @memberof ErrorDetails
     */
    'tracingId': string;
    /**
     * Numeric HTTP status code associated with the error
     * @type {number}
     * @memberof ErrorDetails
     */
    'code': number;
    /**
     * Textual description of the HTTP status
     * @type {string}
     * @memberof ErrorDetails
     */
    'status': string;
    /**
     * Link to where further information regarding the error can be found
     * @type {string}
     * @memberof ErrorDetails
     */
    'supportUrl'?: string;
    /**
     * Source of the error. This may be YAPILY, the INSTITUTION, or the USER
     * @type {string}
     * @memberof ErrorDetails
     */
    'source'?: string;
    /**
     * List of issues relating to the error
     * @type {Array<ErrorIssue>}
     * @memberof ErrorDetails
     */
    'issues'?: Array<ErrorIssue>;
}
/**
 * Detailed information regarding the issue that was experienced during processing of the request
 * @export
 * @interface ErrorIssue
 */
export interface ErrorIssue {
    /**
     * Category of the issue
     * @type {string}
     * @memberof ErrorIssue
     */
    'type': string;
    /**
     * Code that uniquely identifies the type of issue
     * @type {string}
     * @memberof ErrorIssue
     */
    'code': string;
    /**
     * Identfies the parameter / property within the request (headers, query parameters or body) that the issue relates to. For headers and query parameters, it refers to the parameter name. For the body, it refers to the JSONPath of the property
     * @type {string}
     * @memberof ErrorIssue
     */
    'parameter'?: string;
    /**
     * Human readable description of the issue that was experienced
     * @type {string}
     * @memberof ErrorIssue
     */
    'message'?: string;
    /**
     * 
     * @type {InstitutionError}
     * @memberof ErrorIssue
     */
    'institutionError'?: InstitutionError;
}
/**
 * 
 * @export
 * @interface EventSubscriptionDeleteResponse
 */
export interface EventSubscriptionDeleteResponse {
    /**
     * Unique identifier of the event type (for which notifications will be sent)
     * @type {string}
     * @memberof EventSubscriptionDeleteResponse
     */
    'eventTypeId': string;
    /**
     * Application related to event subscription.
     * @type {string}
     * @memberof EventSubscriptionDeleteResponse
     */
    'applicationId': string;
    /**
     * Creation datetime of event subscription.
     * @type {string}
     * @memberof EventSubscriptionDeleteResponse
     */
    'created': string;
    /**
     * 
     * @type {DeleteStatusEnum}
     * @memberof EventSubscriptionDeleteResponse
     */
    'deleteStatus': DeleteStatusEnum;
}


/**
 * 
 * @export
 * @interface EventSubscriptionRequest
 */
export interface EventSubscriptionRequest {
    /**
     * Unique identifier of the event type (for which notifications will be sent).<br><br>Allowed values: payment.status, payment.status.completed, payment.isoStatus, virtualAccount.payIn.status, virtualAccount.payOut.status, virtualAccount.createBeneficiary.status, virtualAccount.account.status, virtualAccount.client.status, virtualAccount.refund.status, virtualAccount.payOut.return  
     * @type {string}
     * @memberof EventSubscriptionRequest
     */
    'eventTypeId': string;
    /**
     * 
     * @type {Notification}
     * @memberof EventSubscriptionRequest
     */
    'notification': Notification;
}
/**
 * 
 * @export
 * @interface EventSubscriptionResponse
 */
export interface EventSubscriptionResponse {
    /**
     * Unique identifier of the event type (for which notifications will be sent)
     * @type {string}
     * @memberof EventSubscriptionResponse
     */
    'eventTypeId': string;
    /**
     * Application related to event subscription.
     * @type {string}
     * @memberof EventSubscriptionResponse
     */
    'applicationId': string;
    /**
     * Creation date of event subscription.
     * @type {string}
     * @memberof EventSubscriptionResponse
     */
    'created': string;
    /**
     * 
     * @type {Notification}
     * @memberof EventSubscriptionResponse
     */
    'notification': Notification;
}
/**
 * __Optional__. Used to provide details on the currency exchange rate and contract.
 * @export
 * @interface ExchangeRateInformation
 */
export interface ExchangeRateInformation {
    /**
     * __Mandatory__. The currency in which the rate of exchange is expressed in a currency exchange. In the example 1GBP = xxxCUR, the unit currency is `GBP`.
     * @type {string}
     * @memberof ExchangeRateInformation
     */
    'unitCurrency': string;
    /**
     * __Optional__. The factor used for conversion of an amount from one currency to another. This reflects the price at which one currency was bought with another currency.
     * @type {number}
     * @memberof ExchangeRateInformation
     */
    'rate'?: number;
    /**
     * 
     * @type {RateTypeEnum}
     * @memberof ExchangeRateInformation
     */
    'rateType': RateTypeEnum;
    /**
     * __Optional__. The unique and unambiguous reference to the foreign exchange contract agreed between the initiating party/creditor and the debtor agent.
     * @type {string}
     * @memberof ExchangeRateInformation
     */
    'foreignExchangeContractReference'?: string;
}


/**
 * 
 * @export
 * @interface ExchangeRateInformationResponse
 */
export interface ExchangeRateInformationResponse {
    /**
     * __Mandatory__. The currency in which the rate of exchange is expressed in a currency exchange. In the example 1GBP = xxxCUR, the unit currency is `GBP`.
     * @type {string}
     * @memberof ExchangeRateInformationResponse
     */
    'unitCurrency': string;
    /**
     * __Optional__. The factor used for conversion of an amount from one currency to another. This reflects the price at which one currency was bought with another currency.
     * @type {number}
     * @memberof ExchangeRateInformationResponse
     */
    'rate'?: number;
    /**
     * 
     * @type {RateTypeEnum}
     * @memberof ExchangeRateInformationResponse
     */
    'rateType': RateTypeEnum;
    /**
     * __Optional__. The unique and unambiguous reference to the foreign exchange contract agreed between the initiating party/creditor and the debtor agent.
     * @type {string}
     * @memberof ExchangeRateInformationResponse
     */
    'foreignExchangeContractReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeRateInformationResponse
     */
    'exchangeRateExpiryDate'?: string;
}


/**
 * 
 * @export
 * @interface ExtendConsentRequest
 */
export interface ExtendConsentRequest {
    /**
     * __Mandatory__. The time that the user confirmed access to their account information
     * @type {string}
     * @memberof ExtendConsentRequest
     */
    'lastConfirmedAt': string;
}
/**
 * Features that an individual `Institution` may support. 
 * @export
 * @interface FeatureDetails
 */
export interface FeatureDetails {
    /**
     * 
     * @type {FeatureEnum}
     * @memberof FeatureDetails
     */
    'feature'?: FeatureEnum;
    /**
     * Endpoints that are associated with the feature e.g. (available for use if an Institution supports a feature).
     * @type {string}
     * @memberof FeatureDetails
     */
    'endpoint'?: string;
    /**
     * The link to further documentation regarding the feature.
     * @type {string}
     * @memberof FeatureDetails
     */
    'documentationUrl'?: string;
}


/**
 * Used to describe what functions are supported by the associated `Institution`.        <br><br>For more information on each feature, see the following links:        <ul>          <li>[Financial Data Features](https://docs.yapily.com/pages/key-concepts/account-data/account-features/)</li>          <li>[Payments Features](https://docs.yapily.com/pages/key-concepts/payments/payment-features/)</li>        </ul>
 * @export
 * @enum {string}
 */

export const FeatureEnum = {
    InitiatePreAuthorisation: 'INITIATE_PRE_AUTHORISATION',
    InitiatePreAuthorisationAccounts: 'INITIATE_PRE_AUTHORISATION_ACCOUNTS',
    InitiatePreAuthorisationPayments: 'INITIATE_PRE_AUTHORISATION_PAYMENTS',
    InitiateAccountRequest: 'INITIATE_ACCOUNT_REQUEST',
    InitiateEmbeddedAccountRequest: 'INITIATE_EMBEDDED_ACCOUNT_REQUEST',
    AccountRequestDetails: 'ACCOUNT_REQUEST_DETAILS',
    Accounts: 'ACCOUNTS',
    Account: 'ACCOUNT',
    AccountTransactions: 'ACCOUNT_TRANSACTIONS',
    AccountStatements: 'ACCOUNT_STATEMENTS',
    AccountStatement: 'ACCOUNT_STATEMENT',
    AccountStatementFile: 'ACCOUNT_STATEMENT_FILE',
    AccountScheduledPayments: 'ACCOUNT_SCHEDULED_PAYMENTS',
    AccountDirectDebits: 'ACCOUNT_DIRECT_DEBITS',
    AccountPeriodicPayments: 'ACCOUNT_PERIODIC_PAYMENTS',
    AccountTransactionsWithMerchant: 'ACCOUNT_TRANSACTIONS_WITH_MERCHANT',
    Identity: 'IDENTITY',
    AccountsWithoutBalance: 'ACCOUNTS_WITHOUT_BALANCE',
    AccountWithoutBalance: 'ACCOUNT_WITHOUT_BALANCE',
    AccountBalances: 'ACCOUNT_BALANCES',
    InitiateSinglePaymentSortcode: 'INITIATE_SINGLE_PAYMENT_SORTCODE',
    ExistingPaymentInitiationDetails: 'EXISTING_PAYMENT_INITIATION_DETAILS',
    CreateSinglePaymentSortcode: 'CREATE_SINGLE_PAYMENT_SORTCODE',
    ExistingPaymentsDetails: 'EXISTING_PAYMENTS_DETAILS',
    InitiateDomesticSinglePayment: 'INITIATE_DOMESTIC_SINGLE_PAYMENT',
    InitiateEmbeddedDomesticSinglePayment: 'INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT',
    CreateDomesticSinglePayment: 'CREATE_DOMESTIC_SINGLE_PAYMENT',
    InitiateEmbeddedBulkPayment: 'INITIATE_EMBEDDED_BULK_PAYMENT',
    InitiateDomesticSingleInstantPayment: 'INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT',
    CreateDomesticSingleInstantPayment: 'CREATE_DOMESTIC_SINGLE_INSTANT_PAYMENT',
    InitiateDomesticVariableRecurringPayment: 'INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    CreateDomesticVariableRecurringPayment: 'CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    InitiateDomesticVariableRecurringPaymentSweeping: 'INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING',
    InitiateDomesticVariableRecurringPaymentNonsweeping: 'INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING',
    CreateDomesticVariableRecurringPaymentSweeping: 'CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING',
    CreateDomesticVariableRecurringPaymentNonsweeping: 'CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING',
    InitiateDomesticScheduledPayment: 'INITIATE_DOMESTIC_SCHEDULED_PAYMENT',
    CreateDomesticScheduledPayment: 'CREATE_DOMESTIC_SCHEDULED_PAYMENT',
    InitiateDomesticPeriodicPayment: 'INITIATE_DOMESTIC_PERIODIC_PAYMENT',
    CreateDomesticPeriodicPayment: 'CREATE_DOMESTIC_PERIODIC_PAYMENT',
    PeriodicPaymentFrequencyExtended: 'PERIODIC_PAYMENT_FREQUENCY_EXTENDED',
    InitiateInternationalScheduledPayment: 'INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT',
    CreateInternationalScheduledPayment: 'CREATE_INTERNATIONAL_SCHEDULED_PAYMENT',
    InitiateInternationalPeriodicPayment: 'INITIATE_INTERNATIONAL_PERIODIC_PAYMENT',
    CreateInternationalPeriodicPayment: 'CREATE_INTERNATIONAL_PERIODIC_PAYMENT',
    InitiateInternationalSinglePayment: 'INITIATE_INTERNATIONAL_SINGLE_PAYMENT',
    CreateInternationalSinglePayment: 'CREATE_INTERNATIONAL_SINGLE_PAYMENT',
    InitiateBulkPayment: 'INITIATE_BULK_PAYMENT',
    CreateBulkPayment: 'CREATE_BULK_PAYMENT',
    Transfer: 'TRANSFER',
    OpenDataPersonalCurrentAccounts: 'OPEN_DATA_PERSONAL_CURRENT_ACCOUNTS',
    OpenDataAtms: 'OPEN_DATA_ATMS',
    ReadDomesticSingleRefund: 'READ_DOMESTIC_SINGLE_REFUND',
    ReadDomesticScheduledRefund: 'READ_DOMESTIC_SCHEDULED_REFUND',
    ReadDomesticPeriodicPaymentRefund: 'READ_DOMESTIC_PERIODIC_PAYMENT_REFUND',
    ReadInternationalSingleRefund: 'READ_INTERNATIONAL_SINGLE_REFUND',
    ReadInternationalScheduledRefund: 'READ_INTERNATIONAL_SCHEDULED_REFUND',
    AccountBeneficiaries: 'ACCOUNT_BENEFICIARIES',
    InitiateOnetimePreAuthorisationPayments: 'INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS',
    InitiateOnetimePreAuthorisationAccounts: 'INITIATE_ONETIME_PRE_AUTHORISATION_ACCOUNTS',
    InitiateOnetimePreAuthorisation: 'INITIATE_ONETIME_PRE_AUTHORISATION',
    VariableRecurringPaymentFundsConfirmation: 'VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION'
} as const;

export type FeatureEnum = typeof FeatureEnum[keyof typeof FeatureEnum];


/**
 * 
 * @export
 * @interface FilterAndSort
 */
export interface FilterAndSort {
    /**
     * __Optional__. The earliest date and time of resources / records that should be returned.
     * @type {string}
     * @memberof FilterAndSort
     */
    'from'?: string;
    /**
     * __Optional__. The latest date and time of resources / records that should be returned.
     * @type {string}
     * @memberof FilterAndSort
     */
    'before'?: string;
    /**
     * __Optional__. The maximum number of resources / records that should be returned.
     * @type {number}
     * @memberof FilterAndSort
     */
    'limit'?: number;
    /**
     * 
     * @type {SortEnum}
     * @memberof FilterAndSort
     */
    'sort'?: SortEnum;
    /**
     * 
     * @type {number}
     * @memberof FilterAndSort
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterAndSort
     */
    'cursor'?: string;
}


/**
 * 
 * @export
 * @interface FilteredClientPayloadListAccount
 */
export interface FilteredClientPayloadListAccount {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListAccount
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<Account>}
     * @memberof FilteredClientPayloadListAccount
     */
    'data'?: Array<Account>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListAccount
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListAccount
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListAccount
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListAccount
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListAccountStatement
 */
export interface FilteredClientPayloadListAccountStatement {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<AccountStatement>}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'data'?: Array<AccountStatement>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListAccountStatement
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListCategory
 */
export interface FilteredClientPayloadListCategory {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListCategory
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<Category>}
     * @memberof FilteredClientPayloadListCategory
     */
    'data'?: Array<Category>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListCategory
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListCategory
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListCategory
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListCategory
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListConsent
 */
export interface FilteredClientPayloadListConsent {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListConsent
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<Consent>}
     * @memberof FilteredClientPayloadListConsent
     */
    'data'?: Array<Consent>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListConsent
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListConsent
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListConsent
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListConsent
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListDirectDebitResponse
 */
export interface FilteredClientPayloadListDirectDebitResponse {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<DirectDebitResponse>}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'data'?: Array<DirectDebitResponse>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListDirectDebitResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListFeatureDetails
 */
export interface FilteredClientPayloadListFeatureDetails {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<FeatureDetails>}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'data'?: Array<FeatureDetails>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListFeatureDetails
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListInstitution
 */
export interface FilteredClientPayloadListInstitution {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListInstitution
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<Institution>}
     * @memberof FilteredClientPayloadListInstitution
     */
    'data'?: Array<Institution>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListInstitution
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListInstitution
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListInstitution
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListInstitution
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListPaymentResponse
 */
export interface FilteredClientPayloadListPaymentResponse {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<PaymentResponse>}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'data'?: Array<PaymentResponse>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListPaymentResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface FilteredClientPayloadListTransaction
 */
export interface FilteredClientPayloadListTransaction {
    /**
     * 
     * @type {object}
     * @memberof FilteredClientPayloadListTransaction
     */
    'apiCall'?: object;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof FilteredClientPayloadListTransaction
     */
    'data'?: Array<Transaction>;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListTransaction
     */
    'nextCursorHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilteredClientPayloadListTransaction
     */
    'nextLink'?: string;
    /**
     * 
     * @type {{ [key: string]: FilterAndSort; }}
     * @memberof FilteredClientPayloadListTransaction
     */
    'pagingMap'?: { [key: string]: FilterAndSort; };
    /**
     * 
     * @type {number}
     * @memberof FilteredClientPayloadListTransaction
     */
    'totalCount'?: number;
}
/**
 * A financial profile for a User.
 * @export
 * @interface FinancialProfile
 */
export interface FinancialProfile {
    /**
     * The status, can be EMPTY, PARTIAL, PENDING, COMPLETED or ERROR.
     * @type {string}
     * @memberof FinancialProfile
     */
    'status'?: string;
    /**
     * A list of ProfileConsent used in the financial profile.
     * @type {Array<ProfileConsent>}
     * @memberof FinancialProfile
     */
    'profileConsents'?: Array<ProfileConsent>;
    /**
     * 
     * @type {EnrichedWrapper}
     * @memberof FinancialProfile
     */
    'enrichment'?: EnrichedWrapper;
}
/**
 * __Mandatory__. Frequency for which the payment limits are enforced. Allowed values are [MONTHLY].
 * @export
 * @enum {string}
 */

export const FrequencyEnum = {
    Monthly: 'MONTHLY'
} as const;

export type FrequencyEnum = typeof FrequencyEnum[keyof typeof FrequencyEnum];


/**
 * __Mandatory__. See [payment frequency](/guides/payments/payment-execution/periodic-payments/#payment-frequency) for more information
 * @export
 * @enum {string}
 */

export const FrequencyEnumExtended = {
    Daily: 'DAILY',
    EveryWorkingDay: 'EVERY_WORKING_DAY',
    CalendarDay: 'CALENDAR_DAY',
    Weekly: 'WEEKLY',
    EveryTwoWeeks: 'EVERY_TWO_WEEKS',
    Monthly: 'MONTHLY',
    EveryTwoMonths: 'EVERY_TWO_MONTHS',
    Quarterly: 'QUARTERLY',
    Semiannual: 'SEMIANNUAL',
    Annual: 'ANNUAL'
} as const;

export type FrequencyEnumExtended = typeof FrequencyEnumExtended[keyof typeof FrequencyEnumExtended];


/**
 * __Mandatory__. Defines the intervals at which payment should be made.
 * @export
 * @interface FrequencyRequest
 */
export interface FrequencyRequest {
    /**
     * 
     * @type {FrequencyEnumExtended}
     * @memberof FrequencyRequest
     */
    'type': FrequencyEnumExtended;
    /**
     * __Conditional__. See [payment frequency](/guides/payments/payment-execution/periodic-payments/#payment-frequency) for more information
     * @type {number}
     * @memberof FrequencyRequest
     */
    'intervalWeek'?: number;
    /**
     * __Conditional__. See [payment frequency](/guides/payments/payment-execution/periodic-payments/#payment-frequency) for more information
     * @type {number}
     * @memberof FrequencyRequest
     */
    'intervalMonth'?: number;
    /**
     * __Conditional__. See [payment frequency](/guides/payments/payment-execution/periodic-payments/#payment-frequency) for more information
     * @type {number}
     * @memberof FrequencyRequest
     */
    'executionDay'?: number;
}


/**
 * __Mandatory__. Defines the intervals at which payment should be made.
 * @export
 * @interface FrequencyResponse
 */
export interface FrequencyResponse {
    /**
     * 
     * @type {FrequencyEnumExtended}
     * @memberof FrequencyResponse
     */
    'frequencyType'?: FrequencyEnumExtended;
    /**
     * The weekly intervals at which a payment will be made. e.g. 1 = Every months, 2 = Every 2 months.
     * @type {number}
     * @memberof FrequencyResponse
     */
    'intervalWeek'?: number;
    /**
     * The monthly intervals at which a payment will be made. e.g. 1 = Every month, 2 = Every 2 months
     * @type {number}
     * @memberof FrequencyResponse
     */
    'intervalMonth'?: number;
    /**
     * The day on which a payment will be made, according to the weekly or monthly interval.
     * @type {number}
     * @memberof FrequencyResponse
     */
    'executionDay'?: number;
}


/**
 * 
 * @export
 * @interface FundsAvailable
 */
export interface FundsAvailable {
    /**
     * __Mandatory__. Indicates whether funds are available or not.
     * @type {boolean}
     * @memberof FundsAvailable
     */
    'fundsAvailable': boolean;
    /**
     * __Mandatory__. Date and Time when the funds availability is checked.
     * @type {string}
     * @memberof FundsAvailable
     */
    'fundsAvailableAt': string;
}
/**
 * The fund confirmation object defining the details of the account and funds to be checked under the Variable Recurring Payment consent.
 * @export
 * @interface FundsConfirmationRequest
 */
export interface FundsConfirmationRequest {
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof FundsConfirmationRequest
     */
    'reference'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof FundsConfirmationRequest
     */
    'paymentAmount': Amount;
}
/**
 * 
 * @export
 * @interface FundsConfirmationResponse
 */
export interface FundsConfirmationResponse {
    /**
     * 
     * @type {string}
     * @memberof FundsConfirmationResponse
     */
    'id'?: string;
    /**
     * The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof FundsConfirmationResponse
     */
    'reference'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof FundsConfirmationResponse
     */
    'paymentAmount': Amount;
    /**
     * 
     * @type {FundsAvailable}
     * @memberof FundsConfirmationResponse
     */
    'fundsAvailable': FundsAvailable;
}
/**
 * 
 * @export
 * @interface GetHostedVRPConsentsResponseInner
 */
export interface GetHostedVRPConsentsResponseInner {
    /**
     * Represents the Unique Id of the VRP consent request
     * @type {string}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'id': string;
    /**
     * Represents the Unique Id of the `Application` the user is associated with.
     * @type {string}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'applicationId': string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'institutionIdentifiers'?: InstitutionIdentifiers;
    /**
     * 
     * @type {VRPSetupRequest}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'vrpSetup'?: VRPSetupRequest;
    /**
     * Represents the date and time at which the Consent was updated.
     * @type {string}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'updatedAt'?: string;
    /**
     * Current status of the authorisation. Can be one of [AWAITING_AUTHORIZATION, AUTHORIZED, REJECTED, REVOKED, FAILED, EXPIRED]
     * @type {string}
     * @memberof GetHostedVRPConsentsResponseInner
     */
    'consentStatus'?: string;
}
/**
 * The payment amount and currency
 * @export
 * @interface HostedAmountDetails
 */
export interface HostedAmountDetails {
    /**
     * The payment amount
     * @type {number}
     * @memberof HostedAmountDetails
     */
    'amountToPay': number;
    /**
     * The [ISO 4217](https://www.xe.com/iso4217.php) currency code
     * @type {string}
     * @memberof HostedAmountDetails
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface HostedNonSweepingPeriodicLimits
 */
export interface HostedNonSweepingPeriodicLimits {
    /**
     * __Mandatory__. Maximum amount that can be specified in all payment instructions in a given period under this VRP consent. If the Alignment is Calendar, the limit is pro-rated in the first period to the remaining number of days.
     * @type {Amount}
     * @memberof HostedNonSweepingPeriodicLimits
     */
    'maxAmount': Amount;
    /**
     * __Mandatory__. Frequency for which the payment limits are enforced. Allowed values are [MONTHLY].
     * @type {string}
     * @memberof HostedNonSweepingPeriodicLimits
     */
    'frequency': string;
    /**
     * __Mandatory__. Period alignment for which the payment limits are enforced. Allowed values are [CONSENT, CALENDAR]. If CONSENT, then period starts on consent creation date. If CALENDAR, then period lines up with the frequency e.g. WEEKLY period will begin at start of the week in question.
     * @type {string}
     * @memberof HostedNonSweepingPeriodicLimits
     */
    'alignment': string;
}
/**
 * 
 * @export
 * @interface HostedPayment
 */
export interface HostedPayment {
    /**
     * The Unique Identifier of the payment.
     * @type {string}
     * @memberof HostedPayment
     */
    'paymentId'?: string;
    /**
     * The Unique Identifier of the payment created using Yapily hosted application.
     * @type {string}
     * @memberof HostedPayment
     */
    'hostedPaymentId'?: string;
    /**
     * The Unique Identifier of the consent.
     * @type {string}
     * @memberof HostedPayment
     */
    'consentId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiersResponse}
     * @memberof HostedPayment
     */
    'institutionIdentifiers'?: InstitutionIdentifiersResponse;
    /**
     * The phase reached by the payment and its timestamp.
     * @type {Array<HostedPaymentPhase>}
     * @memberof HostedPayment
     */
    'phases'?: Array<HostedPaymentPhase>;
    /**
     * Details of the payment status.
     * @type {Array<HostedPaymentStatusDetails>}
     * @memberof HostedPayment
     */
    'statusDetails'?: Array<HostedPaymentStatusDetails>;
    /**
     * The Unique Identifier of the payment created with the `Institution`.
     * @type {string}
     * @memberof HostedPayment
     */
    'institutionPaymentId'?: string;
    /**
     * The Unique Identifier provided by TPP in the Payment request to identify the payment.
     * @type {string}
     * @memberof HostedPayment
     */
    'paymentLifecycleId'?: string;
    /**
     * A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof HostedPayment
     */
    'paymentIdempotencyId'?: string;
    /**
     * The payment reference or description. Limited to a maximum of 18 characters for UK institutions.
     * @type {string}
     * @memberof HostedPayment
     */
    'reference'?: string;
    /**
     * 
     * @type {PaymentContextTypeResponse}
     * @memberof HostedPayment
     */
    'contextType'?: PaymentContextTypeResponse;
    /**
     * 
     * @type {PaymentTypeResponse}
     * @memberof HostedPayment
     */
    'type'?: PaymentTypeResponse;
    /**
     * 
     * @type {PayeeDetailsResponse}
     * @memberof HostedPayment
     */
    'payee'?: PayeeDetailsResponse;
    /**
     * 
     * @type {PayerDetailsResponse}
     * @memberof HostedPayment
     */
    'payer'?: PayerDetailsResponse;
    /**
     * 
     * @type {AmountDetailsResponse}
     * @memberof HostedPayment
     */
    'amount'?: AmountDetailsResponse;
}


/**
 * 
 * @export
 * @interface HostedPaymentDetails
 */
export interface HostedPaymentDetails {
    /**
     * The unique ID of the payment request.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'paymentRequestId'?: string;
    /**
     * The Unique Identifier for the `User` assigned by Yapily.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'userId'?: string;
    /**
     * Your reference to the `User`.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'applicationUserId'?: string;
    /**
     * The Unique Identifier of the `Application` the user is associated with.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'applicationId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiersResponse}
     * @memberof HostedPaymentDetails
     */
    'institutionIdentifiers'?: InstitutionIdentifiersResponse;
    /**
     * 
     * @type {UserSettings}
     * @memberof HostedPaymentDetails
     */
    'userSettings'?: UserSettings;
    /**
     * URL of your server to redirect the user after completion of the payment flow.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {HostedPaymentRequestDetailsLink}
     * @memberof HostedPaymentDetails
     */
    'paymentRequestDetails'?: HostedPaymentRequestDetailsLink;
    /**
     * The date and time at which the payment request was created.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'createdAt'?: string;
    /**
     * The date and time at which the auth Token will expire.
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'authorisationExpiresAt'?: string;
    /**
     * Current status of the payment request. <br> Possible values: <br> ACTIVE <br> INACTIVE
     * @type {string}
     * @memberof HostedPaymentDetails
     */
    'status'?: string;
    /**
     * Payments that have been initiated as part of this request
     * @type {Set<HostedPayment>}
     * @memberof HostedPaymentDetails
     */
    'payments'?: Set<HostedPayment>;
}
/**
 * The ISO status of the payment.
 * @export
 * @interface HostedPaymentIsoStatus
 */
export interface HostedPaymentIsoStatus {
    /**
     * The ISO 20022 `PaymentStatusCode`. One of : <br> ACSC <br> ACCC <br> ACCP  <br> ACSP <br> ACTC <br> ACWC <br> ACWP <br> ACFC <br> RCVD <br> PART <br> PATC <br> PDNG <br> RJCT <br> CANC
     * @type {string}
     * @memberof HostedPaymentIsoStatus
     */
    'code'?: string;
    /**
     * The full name of the ISO 20022 `PaymentStatusCode`.
     * @type {string}
     * @memberof HostedPaymentIsoStatus
     */
    'name'?: string;
}
/**
 * The phase of the payment.
 * @export
 * @interface HostedPaymentPhase
 */
export interface HostedPaymentPhase {
    /**
     * The name of the hosted payment process phase. Allowed values are : <ul> <li> INITIATED  -  Payment process initiated </li><li> DECLINED  -  Payment process failed and will not proceed further </li><li> INSTITUTION_SUBMITTED  -  Payment institution submitted </li><li> EMBEDDED_CREDENTIAL_REQUESTED  -  For embedded banks, a UI element to collect user credentials was displayed </li><li> AUTHORISATION_INITIATED  -  All details required for payment initiation have been collected </li><li> VALIDATION_COMPLETED  -  The payment payload was validated successfully </li><li> AUTHORISATION_CREATED  -  Payment authorisation request created with Institution </li><li> EMBEDDED_CODE_REQUESTED  -  For embedded banks, a UI element to collect SCA for initiated consent was displayed </li><li> EMBEDDED_TYPE_REQUESTED  -  For embedded banks, a UI element to allow the user to select their preferred SCA method for this consent authorisation was displayed  </li><li> EMBEDDED_DECOUPLED_AUTHORISATION  -  For embedded banks, decoupled authoirisation was initiated by the bank </li><li> EMBEDDED_CODE_COLLECTED  -  For embedded banks, SCA code was collected for consent authorisation </li><li> EMBEDDED_TYPE_SELECTED  -  For embedded banks, preferred SCA method was selected for consent authorisation </li><li> CONSENT_POLLING_STARTED  -  We start polling the bank for consent authorisation status </li><li> CONSENT_POLLING_ENDED  -  We finish polling the bank for consent authorisation status </li><li> AUTHORISED  -  Payment authorisation completed </li><li> AUTHORISATION_FAILED  -  Payment authorisation failed and will not proceed further </li><li> AUTHORISATION_REJECTED  -  Payment authorisation rejected and will not proceed further </li><li> SUBMITTED  -  Payment execution created and submitted to Institution </li><li> ACCEPTED  -  Payment execution accepted by Institution and awaiting settlement </li><li> REJECTED  -  Payment or Authorisation request rejected by Institution and will not proceed further </li><li> SETTLEMENT_COMPLETED  -  Payment settlement completed </li><li> STATUS_POLLING_STARTED  -  Payment status polling started </li><li> STATUS_POLLING_ENDED  -  Payment status polling ended </li><li> MERCHANT_ACKNOWLEDGED  -  Payment acknowledgement received from merchant </li><li> FINISHED  -  Payment process completed </li> </ul>
     * @type {string}
     * @memberof HostedPaymentPhase
     */
    'phaseName'?: string;
    /**
     * The date and time when phase of the hosted payment was inserted.
     * @type {string}
     * @memberof HostedPaymentPhase
     */
    'phaseCreatedAt'?: string;
}
/**
 * Details of the payment.
 * @export
 * @interface HostedPaymentRequestDetails
 */
export interface HostedPaymentRequestDetails {
    /**
     * A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof HostedPaymentRequestDetails
     */
    'paymentIdempotencyId': string;
    /**
     * The payment reference or description. Limited to a maximum of 18 characters for UK institutions.
     * @type {string}
     * @memberof HostedPaymentRequestDetails
     */
    'reference'?: string;
    /**
     * 
     * @type {PaymentContextType}
     * @memberof HostedPaymentRequestDetails
     */
    'contextType'?: PaymentContextType;
    /**
     * 
     * @type {PaymentType}
     * @memberof HostedPaymentRequestDetails
     */
    'type': PaymentType;
    /**
     * 
     * @type {Payee}
     * @memberof HostedPaymentRequestDetails
     */
    'payee': Payee;
    /**
     * 
     * @type {Payer}
     * @memberof HostedPaymentRequestDetails
     */
    'payer'?: Payer;
    /**
     * 
     * @type {HostedAmountDetails}
     * @memberof HostedPaymentRequestDetails
     */
    'amountDetails': HostedAmountDetails;
    /**
     * The date that the payment is due. Displayed to the end user in the payment summary screen.
     * @type {string}
     * @memberof HostedPaymentRequestDetails
     */
    'paymentDueDate'?: string;
}


/**
 * 
 * @export
 * @interface HostedPaymentRequestDetailsLink
 */
export interface HostedPaymentRequestDetailsLink {
    /**
     * The payment reference or description. Limited to a maximum of 18 characters for UK institutions.
     * @type {string}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'reference'?: string;
    /**
     * 
     * @type {PaymentContextTypeResponse}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'contextType'?: PaymentContextTypeResponse;
    /**
     * 
     * @type {PaymentTypeResponse}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'type'?: PaymentTypeResponse;
    /**
     * 
     * @type {PayeeDetailsResponse}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'payee'?: PayeeDetailsResponse;
    /**
     * 
     * @type {PayerDetailsResponse}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'payer'?: PayerDetailsResponse;
    /**
     * 
     * @type {AmountDetailsResponse}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'amountDetails'?: AmountDetailsResponse;
    /**
     * The date that the payment is due. Displayed to the end user in the payment summary screen.
     * @type {string}
     * @memberof HostedPaymentRequestDetailsLink
     */
    'paymentDueDate'?: string;
}


/**
 * 
 * @export
 * @interface HostedPaymentRequestResponse
 */
export interface HostedPaymentRequestResponse {
    /**
     * Unique Id of the payment request.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'paymentRequestId'?: string;
    /**
     * Unique Id for the `User` assigned by Yapily.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'userId'?: string;
    /**
     * Your reference to the `User`.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'applicationUserId'?: string;
    /**
     * Unique Id of the `Application` the user is associated with.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'applicationId'?: string;
    /**
     * 
     * @type {InstitutionIdentifiersResponse}
     * @memberof HostedPaymentRequestResponse
     */
    'institutionIdentifiers'?: InstitutionIdentifiersResponse;
    /**
     * 
     * @type {UserSettings}
     * @memberof HostedPaymentRequestResponse
     */
    'userSettings'?: UserSettings;
    /**
     * URL of payment server to redirect the user after completion of the payment flow.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {HostedPaymentResponseDetails}
     * @memberof HostedPaymentRequestResponse
     */
    'paymentRequestDetails'?: HostedPaymentResponseDetails;
    /**
     * The URL of Hosted UI page for the applicationId which initiates the user journey for the payment. <br> URL would be appended with authToken, applicationId and userSettings.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'hostedUrl'?: string;
    /**
     * The JWT Token signed by the certificate-vault using Yapily\'s keys.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'authToken'?: string;
    /**
     * The date and time at which the payment was created.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'createdAt'?: string;
    /**
     * The date and time at which the auth Token will expire.
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'authorisationExpiresAt'?: string;
    /**
     * Current status of the payment request. <br> Possible Values: <br> ACTIVE <br> INACTIVE
     * @type {string}
     * @memberof HostedPaymentRequestResponse
     */
    'status'?: string;
}
/**
 * Details of the payment.
 * @export
 * @interface HostedPaymentResponseDetails
 */
export interface HostedPaymentResponseDetails {
    /**
     * A unique identifier provided to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof HostedPaymentResponseDetails
     */
    'paymentIdempotencyId'?: string;
    /**
     * The payment reference or description. Limited to a maximum of 18 characters for UK institutions.
     * @type {string}
     * @memberof HostedPaymentResponseDetails
     */
    'reference'?: string;
    /**
     * 
     * @type {PaymentContextTypeResponse}
     * @memberof HostedPaymentResponseDetails
     */
    'contextType'?: PaymentContextTypeResponse;
    /**
     * 
     * @type {PaymentTypeResponse}
     * @memberof HostedPaymentResponseDetails
     */
    'type'?: PaymentTypeResponse;
    /**
     * 
     * @type {PayeeDetailsResponse}
     * @memberof HostedPaymentResponseDetails
     */
    'payee'?: PayeeDetailsResponse;
    /**
     * 
     * @type {PayerDetailsResponse}
     * @memberof HostedPaymentResponseDetails
     */
    'payer'?: PayerDetailsResponse;
    /**
     * 
     * @type {AmountDetailsResponse}
     * @memberof HostedPaymentResponseDetails
     */
    'amountDetails'?: AmountDetailsResponse;
    /**
     * The date that the payment is due.
     * @type {string}
     * @memberof HostedPaymentResponseDetails
     */
    'paymentDueDate'?: string;
}


/**
 * The status of the payment.
 * @export
 * @interface HostedPaymentStatusDetails
 */
export interface HostedPaymentStatusDetails {
    /**
     * 
     * @type {PaymentStatus}
     * @memberof HostedPaymentStatusDetails
     */
    'status'?: PaymentStatus;
    /**
     * Date and time the status was updated.
     * @type {string}
     * @memberof HostedPaymentStatusDetails
     */
    'statusUpdateDate'?: string;
    /**
     * 
     * @type {HostedPaymentIsoStatus}
     * @memberof HostedPaymentStatusDetails
     */
    'isoStatus'?: HostedPaymentIsoStatus;
}


/**
 * 
 * @export
 * @interface HostedVRPConsentDetails
 */
export interface HostedVRPConsentDetails {
    /**
     * The unique ID of the consent request.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'id': string;
    /**
     * Represents the Unique Identifier for the `User` assigned by Yapily.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'userId'?: string;
    /**
     * Represents the User-friendly reference to the `User`.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'applicationUserId'?: string;
    /**
     * Represens the Unique Identifier of the `Application` the user is associated with.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'applicationId': string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof HostedVRPConsentDetails
     */
    'institutionIdentifiers'?: InstitutionIdentifiers;
    /**
     * 
     * @type {UserSettings}
     * @memberof HostedVRPConsentDetails
     */
    'userSettings'?: UserSettings;
    /**
     * URL of client\'s server to redirect the PSU after completion of the consent authorisation.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {VRPSetup}
     * @memberof HostedVRPConsentDetails
     */
    'vrpSetup': VRPSetup;
    /**
     * 
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'createdAt'?: string;
    /**
     * Represents the date and time at which the auth Token will expire.
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'authorisationExpiresAt'?: string;
    /**
     * Represents the authorisation to make VRP payments
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'consentToken'?: string;
    /**
     * Current status of the authorisation. Can be one of [AWAITING_AUTHORIZATION, AUTHORIZED, REJECTED, REVOKED, FAILED, EXPIRED]
     * @type {string}
     * @memberof HostedVRPConsentDetails
     */
    'consentStatus': string;
    /**
     * 
     * @type {Array<HostedVRPPhase>}
     * @memberof HostedVRPConsentDetails
     */
    'phases'?: Array<HostedVRPPhase>;
}
/**
 * 
 * @export
 * @interface HostedVRPConsentRequestResponse
 */
export interface HostedVRPConsentRequestResponse {
    /**
     * Represents the Unique Id of the VRP consent request
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'id': string;
    /**
     * Represents the Unique Id for the `User` assigned by Yapily.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'userId'?: string;
    /**
     * Represents the user-friendly reference to the `User`.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'applicationUserId'?: string;
    /**
     * Represents the Unique Id of the `Application` the user is associated with.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'applicationId': string;
    /**
     * 
     * @type {InstitutionIdentifiers}
     * @memberof HostedVRPConsentRequestResponse
     */
    'institutionIdentifiers'?: InstitutionIdentifiers;
    /**
     * 
     * @type {UserSettings}
     * @memberof HostedVRPConsentRequestResponse
     */
    'userSettings'?: UserSettings;
    /**
     * URL of client\'s server to redirect the PSU after completion of the consent authorisation.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {VRPSetupRequest}
     * @memberof HostedVRPConsentRequestResponse
     */
    'vrpSetup'?: VRPSetupRequest;
    /**
     * Represents the URL of Hosted UI page for the applicationId which initiates the user journey for the Consent. <br> URL would be appended with authToken, applicationId and userSettings.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'hostedUrl': string;
    /**
     * Represents the JWT Token signed by the certificate-vault using Yapily\'s keys.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'authToken': string;
    /**
     * Represents the date and time at which the Consent was created.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'createdAt': string;
    /**
     * Represents the date and time at which the auth Token will expire.
     * @type {string}
     * @memberof HostedVRPConsentRequestResponse
     */
    'authorisationExpiresAt'?: string;
}
/**
 * The restrictions and limits for payments executed under the VRP consent
 * @export
 * @interface HostedVRPLimits
 */
export interface HostedVRPLimits {
    /**
     * 
     * @type {Array<HostedNonSweepingPeriodicLimits>}
     * @memberof HostedVRPLimits
     */
    'periodicLimits'?: Array<HostedNonSweepingPeriodicLimits>;
    /**
     * __Optional__. Max amount that can be submitted per payment.
     * @type {Amount}
     * @memberof HostedVRPLimits
     */
    'maxAmountPerPayment'?: Amount;
    /**
     * __Optional__. Max cumulative amount that can be submitted under this consent.
     * @type {Amount}
     * @memberof HostedVRPLimits
     */
    'maxCumulativeAmount'?: Amount;
    /**
     * __Optional__. Max number of payments that can be submitted under this consent.
     * @type {number}
     * @memberof HostedVRPLimits
     */
    'maxCumulativeNumberOfPayments'?: number;
    /**
     * Indicates if the user edited the control parameters during authorisation
     * @type {boolean}
     * @memberof HostedVRPLimits
     */
    'editedByUser'?: boolean;
}
/**
 * The restrictions and limits for payments executed under the VRP consent
 * @export
 * @interface HostedVRPLimitsRequest
 */
export interface HostedVRPLimitsRequest {
    /**
     * 
     * @type {Array<HostedNonSweepingPeriodicLimits>}
     * @memberof HostedVRPLimitsRequest
     */
    'periodicLimits'?: Array<HostedNonSweepingPeriodicLimits>;
    /**
     * __Optional__. Max amount that can be submitted per payment.
     * @type {Amount}
     * @memberof HostedVRPLimitsRequest
     */
    'maxAmountPerPayment'?: Amount;
    /**
     * __Optional__. Max cumulative amount that can be submitted under this consent.
     * @type {Amount}
     * @memberof HostedVRPLimitsRequest
     */
    'maxCumulativeAmount'?: Amount;
    /**
     * __Optional__. Max number of payments that can be submitted under this consent.
     * @type {number}
     * @memberof HostedVRPLimitsRequest
     */
    'maxCumulativeNumberOfPayments'?: number;
}
/**
 * 
 * @export
 * @interface HostedVRPPaymentResponse
 */
export interface HostedVRPPaymentResponse {
    /**
     * 
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'paymentIdempotencyId'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof HostedVRPPaymentResponse
     */
    'amount'?: Amount;
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'reference'?: string;
    /**
     * 
     * @type {Payee}
     * @memberof HostedVRPPaymentResponse
     */
    'payee'?: Payee;
    /**
     * 
     * @type {HostedVrpPayerResponse}
     * @memberof HostedVRPPaymentResponse
     */
    'payer'?: HostedVrpPayerResponse;
    /**
     * 
     * @type {HostedVrpRefundAccount}
     * @memberof HostedVRPPaymentResponse
     */
    'refundAccount'?: HostedVrpRefundAccount;
    /**
     * 
     * @type {PaymentRisk}
     * @memberof HostedVRPPaymentResponse
     */
    'risk'?: PaymentRisk;
    /**
     * The Unique Identifier provided by TPP in the Payment request to identify the payment.
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'paymentLifecycleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'expectedExecutionTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'expectedSettlementTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedVRPPaymentResponse
     */
    'institutionPaymentId'?: string;
    /**
     * 
     * @type {HostedPaymentStatusDetails}
     * @memberof HostedVRPPaymentResponse
     */
    'statusDetails'?: HostedPaymentStatusDetails;
}
/**
 * The phase of the VRP Consent Request.
 * @export
 * @interface HostedVRPPhase
 */
export interface HostedVRPPhase {
    /**
     * The name of the hosted VRP consent process phase. Allowed values are : <ul> <li> INITIATED - Process initiated </li><li> DECLINED - Process failed and will not proceed further </li><li> INSTITUTION_SUBMITTED - Consent institution submitted </li><li> INPUT_CAPTURED - Additional input captured to process the Consent </li><li> IBAN_VALIDATED - Payer IBAN successfully validated </li><li> AUTHORISATION_CREATED - Consent authorisation request created with Institution, awaiting authorisation completion </li><li> AUTHORISATION_REJECTED - Consent Authorisation request rejected by Institution and will not proceed further </li><li> AUTHORISED - Consent authorisation completed </li><li> AUTHORISATION_FAILED - Consent authorisation failed and will not proceed further</li><li> SUBMITTED - Consent execution created and submitted to Institution </li><li> ACCEPTED - Consent execution accepted by Institution and awaiting settlement </li><li> REJECTED - Consent execution request rejected by Institution and will not proceed further </li><li> STATUS_POLLING_STARTED - Consent status polling started </li><li> STATUS_POLLING_ENDED - Consent status polling ended </li><li> MERCHANT_ACKNOWLEDGED - Consent acknowledgement received from merchant </li><li> FINISHED - Consent process completed </li> <li> REVOKED - Consent process completed </li>  </ul>
     * @type {string}
     * @memberof HostedVRPPhase
     */
    'phaseName'?: string;
    /**
     * The date and time at which the phase of the hosted Consent was created.
     * @type {string}
     * @memberof HostedVRPPhase
     */
    'phaseCreatedAt'?: string;
}
/**
 * 
 * @export
 * @interface HostedVrpAccountIdentification
 */
export interface HostedVrpAccountIdentification {
    /**
     * Used to describe the format of the account.<br><br> Allowed values: <br>MASKED_ACCOUNT_NUMBER<br>SORT_CODE<br>ACCOUNT_NUMBER 
     * @type {string}
     * @memberof HostedVrpAccountIdentification
     */
    'type': string;
    /**
     * __Mandatory__. The value associated with the account identification type.<br><br> See [Account Identification Combinations](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#account-identifications-combinations) for more information on the format of the values.
     * @type {string}
     * @memberof HostedVrpAccountIdentification
     */
    'identification': string;
}
/**
 * __Conditional__. Details of the benefactor [person or business].
 * @export
 * @interface HostedVrpPayerResponse
 */
export interface HostedVrpPayerResponse {
    /**
     * The account holder name of the Payer.
     * @type {string}
     * @memberof HostedVrpPayerResponse
     */
    'name'?: string;
    /**
     * __Mandatory__. The account identifications that identify the `Payer` bank account.
     * @type {Set<HostedVrpAccountIdentification>}
     * @memberof HostedVrpPayerResponse
     */
    'accountIdentifications': Set<HostedVrpAccountIdentification>;
    /**
     * 
     * @type {Address}
     * @memberof HostedVrpPayerResponse
     */
    'address'?: Address;
}
/**
 * The account to which funds should be returned if the payment is to be later refunded.
 * @export
 * @interface HostedVrpRefundAccount
 */
export interface HostedVrpRefundAccount {
    /**
     * 
     * @type {string}
     * @memberof HostedVrpRefundAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Set<HostedVrpAccountIdentification>}
     * @memberof HostedVrpRefundAccount
     */
    'accountIdentifications'?: Set<HostedVrpAccountIdentification>;
}
/**
 * Identification details of a party associated with an account e.g. (account owner or operator).
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'phone'?: string;
    /**
     * 
     * @type {Array<IdentityAddress>}
     * @memberof Identity
     */
    'addresses'?: Array<IdentityAddress>;
}
/**
 * 
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityAddress
     */
    'addressLines'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'streetName'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'buildingNumber'?: string;
    /**
     * 
     * @type {AddressTypeEnum}
     * @memberof IdentityAddress
     */
    'type'?: AddressTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IdentityAddress
     */
    'county'?: string;
}


/**
 * __Mandatory__. The payment initiation object defining the details of the payment under the Variable Recurring Payment consent.
 * @export
 * @interface InitiationDetails
 */
export interface InitiationDetails {
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof InitiationDetails
     */
    'reference'?: string;
    /**
     * 
     * @type {Payer}
     * @memberof InitiationDetails
     */
    'payer'?: Payer;
    /**
     * 
     * @type {Payee}
     * @memberof InitiationDetails
     */
    'payee'?: Payee;
}
/**
 * Typically, a bank or business unit within a bank e.g. (AIB Business, AIB Ireland, AIB UK).
 * @export
 * @interface Institution
 */
export interface Institution {
    /**
     * Unique identifier for the `Institution`.
     * @type {string}
     * @memberof Institution
     */
    'id'?: string;
    /**
     * The friendly name of the `Institution`.
     * @type {string}
     * @memberof Institution
     */
    'name'?: string;
    /**
     * The full name of the `Institution`.
     * @type {string}
     * @memberof Institution
     */
    'fullName'?: string;
    /**
     * An array of `Country` denoting which regions the `Institution` provides coverage for
     * @type {Set<Country>}
     * @memberof Institution
     */
    'countries'?: Set<Country>;
    /**
     * 
     * @type {EnvironmentType}
     * @memberof Institution
     */
    'environmentType'?: EnvironmentType;
    /**
     * 
     * @type {CredentialsType}
     * @memberof Institution
     */
    'credentialsType'?: CredentialsType;
    /**
     * Contains links to the logo and the icons for the `Institution`
     * @type {Set<Media>}
     * @memberof Institution
     */
    'media'?: Set<Media>;
    /**
     * 
     * @type {Set<FeatureEnum>}
     * @memberof Institution
     */
    'features'?: Set<FeatureEnum>;
    /**
     * 
     * @type {{ [key: string]: MonitoringFeatureStatus; }}
     * @memberof Institution
     */
    'monitoring'?: { [key: string]: MonitoringFeatureStatus; };
}


/**
 * `Institution` authorised consents which are currently in place for the `Application User`.
 * @export
 * @interface InstitutionConsent
 */
export interface InstitutionConsent {
    /**
     * __Mandatory__. The `Institution` the authorisation request is sent to.
     * @type {string}
     * @memberof InstitutionConsent
     */
    'institutionId'?: string;
}
/**
 * Raw error details provided by the `Institution`, when it was the error source.
 * @export
 * @interface InstitutionError
 */
export interface InstitutionError {
    /**
     * Textual description of the `Institution` error.
     * @type {string}
     * @memberof InstitutionError
     */
    'errorMessage'?: string;
    /**
     * Numeric HTTP status code associated with the `Institution` error.
     * @type {number}
     * @memberof InstitutionError
     */
    'httpStatusCode'?: number;
}
/**
 * Specifies the institution requirements for making the payment. Skips the bank selection screen in payment flow if the `institutionId` and `institutionCountryCode` are provided.
 * @export
 * @interface InstitutionIdentifiers
 */
export interface InstitutionIdentifiers {
    /**
     * Yapily identifier which identifies the `Institution` the payment request is sent to.
     * @type {string}
     * @memberof InstitutionIdentifiers
     */
    'institutionId'?: string;
    /**
     * 2 letter ISO Country code of the `Institution` the payment request is sent to.
     * @type {string}
     * @memberof InstitutionIdentifiers
     */
    'institutionCountryCode': string;
}
/**
 * Specifies the institution selected for making the payment.
 * @export
 * @interface InstitutionIdentifiersResponse
 */
export interface InstitutionIdentifiersResponse {
    /**
     * Yapily identifier which identifies the `Institution` the payment request is sent to.
     * @type {string}
     * @memberof InstitutionIdentifiersResponse
     */
    'institutionId'?: string;
    /**
     * 2 letter ISO Country code of the `Institution` the payment request is sent to.
     * @type {string}
     * @memberof InstitutionIdentifiersResponse
     */
    'institutionCountryCode'?: string;
}
/**
 * __Conditional__. Used to specify properties to define an international payment. <br><br>Must be specified when the payment `type` is one of the following:<ul>     <li><code>INTERNATIONAL_SINGLE_PAYMENT</code></li>     <li><code>INTERNATIONAL_SCHEDULED_PAYMENT</code></li>     <li><code>INTERNATIONAL_PERIODIC_PAYMENT</code></li></ul>
 * @export
 * @interface InternationalPaymentRequest
 */
export interface InternationalPaymentRequest {
    /**
     * __Mandatory__. The currency to be transferred to the payee. This may differ from the currency the payment is denoted in and the currency of the payer\'s account. Specified as a 3-letter code (ISO 4217).
     * @type {string}
     * @memberof InternationalPaymentRequest
     */
    'currencyOfTransfer': string;
    /**
     * 
     * @type {ExchangeRateInformation}
     * @memberof InternationalPaymentRequest
     */
    'exchangeRateInformation'?: ExchangeRateInformation;
    /**
     * __Optional__. Used to indicate the external purpose as a [ISO20022 purpose code](https://www.rba.hr/documents/20182/183267/External+purpose+codes+list/8a28f888-1f83-5e29-d6ed-fce05f428689?version=1.1) value.
     * @type {string}
     * @memberof InternationalPaymentRequest
     */
    'purpose'?: string;
    /**
     * 
     * @type {PriorityCodeEnum}
     * @memberof InternationalPaymentRequest
     */
    'priority'?: PriorityCodeEnum;
    /**
     * 
     * @type {ChargeBearerType}
     * @memberof InternationalPaymentRequest
     */
    'chargeBearer'?: ChargeBearerType;
}


/**
 * Defines the underlying transaction type (e.g. Card or Debit Transactions, Loans or Mortages). <br><br> Conforms to `ISO` standards - ISO 20022.
 * @export
 * @interface IsoBankTransactionCode
 */
export interface IsoBankTransactionCode {
    /**
     * 
     * @type {IsoCodeDetails}
     * @memberof IsoBankTransactionCode
     */
    'domainCode'?: IsoCodeDetails;
    /**
     * 
     * @type {IsoCodeDetails}
     * @memberof IsoBankTransactionCode
     */
    'familyCode'?: IsoCodeDetails;
    /**
     * 
     * @type {IsoCodeDetails}
     * @memberof IsoBankTransactionCode
     */
    'subFamilyCode'?: IsoCodeDetails;
}
/**
 * __Mandatory__. Details the identification of the ISO code.
 * @export
 * @interface IsoCodeDetails
 */
export interface IsoCodeDetails {
    /**
     * __Mandatory__. Unique identifier of the ISO code.
     * @type {string}
     * @memberof IsoCodeDetails
     */
    'code'?: string;
    /**
     * __Mandatory__. Name of the ISO Code.
     * @type {string}
     * @memberof IsoCodeDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'last'?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'previous'?: string;
}
/**
 * Details of the media held for the `Institution`
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * __Mandatory__. URL from where the media can be retrieved.
     * @type {string}
     * @memberof Media
     */
    'source'?: string;
    /**
     * __Mandatory__. The type of media e.g. (logo, icon).
     * @type {string}
     * @memberof Media
     */
    'type'?: string;
}
/**
 * Details of the merchant involved in the transaction.
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * The name of the merchant involved in the transaction.
     * @type {string}
     * @memberof Merchant
     */
    'merchantName'?: string;
    /**
     * Defines the underlying services and goods that the merchant provides. Specified as a 3-letter ISO 18245 code 
     * @type {string}
     * @memberof Merchant
     */
    'merchantCategoryCode'?: string;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface Model401VirtualAccountsApiErrorResponse
 */
export interface Model401VirtualAccountsApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof Model401VirtualAccountsApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof Model401VirtualAccountsApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface Model403VirtualAccountsApiErrorResponse
 */
export interface Model403VirtualAccountsApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof Model403VirtualAccountsApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof Model403VirtualAccountsApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface Model404VirtualAccountsApiErrorResponse
 */
export interface Model404VirtualAccountsApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof Model404VirtualAccountsApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof Model404VirtualAccountsApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface Model424VirtualAccountsApiErrorResponse
 */
export interface Model424VirtualAccountsApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof Model424VirtualAccountsApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof Model424VirtualAccountsApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * Used to return errors from the bank from each request<ul><li>`400` - Returned by any `POST` endpoint when the body does not conform to the contract</li><li>`401` - Returned by any endpoint when an invalid `authToken` is used for authentication</li><li>`403` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the `Consent` is no longer authorised to access financial data or to make a payment</li><li>`404` - Returned by any endpoint where there are path parameters and the path parameters supplied are unable to find the desired resource</li><li>`409` - Returned by any `POST` endpoint when creating a resource that conflicts with any other existing resource e.g. [Create User](https://docs.yapily.com/api/#create-user)</li><li>`424` - Returned by any [Financial Data](https://docs.yapily.com/api/#yapily-api-financial-data) and any [Payments](https://docs.yapily.com/api/#yapily-api-payments) endpoint when the feature to be accessed is not supported by the `Institution`.</li><li>`500` - Returned by any endpoint when Yapily is down. If you encounter any false positives, please <a href=\"mailto:support@yapily.com\">notify us</a></li></ul>
 * @export
 * @interface Model500VirtualAccountsApiErrorResponse
 */
export interface Model500VirtualAccountsApiErrorResponse {
    /**
     * 
     * @type {ErrorDetails}
     * @memberof Model500VirtualAccountsApiErrorResponse
     */
    'error'?: ErrorDetails;
    /**
     * 
     * @type {Array<MonitoringEndpointStatus>}
     * @memberof Model500VirtualAccountsApiErrorResponse
     */
    'monitoring'?: Array<MonitoringEndpointStatus>;
}
/**
 * 
 * @export
 * @interface MonitoringEndpointStatus
 */
export interface MonitoringEndpointStatus {
    /**
     * 
     * @type {string}
     * @memberof MonitoringEndpointStatus
     */
    'lastTested'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitoringEndpointStatus
     */
    'resourceEndpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitoringEndpointStatus
     */
    'span'?: string;
    /**
     * 
     * @type {MonitoringStatusEnum}
     * @memberof MonitoringEndpointStatus
     */
    'status'?: MonitoringStatusEnum;
}


/**
 * 
 * @export
 * @interface MonitoringFeatureStatus
 */
export interface MonitoringFeatureStatus {
    /**
     * 
     * @type {string}
     * @memberof MonitoringFeatureStatus
     */
    'lastTested'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitoringFeatureStatus
     */
    'span'?: string;
    /**
     * 
     * @type {MonitoringStatusEnum}
     * @memberof MonitoringFeatureStatus
     */
    'status'?: MonitoringStatusEnum;
}


/**
 * The latest operational status.
 * @export
 * @enum {string}
 */

export const MonitoringStatusEnum = {
    Up: 'Up',
    Down: 'Down',
    Warning: 'Warning',
    Unknown: 'Unknown',
    Expired: 'Expired'
} as const;

export type MonitoringStatusEnum = typeof MonitoringStatusEnum[keyof typeof MonitoringStatusEnum];


/**
 * Details the additional levels of authorisation which are required from, and being managed by, the `Institution`.
 * @export
 * @interface MultiAuthorisation
 */
export interface MultiAuthorisation {
    /**
     * _Mandatory_. Specifies the current status of the multi-authorisation flow.
     * @type {string}
     * @memberof MultiAuthorisation
     */
    'status'?: string;
    /**
     * __Mandatory__. Total number of authorisations required.
     * @type {number}
     * @memberof MultiAuthorisation
     */
    'numberOfAuthorisationRequired'?: number;
    /**
     * __Mandatory__. The total number of authorisations that have been recieved.
     * @type {number}
     * @memberof MultiAuthorisation
     */
    'numberOfAuthorisationReceived'?: number;
    /**
     * __Mandatory__. Date and time of when the authorisation was last updated.
     * @type {string}
     * @memberof MultiAuthorisation
     */
    'lastUpdatedDateTime'?: string;
    /**
     * __Mandatory__. Date and time by when the authorisation flow must be completed before it expires and the authorisation request is terminated.
     * @type {string}
     * @memberof MultiAuthorisation
     */
    'expirationDateTime'?: string;
}
/**
 * Details of a new user to be created for the application.
 * @export
 * @interface NewApplicationUser
 */
export interface NewApplicationUser {
    /**
     * __Optional__. The unique identifier of the `Application User` assigned by the Application Owner.
     * @type {string}
     * @memberof NewApplicationUser
     */
    'applicationUserId'?: string;
    /**
     * __Deprecated__. A non-unique reference Id for the `Application User`.
     * @type {string}
     * @memberof NewApplicationUser
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @interface Next
 */
export interface Next {
    /**
     * 
     * @type {string}
     * @memberof Next
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof Next
     */
    'before'?: string;
    /**
     * 
     * @type {number}
     * @memberof Next
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof Next
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface NonSweepingAuthorisationRequest
 */
export interface NonSweepingAuthorisationRequest {
    /**
     * This is the Yapily user identifier for the user returned by the create user step POST ../users
     * @type {string}
     * @memberof NonSweepingAuthorisationRequest
     */
    'userId'?: string;
    /**
     * A client\'s own user reference. If the client wants to work with their own unique references for individual PSUs then they can use the applicationUserId property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied applicationUserId, then a new Yapily userId is created automatically and linked to the applicationUserId value.  Clients can then use either their own applicationUserId or the Yapily userId to reference the same user in future calls.
     * @type {string}
     * @memberof NonSweepingAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof NonSweepingAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Optional__. The payment context code. Allowed values are [BILL_IN_ADVANCE, BILL_IN_ARREARS, ECOMMERCE_MERCHANT, FACE_TO_FACE_POS, TRANSFER_TO_SELF,TRANSFER_TO_THIRD_PARTY, PISP_PAYEE ].
     * @type {string}
     * @memberof NonSweepingAuthorisationRequest
     */
    'contextType'?: string;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof NonSweepingAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/knowledge/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof NonSweepingAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof NonSweepingAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/knowledge/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof NonSweepingAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {NonSweepingControlParameters}
     * @memberof NonSweepingAuthorisationRequest
     */
    'controlParameters': NonSweepingControlParameters;
    /**
     * 
     * @type {InitiationDetails}
     * @memberof NonSweepingAuthorisationRequest
     */
    'initiationDetails': InitiationDetails;
    /**
     * 
     * @type {ComplianceData}
     * @memberof NonSweepingAuthorisationRequest
     */
    'complianceData'?: ComplianceData;
}
/**
 * 
 * @export
 * @interface NonSweepingAuthorisationResponse
 */
export interface NonSweepingAuthorisationResponse {
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'id'?: string;
    /**
     * This is the Yapily user identifier for the user returned by the create user step POST ../users
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'userId'?: string;
    /**
     * A client\'s own user reference. If the client wants to work with their own unique references for individual PSUs then they can use the applicationUserId property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied applicationUserId, then a new Yapily userId is created automatically and linked to the applicationUserId value.  Clients can then use either their own applicationUserId or the Yapily userId to reference the same user in future calls.
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'applicationUserId'?: string;
    /**
     * The reference to the Institution which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof NonSweepingAuthorisationResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'createdAt'?: string;
    /**
     * __Optional__. Used to granularly specify the set of features that the user will give their consent for when requesting access to their account information. Depending on the `Institution`, this may also populate a consent screen which list these scopes before the user authorises.<br><br>This endpoint accepts allow all [Financial Data Features](/guides/financial-data/features/#feature-list) that the `Institution` supports.To find out which scopes an `Institution` supports, check [GET Institution](./#get-institution).
     * @type {Set<FeatureEnum>}
     * @memberof NonSweepingAuthorisationResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * The `consent-token` containing the user\'s authorisation to make the payment request.
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'consentToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'authorizedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'authorisationUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSweepingAuthorisationResponse
     */
    'qrCodeUrl'?: string;
    /**
     * 
     * @type {NonSweepingControlParameters}
     * @memberof NonSweepingAuthorisationResponse
     */
    'controlParameters'?: NonSweepingControlParameters;
    /**
     * 
     * @type {Payer}
     * @memberof NonSweepingAuthorisationResponse
     */
    'payer'?: Payer;
    /**
     * 
     * @type {InitiationDetails}
     * @memberof NonSweepingAuthorisationResponse
     */
    'initiationDetails'?: InitiationDetails;
}


/**
 * Define the restrictions and limits for payment orders as part of Non-Sweeping VRP consent
 * @export
 * @interface NonSweepingControlParameters
 */
export interface NonSweepingControlParameters {
    /**
     * __Mandatory__. Defines the authentication method(s) allowed in payment submission step. Allowed values are [SCA_REQUIRED, SCA_NOT_REQUIRED].
     * @type {Array<string>}
     * @memberof NonSweepingControlParameters
     */
    'psuAuthenticationMethods': Array<string>;
    /**
     * 
     * @type {Array<NonSweepingPeriodicLimits>}
     * @memberof NonSweepingControlParameters
     */
    'periodicLimits'?: Array<NonSweepingPeriodicLimits>;
    /**
     * __Mandatory__. Max amount that can be submitted per payment.
     * @type {Amount}
     * @memberof NonSweepingControlParameters
     */
    'maxAmountPerPayment'?: Amount;
    /**
     * __Optional__. Max cumulative amount that can be submitted under this consent.
     * @type {Amount}
     * @memberof NonSweepingControlParameters
     */
    'maxCumulativeAmount'?: Amount;
    /**
     * __Mandatory__. Initial payment to be charged under this consent. If enforced, this amount must match the first payment amount executed using this consent.
     * @type {Amount}
     * @memberof NonSweepingControlParameters
     */
    'initialPayment'?: Amount;
    /**
     * __Optional__. Max number of payments that can be submitted under this consent.
     * @type {number}
     * @memberof NonSweepingControlParameters
     */
    'maxCumulativeNumberOfPayments'?: number;
    /**
     * __Optional__. Start date when the consent becomes valid.
     * @type {string}
     * @memberof NonSweepingControlParameters
     */
    'validFrom'?: string;
    /**
     * __Optional__. End date when the consent expires and becomes invalid.
     * @type {string}
     * @memberof NonSweepingControlParameters
     */
    'validTo'?: string;
    /**
     * The use-case for the VRP consent supported by the bank. Allowed values: <br>`ONGOING` <br>`SUBSCRIPTION`
     * @type {string}
     * @memberof NonSweepingControlParameters
     */
    'recurringPaymentCategory'?: string;
}
/**
 * 
 * @export
 * @interface NonSweepingPeriodicLimits
 */
export interface NonSweepingPeriodicLimits {
    /**
     * __Mandatory__. Maximum amount that can be specified in all payment instructions in a given period under this VRP consent. If the Alignment is Calendar, the limit is pro-rated in the first period to the remaining number of days.
     * @type {Amount}
     * @memberof NonSweepingPeriodicLimits
     */
    'totalMaxAmount': Amount;
    /**
     * __Mandatory__. Frequency for which the payment limits are enforced. Allowed values are [DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, YEARLY]. This field cannot be enforced when `recurringPaymentCategory=ONGOING`.
     * @type {string}
     * @memberof NonSweepingPeriodicLimits
     */
    'frequency'?: string;
    /**
     * __Mandatory__. Period alignment for which the payment limits are enforced. Allowed values are [CONSENT, CALENDAR]. If CONSENT, then period starts on consent creation date. If CALENDAR, then period lines up with the frequency e.g. WEEKLY period will begin at start of the week in question. This field cannot be enforced when `recurringPaymentCategory=ONGOING`.
     * @type {string}
     * @memberof NonSweepingPeriodicLimits
     */
    'alignment'?: string;
    /**
     * __Optional__. Max number of payments that can be submitted under this period.
     * @type {number}
     * @memberof NonSweepingPeriodicLimits
     */
    'maxNumberOfPayments'?: number;
}
/**
 * Subscription details for how and where to receive notifications.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * How the notification will be delivered. This is currently only via WEBHOOK.
     * @type {string}
     * @memberof Notification
     */
    'type': string;
    /**
     * URL to which the notification will be sent.
     * @type {string}
     * @memberof Notification
     */
    'url': string;
}
/**
 * The request body containing the `OneTimeTokenRequest` json payload
 * @export
 * @interface OneTimeTokenRequest
 */
export interface OneTimeTokenRequest {
    /**
     * __Mandatory__. The one time token to exchange for a consent token.
     * @type {string}
     * @memberof OneTimeTokenRequest
     */
    'oneTimeToken': string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'totalCount'?: number;
    /**
     * 
     * @type {FilterAndSort}
     * @memberof Pagination
     */
    'self'?: FilterAndSort;
    /**
     * 
     * @type {Next}
     * @memberof Pagination
     */
    'next'?: Next;
}
/**
 * __Mandatory__. Details of the beneficiary [person or business].
 * @export
 * @interface Payee
 */
export interface Payee {
    /**
     * __Mandatory__. The account holder name of the beneficiary.
     * @type {string}
     * @memberof Payee
     */
    'name': string;
    /**
     * __Mandatory__. The account identifications that identify the `Payee` bank account.
     * @type {Set<AccountIdentification>}
     * @memberof Payee
     */
    'accountIdentifications': Set<AccountIdentification>;
    /**
     * __Optional__. The payee account type. <br><br>Allowed values: BUSINESS, BUSINESS_SAVING, CHARITY, COLLECTION, CORPORATE, E_WALLET, GOVERNMENT, INVESTMENT, INVESTMENT_ISA, JOINT_PERSONAL, PENSION, PERSONAL, PERSONAL_SAVING, PREMIER, WEALTH .
     * @type {string}
     * @memberof Payee
     */
    'accountType'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Payee
     */
    'address'?: Address;
    /**
     * __Optional__. The merchant ID is a unique code provided by the payment processor to the merchant.
     * @type {string}
     * @memberof Payee
     */
    'merchantId'?: string;
    /**
     * __Optional__. The category code of the merchant in case the `Payee` is a business. Specified as a 3-letter ISO 18245 code.
     * @type {string}
     * @memberof Payee
     */
    'merchantCategoryCode'?: string;
}
/**
 * __Mandatory__. Details of the beneficiary [person or business].
 * @export
 * @interface PayeeDetails
 */
export interface PayeeDetails {
    /**
     * __Mandatory__. The account holder name of the beneficiary.
     * @type {string}
     * @memberof PayeeDetails
     */
    'name': string;
    /**
     * __Mandatory__. The account identifications that identify the `Payee` bank account.
     * @type {Set<AccountIdentification>}
     * @memberof PayeeDetails
     */
    'accountIdentifications': Set<AccountIdentification>;
    /**
     * __Conditional__. The 2-letter ISO 3166 country code for the address. <br><br>An `Institution` may require you to specify the `country` when used in the context of the `Payee` to be able to make a payment
     * @type {string}
     * @memberof PayeeDetails
     */
    'country': string;
}
/**
 *  Details of the beneficiary [person or business].
 * @export
 * @interface PayeeDetailsResponse
 */
export interface PayeeDetailsResponse {
    /**
     * The account holder name of the beneficiary.
     * @type {string}
     * @memberof PayeeDetailsResponse
     */
    'name'?: string;
    /**
     * The account identifications that identify the `Payee` bank account.
     * @type {Set<AccountIdentificationResponse>}
     * @memberof PayeeDetailsResponse
     */
    'accountIdentifications'?: Set<AccountIdentificationResponse>;
    /**
     * 
     * @type {AddressResponse}
     * @memberof PayeeDetailsResponse
     */
    'address'?: AddressResponse;
    /**
     * The merchant ID is a unique code provided by the payment processor to the merchant.
     * @type {string}
     * @memberof PayeeDetailsResponse
     */
    'merchantId'?: string;
    /**
     * The category code of the merchant in case the `Payee` is a business. Specified as a 3-letter ISO 18245 code.
     * @type {string}
     * @memberof PayeeDetailsResponse
     */
    'merchantCategoryCode'?: string;
}
/**
 * __Conditional__. Details of the benefactor [person or business].
 * @export
 * @interface Payer
 */
export interface Payer {
    /**
     * The account holder name of the Payer.
     * @type {string}
     * @memberof Payer
     */
    'name'?: string;
    /**
     * __Mandatory__. The account identifications that identify the `Payer` bank account.
     * @type {Set<AccountIdentification>}
     * @memberof Payer
     */
    'accountIdentifications': Set<AccountIdentification>;
    /**
     * 
     * @type {Address}
     * @memberof Payer
     */
    'address'?: Address;
}
/**
 * __Conditional__. Details of the benefactor [person or business].
 * @export
 * @interface PayerDetails
 */
export interface PayerDetails {
    /**
     * __Mandatory__. The account identifications that identify the `Payer` bank account.
     * @type {Set<AccountIdentification>}
     * @memberof PayerDetails
     */
    'accountIdentifications': Set<AccountIdentification>;
}
/**
 * Details of the benefactor [person or business].
 * @export
 * @interface PayerDetailsResponse
 */
export interface PayerDetailsResponse {
    /**
     * The account holder name of the Payer.
     * @type {string}
     * @memberof PayerDetailsResponse
     */
    'name'?: string;
    /**
     * The account identifications that identify the `Payer` bank account.
     * @type {Set<AccountIdentificationResponse>}
     * @memberof PayerDetailsResponse
     */
    'accountIdentifications'?: Set<AccountIdentificationResponse>;
    /**
     * 
     * @type {AddressResponse}
     * @memberof PayerDetailsResponse
     */
    'address'?: AddressResponse;
}
/**
 * The request body containing an `PaymentAuthorisationRequest` json payload
 * @export
 * @interface PaymentAuthorisationRequest
 */
export interface PaymentAuthorisationRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof PaymentAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof PaymentAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof PaymentAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The URL to redirect the user to after the user complete the authorisation at the `Institution`.
     * @type {string}
     * @memberof PaymentAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof PaymentAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof PaymentAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {PaymentRequest}
     * @memberof PaymentAuthorisationRequest
     */
    'paymentRequest': PaymentRequest;
}
/**
 * 
 * @export
 * @interface PaymentAuthorisationRequestResponse
 */
export interface PaymentAuthorisationRequestResponse {
    /**
     * Unique identifier for the payment authorisation request. <br><br>The `consentID` used to [retrieve a consent](/api/reference/#operation/getConsentById).
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'id'?: string;
    /**
     * The `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'userUuid'?: string;
    /**
     * The user-friendly reference to the `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'referenceId'?: string;
    /**
     * The `Institution` the authorisation request was sent to.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time the consent was created.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'transactionTo'?: string;
    /**
     * Date and time the authorisation expires. Re-authorisation is needed to retain access.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentAuthorisationRequestResponse
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'timeToExpire'?: string;
    /**
     * The set of features the consent provides access to.
     * @type {Set<FeatureEnum>}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to make a payment request.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'consentToken'?: string;
    /**
     * Correlation ID used with the `Institution` during the authorisation process.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'state'?: string;
    /**
     * Date and time the request was authorised by the `Institution`.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'authorizedAt'?: string;
    /**
     * Unique identifier of the consent assigned by the `Institution`.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {Array<PaymentChargeDetails>}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'charges'?: Array<PaymentChargeDetails>;
    /**
     * 
     * @type {ExchangeRateInformationResponse}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'exchangeRateInformation'?: ExchangeRateInformationResponse;
    /**
     * 
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'authorisationUrl'?: string;
    /**
     * The URL for a QR code that may be scanned via a mobile device to make a authorisation redirect to the bank (authURL encoded).
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'qrCodeUrl'?: string;
    /**
     * Message from the `Institution` received by Yapily, detailing the next action the user is required to take. This is used only for Decoupled flows.
     * @type {string}
     * @memberof PaymentAuthorisationRequestResponse
     */
    'explanation'?: string;
}


/**
 * Details the charges that will apply to the payment.
 * @export
 * @interface PaymentChargeDetails
 */
export interface PaymentChargeDetails {
    /**
     * 
     * @type {Amount}
     * @memberof PaymentChargeDetails
     */
    'chargeAmount'?: Amount;
    /**
     * __Mandatory__. Specifies the nature of the transaction charge e.g. (Bank transfer fees).
     * @type {string}
     * @memberof PaymentChargeDetails
     */
    'chargeType'?: string;
    /**
     * __Mandatory__. States which party of the payment bears the charges.
     * @type {string}
     * @memberof PaymentChargeDetails
     */
    'chargeTo'?: string;
}
/**
 * 
 * @export
 * @interface PaymentConstraintsResponse
 */
export interface PaymentConstraintsResponse {
    /**
     * The id to represent the `Institution`.
     * @type {string}
     * @memberof PaymentConstraintsResponse
     */
    'institutionId': string;
    /**
     * 2 letter ISO Country code of the `Institution`.
     * @type {string}
     * @memberof PaymentConstraintsResponse
     */
    'institutionCountryCode'?: string;
    /**
     * Define the applicable API end point.
     * @type {string}
     * @memberof PaymentConstraintsResponse
     */
    'endpointPath'?: string;
    /**
     * Https Method for the endpoint.
     * @type {string}
     * @memberof PaymentConstraintsResponse
     */
    'endpointMethod'?: string;
    /**
     * 
     * @type {PaymentTypeOfConstraints}
     * @memberof PaymentConstraintsResponse
     */
    'paymentType': PaymentTypeOfConstraints;
    /**
     * 
     * @type {RequestConstraints}
     * @memberof PaymentConstraintsResponse
     */
    'request': RequestConstraints;
}


/**
 * __Optional__. The payment context code. This defaults to `OTHER` if not specified.
 * @export
 * @enum {string}
 */

export const PaymentContextType = {
    Bill: 'BILL',
    Goods: 'GOODS',
    Services: 'SERVICES',
    Other: 'OTHER',
    PersonToPerson: 'PERSON_TO_PERSON',
    BillInAdvance: 'BILL_IN_ADVANCE',
    BillInArrears: 'BILL_IN_ARREARS',
    EcommerceMerchant: 'ECOMMERCE_MERCHANT',
    FaceToFacePos: 'FACE_TO_FACE_POS',
    TransferToSelf: 'TRANSFER_TO_SELF',
    TransferToThirdParty: 'TRANSFER_TO_THIRD_PARTY',
    PispPayee: 'PISP_PAYEE'
} as const;

export type PaymentContextType = typeof PaymentContextType[keyof typeof PaymentContextType];


/**
 * The payment context code.
 * @export
 * @enum {string}
 */

export const PaymentContextTypeResponse = {
    Bill: 'BILL',
    Goods: 'GOODS',
    Services: 'SERVICES',
    Other: 'OTHER',
    PersonToPerson: 'PERSON_TO_PERSON'
} as const;

export type PaymentContextTypeResponse = typeof PaymentContextTypeResponse[keyof typeof PaymentContextTypeResponse];


/**
 * The request body containing an `PaymentEmbeddedAuthorisationRequest` json payload
 * @export
 * @interface PaymentEmbeddedAuthorisationRequest
 */
export interface PaymentEmbeddedAuthorisationRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {PaymentRequest}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'paymentRequest': PaymentRequest;
    /**
     * 
     * @type {UserCredentials}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'userCredentials'?: UserCredentials;
    /**
     * 
     * @type {ScaMethod}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'selectedScaMethod'?: ScaMethod;
    /**
     * __Conditional__. Used to update the authorisation with the sca code received by the user from the `Institution` using the embedded payment authorisation flow.<br><br>This is the penultimate step required in the embedded payment authorisation flow to authorise the `Consent`. After sending the sca code, to obtain an authorised consent, the last step is to poll [Get Consent](https://docs.yapily.com/api/reference/#operation/getConsentById) until the `Institution` authorises the request and the `Consent` `status` transitions to `AUTHORIZED`.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequest
     */
    'scaCode'?: string;
}
/**
 * 
 * @export
 * @interface PaymentEmbeddedAuthorisationRequestResponse
 */
export interface PaymentEmbeddedAuthorisationRequestResponse {
    /**
     * Unique identifier for the embedded payment authorisation request.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'id'?: string;
    /**
     * The `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'userUuid'?: string;
    /**
     * The user-friendly reference to the `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'referenceId'?: string;
    /**
     * The  `Institution` the authorisation request was sent to.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time the embedded payment authorisation was created.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'transactionTo'?: string;
    /**
     * Date and time the authorisation expires. Re-authorisation is needed to retain access.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'timeToExpire'?: string;
    /**
     * The set of features the consent provides access to.
     * @type {Set<FeatureEnum>}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to make a payment request.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'consentToken'?: string;
    /**
     * Correlation ID used with the `Institution` during the authorisation process.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'state'?: string;
    /**
     * Date and time the request was authorised by the `Institution`.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'authorizedAt'?: string;
    /**
     * Identification of the consent at the `Institution`.
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {Array<PaymentChargeDetails>}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'charges'?: Array<PaymentChargeDetails>;
    /**
     * 
     * @type {ExchangeRateInformationResponse}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'exchangeRateInformation'?: ExchangeRateInformationResponse;
    /**
     * 
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'authorisationUrl'?: string;
    /**
     * The URL link for the QR code that may be scanned via a mobile device to make an authorisation redirect to the bank (authURL encoded).
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'qrCodeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'explanation'?: string;
    /**
     * 
     * @type {Array<ScaMethod>}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'scaMethods'?: Array<ScaMethod>;
    /**
     * 
     * @type {ScaMethod}
     * @memberof PaymentEmbeddedAuthorisationRequestResponse
     */
    'selectedScaMethod'?: ScaMethod;
}


/**
 * The payment status code, as denoted by a 3-letter ISO 20022 code.
 * @export
 * @interface PaymentIsoStatus
 */
export interface PaymentIsoStatus {
    /**
     * 
     * @type {PaymentIsoStatusCodeEnum}
     * @memberof PaymentIsoStatus
     */
    'code'?: PaymentIsoStatusCodeEnum;
    /**
     * The full name of the ISO 20022 `PaymentStatusCode`.
     * @type {string}
     * @memberof PaymentIsoStatus
     */
    'name'?: string;
}


/**
 * The ISO 20022 `PaymentStatusCode`.
 * @export
 * @enum {string}
 */

export const PaymentIsoStatusCodeEnum = {
    Accc: 'ACCC',
    Accp: 'ACCP',
    Acsc: 'ACSC',
    Acsp: 'ACSP',
    Actc: 'ACTC',
    Acwc: 'ACWC',
    Acwp: 'ACWP',
    Rcvd: 'RCVD',
    Pdng: 'PDNG',
    Rjct: 'RJCT',
    Canc: 'CANC',
    Acfc: 'ACFC',
    Patc: 'PATC',
    Part: 'PART'
} as const;

export type PaymentIsoStatusCodeEnum = typeof PaymentIsoStatusCodeEnum[keyof typeof PaymentIsoStatusCodeEnum];


/**
 * __Mandatory__. The payment pre authorisation request object defining the details of the payment and pre auth.
 * @export
 * @interface PaymentPreAuthorisationRequest
 */
export interface PaymentPreAuthorisationRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters to be forwarded in the redirect back to the client after the user authorisation flow has been completed.
     * @type {Array<string>}
     * @memberof PaymentPreAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof PaymentPreAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof PaymentPreAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * __Mandatory__. Defines the scope of the pre-authorisation request.
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'scope': string;
    /**
     * 
     * @type {PayeeDetails}
     * @memberof PaymentPreAuthorisationRequest
     */
    'payee': PayeeDetails;
    /**
     * 
     * @type {PayerDetails}
     * @memberof PaymentPreAuthorisationRequest
     */
    'payer': PayerDetails;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentPreAuthorisationRequest
     */
    'amount': Amount;
    /**
     * __Mandatory__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof PaymentPreAuthorisationRequest
     */
    'reference': string;
}
/**
 * __Mandatory__. The payment request object defining the details of the payment.
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * __Mandatory__. A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof PaymentRequest
     */
    'paymentIdempotencyId': string;
    /**
     * 
     * @type {Payer}
     * @memberof PaymentRequest
     */
    'payer'?: Payer;
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof PaymentRequest
     */
    'reference'?: string;
    /**
     * 
     * @type {PaymentContextType}
     * @memberof PaymentRequest
     */
    'contextType'?: PaymentContextType;
    /**
     * __Optional__. The payment purpose code. <br><br>Allowed values: INTP,DEPT,BEXP,LICF,SERV,SUPP,TRAD,SUBS,GDSV,ROYA,COMT,CHAR,ECPR,CLPR,INTE,LOAN,LOAR,INPC,INPR,INSC,INSU,LIFI,PPTI,HLRP,HLST,PDEP,IVPT,REBT,REFU,CDBL,CPKC,EDUC,FEES,GAMB,LOTT,GIFT,INSM,REOD,GOVT,TCSC,BLDM,RENT,DIVD,INVS,SAVG,HLTI,DNTS,LTCF,MDCS,VIEW,BECH,BENE,SSBE,PEFC,PENS,ADCS,BONU,COMM,SALA,ESTX,HSTX,INTX,PTXP,RDTX,TAXS,VATX,WHLD,TAXR,CBTV,ELEC,GASB,PHON,UBIL,WTER . <br><br>See [Payment Purpose code](https://docs.yapily.com/pages/payments/payments-resources/tri-pilot/) to see the definition of each code
     * @type {string}
     * @memberof PaymentRequest
     */
    'purposeCode'?: string;
    /**
     * 
     * @type {PaymentType}
     * @memberof PaymentRequest
     */
    'type': PaymentType;
    /**
     * 
     * @type {Payee}
     * @memberof PaymentRequest
     */
    'payee': Payee;
    /**
     * 
     * @type {PeriodicPaymentRequest}
     * @memberof PaymentRequest
     */
    'periodicPayment'?: PeriodicPaymentRequest;
    /**
     * 
     * @type {InternationalPaymentRequest}
     * @memberof PaymentRequest
     */
    'internationalPayment'?: InternationalPaymentRequest;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentRequest
     */
    'amount': Amount;
    /**
     * __Conditional__. Used to specify the date of the payment when the payment type is one of the following:<ul>    <li><code>DOMESTIC_SCHEDULED_PAYMENT</code></li>    <li><code>DOMESTIC_PERIODIC_PAYMENT</code></li>    <li><code>INTERNATIONAL_SCHEDULED_PAYMENT</code></li>    <li><code>INTERNATIONAL_PERIODIC_PAYMENT</code></li></ul>
     * @type {string}
     * @memberof PaymentRequest
     */
    'paymentDateTime'?: string;
    /**
     * __Optional__. Used to request the payer details in the payment response when the `Institution` provides the feature `READ_DOMESTIC_SINGLE_REFUND`.<br><br>See [Reverse Payments](https://docs.yapily.com/pages/knowledge/open-banking/reverse_payments/) for more information.
     * @type {boolean}
     * @memberof PaymentRequest
     */
    'readRefundAccount'?: boolean;
}


/**
 * 
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
    /**
     * Unique identifier of the payment.
     * @type {string}
     * @memberof PaymentResponse
     */
    'id'?: string;
    /**
     * Identification of the consent at the Institution.
     * @type {string}
     * @memberof PaymentResponse
     */
    'institutionConsentId'?: string;
    /**
     * __Mandatory__. A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof PaymentResponse
     */
    'paymentIdempotencyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentResponse
     */
    'paymentLifecycleId'?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentResponse
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {PaymentStatusDetails}
     * @memberof PaymentResponse
     */
    'statusDetails'?: PaymentStatusDetails;
    /**
     * 
     * @type {Payer}
     * @memberof PaymentResponse
     */
    'payer'?: Payer;
    /**
     * 
     * @type {Payee}
     * @memberof PaymentResponse
     */
    'payeeDetails'?: Payee;
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof PaymentResponse
     */
    'reference'?: string;
    /**
     * Monetary amount.
     * @type {number}
     * @memberof PaymentResponse
     */
    'amount'?: number;
    /**
     * Currency the payment amount is denoted in. Specified as a 3-letter ISO 4217 code.
     * @type {string}
     * @memberof PaymentResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentResponse
     */
    'amountDetails'?: Amount;
    /**
     * Date and time of when the payment request was created.
     * @type {string}
     * @memberof PaymentResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentResponse
     */
    'firstPaymentAmount'?: Amount;
    /**
     * Date and time of when the first payment request is to be made.
     * @type {string}
     * @memberof PaymentResponse
     */
    'firstPaymentDateTime'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentResponse
     */
    'nextPaymentAmount'?: Amount;
    /**
     * __Conditional__. Defines when the recurring payment is to be made.
     * @type {string}
     * @memberof PaymentResponse
     */
    'nextPaymentDateTime'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentResponse
     */
    'finalPaymentAmount'?: Amount;
    /**
     * Date and time of when the final payment is to be made.
     * @type {string}
     * @memberof PaymentResponse
     */
    'finalPaymentDateTime'?: string;
    /**
     * Number of recurring payment requests to be made as part of the instructed payment schedule.
     * @type {number}
     * @memberof PaymentResponse
     */
    'numberOfPayments'?: number;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentResponse
     */
    'previousPaymentAmount'?: Amount;
    /**
     * Date and time of when the previous payment request was posted.
     * @type {string}
     * @memberof PaymentResponse
     */
    'previousPaymentDateTime'?: string;
    /**
     * 
     * @type {Array<PaymentChargeDetails>}
     * @memberof PaymentResponse
     */
    'chargeDetails'?: Array<PaymentChargeDetails>;
    /**
     * Details the execution type and the payment date between the payer and the payee.
     * @type {string}
     * @memberof PaymentResponse
     */
    'scheduledPaymentType'?: string;
    /**
     * Date and time of when the scheduled payment request will be made.
     * @type {string}
     * @memberof PaymentResponse
     */
    'scheduledPaymentDateTime'?: string;
    /**
     * 
     * @type {FrequencyResponse}
     * @memberof PaymentResponse
     */
    'frequency'?: FrequencyResponse;
    /**
     * __Mandatory__. The currency to be transferred to the payee. This may differ from the currency the payment is denoted in and the currency of the payer\'s account. Specified as a 3-letter code (ISO 4217).
     * @type {string}
     * @memberof PaymentResponse
     */
    'currencyOfTransfer'?: string;
    /**
     * Specifies the external purpose code for the `Institution` - IS0 20022.
     * @type {string}
     * @memberof PaymentResponse
     */
    'purpose'?: string;
    /**
     * 
     * @type {PriorityCodeEnum}
     * @memberof PaymentResponse
     */
    'priority'?: PriorityCodeEnum;
    /**
     * 
     * @type {ExchangeRateInformationResponse}
     * @memberof PaymentResponse
     */
    'exchangeRate'?: ExchangeRateInformationResponse;
    /**
     * 
     * @type {RefundAccount}
     * @memberof PaymentResponse
     */
    'refundAccount'?: RefundAccount;
    /**
     * 
     * @type {number}
     * @memberof PaymentResponse
     */
    'bulkAmountSum'?: number;
}


/**
 * 
 * @export
 * @interface PaymentResponses
 */
export interface PaymentResponses {
    /**
     * 
     * @type {Array<PaymentResponse>}
     * @memberof PaymentResponses
     */
    'payments'?: Array<PaymentResponse>;
}
/**
 * Additional information about the payment that may be used for risk scoring
 * @export
 * @interface PaymentRisk
 */
export interface PaymentRisk {
    /**
     * __Optional__. The payment context code. Allowed values are [BILL_IN_ADVANCE, BILL_IN_ARREARS, ECOMMERCE_MERCHANT, FACE_TO_FACE_POS, TRANSFER_TO_SELF,TRANSFER_TO_THIRD_PARTY, PISP_PAYEE ].
     * @type {string}
     * @memberof PaymentRisk
     */
    'contextType'?: string;
}
/**
 * The status of the Payment. <br><br>For more information, see [Payment Status](/guides/payments/payment-status/)
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Pending: 'PENDING',
    Failed: 'FAILED',
    Declined: 'DECLINED',
    Completed: 'COMPLETED',
    CompletedSettlementInProcess: 'COMPLETED_SETTLEMENT_IN_PROCESS',
    Expired: 'EXPIRED',
    Unknown: 'UNKNOWN',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface PaymentStatusDetails
 */
export interface PaymentStatusDetails {
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentStatusDetails
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatusDetails
     */
    'statusReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatusDetails
     */
    'statusReasonDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentStatusDetails
     */
    'statusUpdateDate'?: string;
    /**
     * 
     * @type {MultiAuthorisation}
     * @memberof PaymentStatusDetails
     */
    'multiAuthorisationStatus'?: MultiAuthorisation;
    /**
     * 
     * @type {PaymentIsoStatus}
     * @memberof PaymentStatusDetails
     */
    'isoStatus'?: PaymentIsoStatus;
}


/**
 * __Mandatory__. Used to specify which of the [payment types](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#payment-types) to execute.<br><br>See [European Payments](https://docs.yapily.com/pages/knowledge/open-banking/european_payments/) to verify whether the `type` should be `DOMESTIC` or `INTERNATIONAL`.
 * @export
 * @enum {string}
 */

export const PaymentType = {
    DomesticPayment: 'DOMESTIC_PAYMENT',
    DomesticInstantPayment: 'DOMESTIC_INSTANT_PAYMENT',
    DomesticVariableRecurringPayment: 'DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    DomesticScheduledPayment: 'DOMESTIC_SCHEDULED_PAYMENT',
    DomesticPeriodicPayment: 'DOMESTIC_PERIODIC_PAYMENT',
    InternationalPayment: 'INTERNATIONAL_PAYMENT',
    InternationalScheduledPayment: 'INTERNATIONAL_SCHEDULED_PAYMENT',
    InternationalPeriodicPayment: 'INTERNATIONAL_PERIODIC_PAYMENT',
    BulkPayment: 'BULK_PAYMENT'
} as const;

export type PaymentType = typeof PaymentType[keyof typeof PaymentType];


/**
 * Payment type associated with constraints.
 * @export
 * @enum {string}
 */

export const PaymentTypeOfConstraints = {
    DomesticPayment: 'DOMESTIC_PAYMENT',
    DomesticInstantPayment: 'DOMESTIC_INSTANT_PAYMENT',
    DomesticVariableRecurringPayment: 'DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    DomesticScheduledPayment: 'DOMESTIC_SCHEDULED_PAYMENT',
    DomesticPeriodicPayment: 'DOMESTIC_PERIODIC_PAYMENT',
    InternationalPayment: 'INTERNATIONAL_PAYMENT',
    InternationalScheduledPayment: 'INTERNATIONAL_SCHEDULED_PAYMENT',
    InternationalPeriodicPayment: 'INTERNATIONAL_PERIODIC_PAYMENT',
    BulkPayment: 'BULK_PAYMENT'
} as const;

export type PaymentTypeOfConstraints = typeof PaymentTypeOfConstraints[keyof typeof PaymentTypeOfConstraints];


/**
 * Specifies which of the [payment types](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/intro-to-payment-execution/#payment-types) to execute.<br>
 * @export
 * @enum {string}
 */

export const PaymentTypeResponse = {
    DomesticPayment: 'DOMESTIC_PAYMENT',
    DomesticInstantPayment: 'DOMESTIC_INSTANT_PAYMENT',
    DomesticVariableRecurringPayment: 'DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    DomesticScheduledPayment: 'DOMESTIC_SCHEDULED_PAYMENT',
    DomesticPeriodicPayment: 'DOMESTIC_PERIODIC_PAYMENT',
    InternationalPayment: 'INTERNATIONAL_PAYMENT',
    InternationalScheduledPayment: 'INTERNATIONAL_SCHEDULED_PAYMENT',
    InternationalPeriodicPayment: 'INTERNATIONAL_PERIODIC_PAYMENT',
    BulkPayment: 'BULK_PAYMENT'
} as const;

export type PaymentTypeResponse = typeof PaymentTypeResponse[keyof typeof PaymentTypeResponse];


/**
 * __Conditional__. Used to specify properties to define a periodic payment. <br><br>Must be specified when the payment `type` is one of the following:<ul>     <li><code>DOMESTIC_PERIODIC_PAYMENT</code></li>     <li><code>INTERNATIONAL_PERIODIC_PAYMENT</code></li></ul>
 * @export
 * @interface PeriodicPaymentRequest
 */
export interface PeriodicPaymentRequest {
    /**
     * 
     * @type {FrequencyRequest}
     * @memberof PeriodicPaymentRequest
     */
    'frequency': FrequencyRequest;
    /**
     * __Conditional__. Defines the total number of payments to be made.<br><br>This is required if `finalPaymentDateTime` is not specified and it is intended for the periodic payment have a fixed amount of payments.
     * @type {number}
     * @memberof PeriodicPaymentRequest
     */
    'numberOfPayments'?: number;
    /**
     * __Conditional__. Defines when to start the recurring payment date and time. Specify this if you want the first payment to start on a different day than what the frequency object defines.
     * @type {string}
     * @memberof PeriodicPaymentRequest
     */
    'nextPaymentDateTime'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PeriodicPaymentRequest
     */
    'nextPaymentAmount'?: Amount;
    /**
     * __Conditional__. Defines the final payment date and time. To create an open-ended periodic payment, do not specify this property.
     * @type {string}
     * @memberof PeriodicPaymentRequest
     */
    'finalPaymentDateTime'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof PeriodicPaymentRequest
     */
    'finalPaymentAmount'?: Amount;
}
/**
 * 
 * @export
 * @interface PreAuthorisationRequest
 */
export interface PreAuthorisationRequest {
    /**
     * 
     * @type {string}
     * @memberof PreAuthorisationRequest
     */
    'userUuid'?: string;
    /**
     * __Conditional__. The user-friendly reference to the `User` that will authorise the authorisation request. If a `User` with the specified `applicationUserId` exists, it will be used otherwise, a new `User` with the specified `applicationUserId` will be created and used. Either the `userUuid` or `applicationUserId` must be provided.
     * @type {string}
     * @memberof PreAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters to be forwarded in the redirect back to the client after the user authorisation flow has been completed.
     * @type {Array<string>}
     * @memberof PreAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof PreAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof PreAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof PreAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/pages/knowledge/yapily-concepts/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof PreAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * __Mandatory__. Defines the scope of the pre-authorisation request.
     * @type {string}
     * @memberof PreAuthorisationRequest
     */
    'scope': string;
}
/**
 * 
 * @export
 * @interface PreAuthorisationResponse
 */
export interface PreAuthorisationResponse {
    /**
     * Unique identifier for the pre-authorisation request.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'id'?: string;
    /**
     * The `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'userUuid'?: string;
    /**
     * The user-friendly reference to the `User` that the authorisation request was created for.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'applicationUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'referenceId'?: string;
    /**
     * The `Institution` the authorisation request was sent to.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof PreAuthorisationResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * Date and time the consent was created.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'createdAt'?: string;
    /**
     * When performing a transaction query using the consent, this is the earliest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'transactionFrom'?: string;
    /**
     * When performing a transaction query using the consent, this is the latest date of transaction records that can be retrieved.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'transactionTo'?: string;
    /**
     * Date and time the authorisation expires. Re-authorisation is needed to retain access.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PreAuthorisationResponse
     * @deprecated
     */
    'timeToExpireInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'timeToExpire'?: string;
    /**
     * The set of features the consent provides access to.
     * @type {Set<FeatureEnum>}
     * @memberof PreAuthorisationResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * Represents the authorisation to gain access to the requested features. Required to access account information or make a payment request.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'consentToken'?: string;
    /**
     * Corellation ID used with the `Institution` during the authorisation process.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'state'?: string;
    /**
     * Date and time the request was authorised by the `Institution`.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'authorizedAt'?: string;
    /**
     * Unique identifier of the consent assigned by the `Institution`.
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'authorisationUrl'?: string;
    /**
     * The URL link for the QR code that may be scanned via a mobile device to make a authorisation redirect to the bank (authURL encoded).
     * @type {string}
     * @memberof PreAuthorisationResponse
     */
    'qrCodeUrl'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PriorityCodeEnum = {
    Normal: 'NORMAL',
    Urgent: 'URGENT'
} as const;

export type PriorityCodeEnum = typeof PriorityCodeEnum[keyof typeof PriorityCodeEnum];


/**
 * Details of a consent linked to a `User Profile`.
 * @export
 * @interface ProfileConsent
 */
export interface ProfileConsent {
    /**
     * Unique identifier of the `consent` in context of a user\'s profile.
     * @type {string}
     * @memberof ProfileConsent
     */
    'id'?: string;
    /**
     * The status, can be PENDING, COMPLETED or ERROR.
     * @type {string}
     * @memberof ProfileConsent
     */
    'status'?: string;
    /**
     * The userUuid.
     * @type {string}
     * @memberof ProfileConsent
     */
    'userId'?: string;
    /**
     * Unique identifier of the consent.
     * @type {string}
     * @memberof ProfileConsent
     */
    'referenceConsentId'?: string;
    /**
     * __Mandatory__. The  `Institution` the authorisation request is sent to.
     * @type {string}
     * @memberof ProfileConsent
     */
    'institutionId'?: string;
    /**
     * When a profile consent is created.
     * @type {string}
     * @memberof ProfileConsent
     */
    'createdAt'?: string;
    /**
     * When a profile consent is expired after created + X.
     * @type {string}
     * @memberof ProfileConsent
     */
    'expiresAt'?: string;
    /**
     * After data retrieval from aggregated profile consent is completed.
     * @type {string}
     * @memberof ProfileConsent
     */
    'dataInsertedAt'?: string;
}
/**
 * Transaction code that is proprietary to the `Institution`.
 * @export
 * @interface ProprietaryBankTransactionCode
 */
export interface ProprietaryBankTransactionCode {
    /**
     * __Mandatory__. Properietary code used to identify the underlying transaction.
     * @type {string}
     * @memberof ProprietaryBankTransactionCode
     */
    'code'?: string;
    /**
     * __Mandatory__. Issuer of the properitary code.
     * @type {string}
     * @memberof ProprietaryBankTransactionCode
     */
    'issuer'?: string;
}
/**
 * __Mandatory__. The type used to complete the currency exchange.
 * @export
 * @enum {string}
 */

export const RateTypeEnum = {
    Actual: 'ACTUAL',
    Agreed: 'AGREED',
    Indicative: 'INDICATIVE'
} as const;

export type RateTypeEnum = typeof RateTypeEnum[keyof typeof RateTypeEnum];


/**
 * 
 * @export
 * @interface RawRequest
 */
export interface RawRequest {
    /**
     * 
     * @type {string}
     * @memberof RawRequest
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawRequest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawRequest
     */
    'requestInstant'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RawRequest
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof RawRequest
     */
    'body'?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RawRequest
     */
    'bodyParameters'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RawRequest
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof RawRequest
     * @deprecated
     */
    'startedAt'?: string;
}
/**
 * Interaction (raw request and response) that occured with the `Institution` in order to fulfil a request.
 * @export
 * @interface RawResponse
 */
export interface RawResponse {
    /**
     * 
     * @type {RawRequest}
     * @memberof RawResponse
     */
    'request'?: RawRequest;
    /**
     * 
     * @type {string}
     * @memberof RawResponse
     */
    'duration'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RawResponse
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof RawResponse
     */
    'resultCode'?: number;
    /**
     * 
     * @type {object}
     * @memberof RawResponse
     */
    'result'?: object;
}
/**
 * 
 * @export
 * @interface RealTimeTransaction
 */
export interface RealTimeTransaction {
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'bookingDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'valueDateTime'?: string;
    /**
     * 
     * @type {TransactionStatusEnum}
     * @memberof RealTimeTransaction
     */
    'status'?: TransactionStatusEnum;
    /**
     * 
     * @type {Amount}
     * @memberof RealTimeTransaction
     */
    'transactionAmount'?: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof RealTimeTransaction
     */
    'grossAmount'?: Amount;
    /**
     * 
     * @type {CurrencyExchange}
     * @memberof RealTimeTransaction
     */
    'currencyExchange'?: CurrencyExchange;
    /**
     * 
     * @type {TransactionChargeDetails}
     * @memberof RealTimeTransaction
     */
    'chargeDetails'?: TransactionChargeDetails;
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'reference'?: string;
    /**
     * 
     * @type {Array<StatementReference>}
     * @memberof RealTimeTransaction
     */
    'statementReferences'?: Array<StatementReference>;
    /**
     * 
     * @type {string}
     * @memberof RealTimeTransaction
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RealTimeTransaction
     */
    'transactionInformation'?: Array<string>;
    /**
     * 
     * @type {AddressDetails}
     * @memberof RealTimeTransaction
     */
    'addressDetails'?: AddressDetails;
    /**
     * 
     * @type {IsoBankTransactionCode}
     * @memberof RealTimeTransaction
     */
    'isoBankTransactionCode'?: IsoBankTransactionCode;
    /**
     * 
     * @type {ProprietaryBankTransactionCode}
     * @memberof RealTimeTransaction
     */
    'proprietaryBankTransactionCode'?: ProprietaryBankTransactionCode;
    /**
     * 
     * @type {TransactionBalance}
     * @memberof RealTimeTransaction
     */
    'balance'?: TransactionBalance;
    /**
     * 
     * @type {Payee}
     * @memberof RealTimeTransaction
     */
    'payeeDetails'?: Payee;
    /**
     * 
     * @type {Payer}
     * @memberof RealTimeTransaction
     */
    'payerDetails'?: Payer;
    /**
     * 
     * @type {Merchant}
     * @memberof RealTimeTransaction
     */
    'merchant'?: Merchant;
    /**
     * 
     * @type {object}
     * @memberof RealTimeTransaction
     */
    'supplementaryData'?: object;
}


/**
 * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`.
 * @export
 * @interface RedirectRequest
 */
export interface RedirectRequest {
    /**
     * __Mandatory__.Successful redirect after the user complete the authorisation at the `Institution`.
     * @type {string}
     * @memberof RedirectRequest
     */
    'url': string;
}
/**
 * The account to which funds should be returned if the payment is to be later refunded.
 * @export
 * @interface RefundAccount
 */
export interface RefundAccount {
    /**
     * 
     * @type {string}
     * @memberof RefundAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Set<AccountIdentification>}
     * @memberof RefundAccount
     */
    'accountIdentifications'?: Set<AccountIdentification>;
}
/**
 * Object defining the constraints rules applicable for a given requests.
 * @export
 * @interface RequestConstraints
 */
export interface RequestConstraints {
    /**
     * 
     * @type {Schema}
     * @memberof RequestConstraints
     */
    'headers'?: Schema;
    /**
     * 
     * @type {Schema}
     * @memberof RequestConstraints
     */
    'body': Schema;
}
/**
 * 
 * @export
 * @interface ResponseForwardedData
 */
export interface ResponseForwardedData {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ResponseForwardedData
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ResponseForwardedData
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ResponseListMeta
 */
export interface ResponseListMeta {
    /**
     * 
     * @type {string}
     * @memberof ResponseListMeta
     */
    'tracingId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseListMeta
     */
    'count'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof ResponseListMeta
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ResponseMeta
 */
export interface ResponseMeta {
    /**
     * 
     * @type {string}
     * @memberof ResponseMeta
     */
    'tracingId'?: string;
}
/**
 * 
 * @export
 * @interface ResponseMetaWithCount
 */
export interface ResponseMetaWithCount {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetaWithCount
     */
    'tracingId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseMetaWithCount
     */
    'count'?: number;
}
/**
 * __Conditional__. Used to update the authorisation with the sca method of the user\'s choice for the `Institution` that uses the embedded authorisation flow. If the user has multiple sca methods configured, the `Institution` will allow the user to select from each of these options. <br><br>When the user has multiple sca methods for the `Institution`, this is the second step required in the embedded authorisation flow to authorise the `Consent`.
 * @export
 * @interface ScaMethod
 */
export interface ScaMethod {
    /**
     * __Mandatory__. The id of the sca method provided by the `Institution`
     * @type {string}
     * @memberof ScaMethod
     */
    'id': string;
    /**
     * 
     * @type {Type}
     * @memberof ScaMethod
     */
    'type'?: Type;
    /**
     * __Optional__. A description of the sca method if provided by the `Institution`
     * @type {string}
     * @memberof ScaMethod
     */
    'description'?: string;
    /**
     * Additional information from the institution to provide to the PSU to help with the selected SCA method. The language is determined by the institution and may vary.
     * @type {string}
     * @memberof ScaMethod
     */
    'information'?: string;
    /**
     * Data from the institution to provide to the PSU to complete authorisation. The language is determined by the institution and may vary.
     * @type {Array<string>}
     * @memberof ScaMethod
     */
    'data'?: Array<string>;
}


/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'maximum'?: number;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'exclusiveMaximum'?: number;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'minimum'?: number;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'exclusiveMinimum'?: number;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'pattern'?: string;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'maxItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'minItems'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Schema
     */
    'uniqueItems'?: boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof Schema
     */
    'required'?: Set<string>;
    /**
     * 
     * @type {Array<any>}
     * @memberof Schema
     */
    'enum'?: Array<any>;
    /**
     * 
     * @type {SchemaType}
     * @memberof Schema
     */
    'type'?: SchemaType;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'contains'?: Schema;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'not'?: Schema;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'if'?: Schema;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'then'?: Schema;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'else'?: Schema;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof Schema
     */
    'allOf'?: Array<Schema>;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof Schema
     */
    'oneOf'?: Array<Schema>;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof Schema
     */
    'anyOf'?: Array<Schema>;
    /**
     * 
     * @type {Schema}
     * @memberof Schema
     */
    'items'?: Schema;
    /**
     * 
     * @type {{ [key: string]: Schema; }}
     * @memberof Schema
     */
    'properties'?: { [key: string]: Schema; };
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'format'?: string;
    /**
     * 
     * @type {any}
     * @memberof Schema
     */
    'default'?: any;
    /**
     * 
     * @type {any}
     * @memberof Schema
     */
    'example'?: any;
    /**
     * dependentRequired keyword is used to satisfy dependency between fields
     * @type {{ [key: string]: Set<string>; }}
     * @memberof Schema
     */
    'dependentRequired'?: { [key: string]: Set<string>; };
    /**
     * 
     * @type {{ [key: string]: Schema; }}
     * @memberof Schema
     */
    '$defs'?: { [key: string]: Schema; };
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    '$ref'?: string;
    /**
     * 
     * @type {SchemaXYapilyAnnotations}
     * @memberof Schema
     */
    'x-yapily-annotations'?: SchemaXYapilyAnnotations;
    /**
     * 
     * @type {SchemaXYapilyValidations}
     * @memberof Schema
     */
    'x-yapily-validations'?: SchemaXYapilyValidations;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SchemaType = {
    Array: 'array',
    Boolean: 'boolean',
    Integer: 'integer',
    Number: 'number',
    Object: 'object',
    String: 'string'
} as const;

export type SchemaType = typeof SchemaType[keyof typeof SchemaType];


/**
 * 
 * @export
 * @interface SchemaXYapilyAnnotations
 */
export interface SchemaXYapilyAnnotations {
    /**
     * 
     * @type {string}
     * @memberof SchemaXYapilyAnnotations
     */
    'lastUpdatedAt'?: string;
}
/**
 * 
 * @export
 * @interface SchemaXYapilyValidations
 */
export interface SchemaXYapilyValidations {
    /**
     * 
     * @type {string}
     * @memberof SchemaXYapilyValidations
     */
    'maxDurationFromNow'?: string;
}
/**
 * 
 * @export
 * @interface SearchApplicationsPublicFilterValuesParameter
 */
export interface SearchApplicationsPublicFilterValuesParameter {
    /**
     * Sub-application ids to filter the results for. If provided, the results will only include sub-applications with the given ids. Non-existent ids will be ignored.
     * @type {Array<string>}
     * @memberof SearchApplicationsPublicFilterValuesParameter
     */
    'applicationIds'?: Array<string>;
    /**
     * The number of results to skip.
     * @type {number}
     * @memberof SearchApplicationsPublicFilterValuesParameter
     */
    'offset'?: number;
    /**
     * The maximum number of results to return.
     * @type {number}
     * @memberof SearchApplicationsPublicFilterValuesParameter
     */
    'limit'?: number;
    /**
     * The field to sort the results by.<br><br>Possible values:<ul><li>`last_updated` (ascending)</li><li>`-last_updated` (descending)</li><li>`name` (ascending)</li><li>`-name` (descending)</li><li>`uuid` (ascending)</li><li>`-uuid` (descending)</li></ul>
     * @type {string}
     * @memberof SearchApplicationsPublicFilterValuesParameter
     */
    'sort'?: string;
}
/**
 * The attribute on which resources / records returned should be sorted. Valid options for the sort parameter.
 * @export
 * @enum {string}
 */

export const SortEnum = {
    Date: 'date',
    Date2: '-date'
} as const;

export type SortEnum = typeof SortEnum[keyof typeof SortEnum];


/**
 * Unique reference for a statement period. This may be optionally populated if available.
 * @export
 * @interface StatementReference
 */
export interface StatementReference {
    /**
     * 
     * @type {string}
     * @memberof StatementReference
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Subcategory
 */
export interface Subcategory {
    /**
     * 
     * @type {string}
     * @memberof Subcategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subcategory
     */
    'label'?: string;
}
/**
 * __Mandatory__. The payment submission object defining the details of the payment instruction to be executed under the Variable Recurring Payment.
 * @export
 * @interface SubmissionDetails
 */
export interface SubmissionDetails {
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof SubmissionDetails
     */
    'reference'?: string;
    /**
     * 
     * @type {Payee}
     * @memberof SubmissionDetails
     */
    'payee': Payee;
    /**
     * 
     * @type {Amount}
     * @memberof SubmissionDetails
     */
    'paymentAmount': Amount;
}
/**
 * __Mandatory__. The payment request object defining the details of the payment for execution under the Variable Recurring Payment consent.
 * @export
 * @interface SubmissionRequest
 */
export interface SubmissionRequest {
    /**
     * __Mandatory__. A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.
     * @type {string}
     * @memberof SubmissionRequest
     */
    'paymentIdempotencyId': string;
    /**
     * __Mandatory__. Chosen authentication method for submission step. Allowed values are [SCA_REQUIRED, SCA_NOT_REQUIRED].
     * @type {string}
     * @memberof SubmissionRequest
     */
    'psuAuthenticationMethod': string;
    /**
     * 
     * @type {PaymentContextType}
     * @memberof SubmissionRequest
     */
    'contextType'?: PaymentContextType;
    /**
     * 
     * @type {Amount}
     * @memberof SubmissionRequest
     */
    'paymentAmount': Amount;
}


/**
 * 
 * @export
 * @interface SubmissionResponse
 */
export interface SubmissionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'paymentIdempotencyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'paymentLifecycleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof SubmissionResponse
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {PaymentStatusDetails}
     * @memberof SubmissionResponse
     */
    'statusDetails'?: PaymentStatusDetails;
    /**
     * 
     * @type {InitiationDetails}
     * @memberof SubmissionResponse
     */
    'initiationDetails': InitiationDetails;
    /**
     * 
     * @type {SubmissionDetails}
     * @memberof SubmissionResponse
     */
    'submissionDetails': SubmissionDetails;
    /**
     * 
     * @type {Payer}
     * @memberof SubmissionResponse
     */
    'payer'?: Payer;
    /**
     * 
     * @type {RefundAccount}
     * @memberof SubmissionResponse
     */
    'refundAccount'?: RefundAccount;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'expectedExecutionTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'expectedSettlementTime'?: string;
}


/**
 * 
 * @export
 * @interface SweepingAuthorisationRequest
 */
export interface SweepingAuthorisationRequest {
    /**
     * This is the Yapily user identifier for the user returned by the create user step POST ../users
     * @type {string}
     * @memberof SweepingAuthorisationRequest
     */
    'userId'?: string;
    /**
     * A client\'s own user reference. If the client wants to work with their own unique references for individual PSUs then they can use the applicationUserId property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied applicationUserId, then a new Yapily userId is created automatically and linked to the applicationUserId value.  Clients can then use either their own applicationUserId or the Yapily userId to reference the same user in future calls.
     * @type {string}
     * @memberof SweepingAuthorisationRequest
     */
    'applicationUserId'?: string;
    /**
     * Extra parameters the TPP may want to get forwarded in the callback request after the PSU redirect.
     * @type {Array<string>}
     * @memberof SweepingAuthorisationRequest
     */
    'forwardParameters'?: Array<string>;
    /**
     * 
     * @type {PaymentContextType}
     * @memberof SweepingAuthorisationRequest
     */
    'contextType'?: PaymentContextType;
    /**
     * __Mandatory__. The reference to the `Institution` which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof SweepingAuthorisationRequest
     */
    'institutionId': string;
    /**
     * __Optional__. The server to redirect the user to after the user complete the authorisation at the `Institution`. <br><br>See [Using a callback (Optional)](https://docs.yapily.com/knowledge/callback_url/#using-a-callback-optional) for more information.
     * @type {string}
     * @memberof SweepingAuthorisationRequest
     */
    'callback'?: string;
    /**
     * 
     * @type {RedirectRequest}
     * @memberof SweepingAuthorisationRequest
     */
    'redirect'?: RedirectRequest;
    /**
     * __Conditional__. Used to receive a `oneTimeToken` rather than a `consentToken` at the `callback` for additional security. This can only be used when the `callback` is set. <br><br>See [Using a callback with an OTT (Optional)](https://docs.yapily.com/knowledge/callback_url/#using-a-callback-with-an-ott-optional) for more information.
     * @type {boolean}
     * @memberof SweepingAuthorisationRequest
     */
    'oneTimeToken'?: boolean;
    /**
     * 
     * @type {SweepingControlParameters}
     * @memberof SweepingAuthorisationRequest
     */
    'controlParameters': SweepingControlParameters;
    /**
     * 
     * @type {InitiationDetails}
     * @memberof SweepingAuthorisationRequest
     */
    'initiationDetails': InitiationDetails;
    /**
     * 
     * @type {ComplianceData}
     * @memberof SweepingAuthorisationRequest
     */
    'complianceData'?: ComplianceData;
}


/**
 * 
 * @export
 * @interface SweepingAuthorisationResponse
 */
export interface SweepingAuthorisationResponse {
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'id'?: string;
    /**
     * This is the Yapily user identifier for the user returned by the create user step POST ../users
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'userId'?: string;
    /**
     * A client\'s own user reference. If the client wants to work with their own unique references for individual PSUs then they can use the applicationUserId property to provide that value. Where Yapily does not already have a Yapily userId that matches the supplied applicationUserId, then a new Yapily userId is created automatically and linked to the applicationUserId value.  Clients can then use either their own applicationUserId or the Yapily userId to reference the same user in future calls.
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'applicationUserId'?: string;
    /**
     * The reference to the Institution which identifies which institution the authorisation request is sent to.
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'institutionId'?: string;
    /**
     * 
     * @type {AuthorisationStatus}
     * @memberof SweepingAuthorisationResponse
     */
    'status'?: AuthorisationStatus;
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'createdAt'?: string;
    /**
     * __Optional__. Used to granularly specify the set of features that the user will give their consent for when requesting access to their account information. Depending on the `Institution`, this may also populate a consent screen which list these scopes before the user authorises.<br><br>This endpoint accepts allow all [Financial Data Features](/guides/financial-data/features/#feature-list) that the `Institution` supports.To find out which scopes an `Institution` supports, check [GET Institution](./#get-institution).
     * @type {Set<FeatureEnum>}
     * @memberof SweepingAuthorisationResponse
     */
    'featureScope'?: Set<FeatureEnum>;
    /**
     * The `consent-token` containing the user\'s authorisation to make the payment request.
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'consentToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'authorizedAt'?: string;
    /**
     * Identification of the consent at the Institution.
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'institutionConsentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'authorisationUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SweepingAuthorisationResponse
     */
    'qrCodeUrl'?: string;
    /**
     * 
     * @type {SweepingControlParameters}
     * @memberof SweepingAuthorisationResponse
     */
    'controlParameters'?: SweepingControlParameters;
    /**
     * 
     * @type {Payer}
     * @memberof SweepingAuthorisationResponse
     */
    'payer'?: Payer;
    /**
     * 
     * @type {InitiationDetails}
     * @memberof SweepingAuthorisationResponse
     */
    'initiationDetails'?: InitiationDetails;
}


/**
 * Define the restrictions and limits for payment orders as part of Sweeping VRP consent
 * @export
 * @interface SweepingControlParameters
 */
export interface SweepingControlParameters {
    /**
     * __Mandatory__. Defines the authentication method(s) allowed in payment submission step. Allowed values are [SCA_REQUIRED, SCA_NOT_REQUIRED].
     * @type {Array<string>}
     * @memberof SweepingControlParameters
     */
    'psuAuthenticationMethods': Array<string>;
    /**
     * 
     * @type {Array<SweepingPeriodicLimits>}
     * @memberof SweepingControlParameters
     */
    'periodicLimits': Array<SweepingPeriodicLimits>;
    /**
     * __Mandatory__. Max amount that can be submitted per payment.
     * @type {Amount}
     * @memberof SweepingControlParameters
     */
    'maxAmountPerPayment': Amount;
    /**
     * __Optional__. Start date when the consent becomes valid.
     * @type {string}
     * @memberof SweepingControlParameters
     */
    'validFrom'?: string;
    /**
     * __Optional__. End date when the consent expires and becomes invalid.
     * @type {string}
     * @memberof SweepingControlParameters
     */
    'validTo'?: string;
}
/**
 * 
 * @export
 * @interface SweepingPeriodicLimits
 */
export interface SweepingPeriodicLimits {
    /**
     * __Mandatory__. Maximum amount that can be specified in all payment instructions in a given period under this VRP consent. If the Alignment is Calendar, the limit is pro-rated in the first period to the remaining number of days.
     * @type {Amount}
     * @memberof SweepingPeriodicLimits
     */
    'totalMaxAmount': Amount;
    /**
     * __Mandatory__. Frequency for which the payment limits are enforced. Allowed values are [DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, YEARLY].
     * @type {string}
     * @memberof SweepingPeriodicLimits
     */
    'frequency': string;
    /**
     * __Mandatory__. Period alignment for which the payment limits are enforced. Allowed values are [CONSENT, CALENDAR]. If CONSENT, then period starts on consent creation date. If CALENDAR, then period lines up with the frequency e.g. WEEKLY period will begin at start of the week in question.
     * @type {string}
     * @memberof SweepingPeriodicLimits
     */
    'alignment': string;
}
/**
 * Terminated transaction stream generated as part of the financial profile for a User.
 * @export
 * @interface TerminatedTransactionStream
 */
export interface TerminatedTransactionStream {
    /**
     * The name of the TransactionStream
     * @type {string}
     * @memberof TerminatedTransactionStream
     */
    'name'?: string;
    /**
     * A list of Transactions from the transaction stream.
     * @type {Array<EnrichedTransaction>}
     * @memberof TerminatedTransactionStream
     */
    'transactions'?: Array<EnrichedTransaction>;
    /**
     * 
     * @type {TransactionSchedule}
     * @memberof TerminatedTransactionStream
     */
    'transactionSchedule'?: TransactionSchedule;
    /**
     * The consistency of the transaction.  This is a number between 0 and 1 with 1 being the most consistent schedule.
     * @type {number}
     * @memberof TerminatedTransactionStream
     */
    'scheduleConsistencyScore'?: number;
    /**
     * When is the transaction expected to occur next.
     * @type {string}
     * @memberof TerminatedTransactionStream
     */
    'nextExpectedTransactionDate'?: string;
    /**
     * When is the first recorded transaction date
     * @type {string}
     * @memberof TerminatedTransactionStream
     */
    'earliestTransactionDate'?: string;
    /**
     * When is the most recent transaction date
     * @type {string}
     * @memberof TerminatedTransactionStream
     */
    'mostRecentTransactionDate'?: string;
    /**
     * The consistency of the amount of the transaction.  This is a number between 0 and 1 with 1 being the most consistent amount.
     * @type {number}
     * @memberof TerminatedTransactionStream
     */
    'amountConsistencyScore'?: number;
    /**
     * The average amount of the transaction stream
     * @type {number}
     * @memberof TerminatedTransactionStream
     */
    'averageAmount'?: number;
    /**
     * Missed transactions of transaction stream
     * @type {number}
     * @memberof TerminatedTransactionStream
     */
    'missedTransactions'?: number;
}
/**
 * Details of a transaction (credit or debit) that has occurred on the account.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Unique identifier of the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'date'?: string;
    /**
     * Date and time of when a transaction was booked.
     * @type {string}
     * @memberof Transaction
     */
    'bookingDateTime'?: string;
    /**
     * Date and time when the funds either cease to be available (for debit transactions) or become available (for credit transactions) to the account owner.
     * @type {string}
     * @memberof Transaction
     */
    'valueDateTime'?: string;
    /**
     * 
     * @type {TransactionStatusEnum}
     * @memberof Transaction
     */
    'status'?: TransactionStatusEnum;
    /**
     * The transaction amount.
     * @type {number}
     * @memberof Transaction
     */
    'amount'?: number;
    /**
     * Currency the transaction amount is denoted in. Specified as a 3-letter ISO 4217 code.
     * @type {string}
     * @memberof Transaction
     */
    'currency'?: string;
    /**
     * 
     * @type {Amount}
     * @memberof Transaction
     */
    'transactionAmount'?: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof Transaction
     */
    'grossAmount'?: Amount;
    /**
     * 
     * @type {CurrencyExchange}
     * @memberof Transaction
     */
    'currencyExchange'?: CurrencyExchange;
    /**
     * 
     * @type {TransactionChargeDetails}
     * @memberof Transaction
     */
    'chargeDetails'?: TransactionChargeDetails;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'reference'?: string;
    /**
     * 
     * @type {Array<StatementReference>}
     * @memberof Transaction
     */
    'statementReferences'?: Array<StatementReference>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'description'?: string;
    /**
     * Further details on the transaction. This is narrative data, caught as unstructured text.
     * @type {Array<string>}
     * @memberof Transaction
     */
    'transactionInformation'?: Array<string>;
    /**
     * 
     * @type {AddressDetails}
     * @memberof Transaction
     */
    'addressDetails'?: AddressDetails;
    /**
     * 
     * @type {IsoBankTransactionCode}
     * @memberof Transaction
     */
    'isoBankTransactionCode'?: IsoBankTransactionCode;
    /**
     * 
     * @type {ProprietaryBankTransactionCode}
     * @memberof Transaction
     */
    'proprietaryBankTransactionCode'?: ProprietaryBankTransactionCode;
    /**
     * 
     * @type {TransactionBalance}
     * @memberof Transaction
     */
    'balance'?: TransactionBalance;
    /**
     * 
     * @type {TransactionPayeeDetails}
     * @memberof Transaction
     */
    'payeeDetails'?: TransactionPayeeDetails;
    /**
     * 
     * @type {TransactionPayerDetails}
     * @memberof Transaction
     */
    'payerDetails'?: TransactionPayerDetails;
    /**
     * 
     * @type {Merchant}
     * @memberof Transaction
     */
    'merchant'?: Merchant;
    /**
     * 
     * @type {Enrichment}
     * @memberof Transaction
     */
    'enrichment'?: Enrichment;
    /**
     * Additional information that cannot be captured in a structured field or block.
     * @type {object}
     * @memberof Transaction
     */
    'supplementaryData'?: object;
    /**
     * __Optional__. Specifies the Mutability of the Transaction record.<ul><li>A transaction with a `Status` of `Pending` is mutable.</li><li>A transaction with a `Status` of `Booked` where the `TransactionMutability` flag is not specified is not guaranteed to be immutable (although in most instances it will be).</li><li>A transaction with a `Status` of `Booked` with the `TransactionMutability` flag set to `Immutable` is immutable.</li><li>A transaction with a `Status` of `Booked` with the `TransactionMutability` flag set to `Mutable` is mutable.</li></ul>
     * @type {string}
     * @memberof Transaction
     */
    'transactionMutability'?: string;
}


/**
 * 
 * @export
 * @interface TransactionBalance
 */
export interface TransactionBalance {
    /**
     * 
     * @type {AccountBalanceType}
     * @memberof TransactionBalance
     */
    'type'?: AccountBalanceType;
    /**
     * 
     * @type {Amount}
     * @memberof TransactionBalance
     */
    'balanceAmount'?: Amount;
}


/**
 * Details the charges that will apply to the transaction.
 * @export
 * @interface TransactionChargeDetails
 */
export interface TransactionChargeDetails {
    /**
     * 
     * @type {Amount}
     * @memberof TransactionChargeDetails
     */
    'chargeAmount'?: Amount;
}
/**
 * An unique identifier for the transaction that was generated by Yapily. This is a hash of transaction attributes and may be useful an id is not present (and therefore hasn\'t been provided by an Institution).
 * @export
 * @interface TransactionHash
 */
export interface TransactionHash {
    /**
     * 
     * @type {string}
     * @memberof TransactionHash
     */
    'hash'?: string;
}
/**
 * Details of the beneficiary [person or business].
 * @export
 * @interface TransactionPayeeDetails
 */
export interface TransactionPayeeDetails {
    /**
     * The account holder name of the Payee.
     * @type {string}
     * @memberof TransactionPayeeDetails
     */
    'name'?: string;
    /**
     * The account identifications that identify the Payee\'s bank account.
     * @type {Array<TransactionPayeeDetailsAccountIdentificationsInner>}
     * @memberof TransactionPayeeDetails
     */
    'accountIdentifications'?: Array<TransactionPayeeDetailsAccountIdentificationsInner>;
}
/**
 * 
 * @export
 * @interface TransactionPayeeDetailsAccountIdentificationsInner
 */
export interface TransactionPayeeDetailsAccountIdentificationsInner {
    /**
     * Describes the format of the account.
     * @type {AccountIdentificationType}
     * @memberof TransactionPayeeDetailsAccountIdentificationsInner
     */
    'type'?: AccountIdentificationType;
    /**
     * The value associated with the account identification type.
     * @type {string}
     * @memberof TransactionPayeeDetailsAccountIdentificationsInner
     */
    'identification'?: string;
}


/**
 * Details of the benefactor [person or business].
 * @export
 * @interface TransactionPayerDetails
 */
export interface TransactionPayerDetails {
    /**
     * The account holder name of the Payer.
     * @type {string}
     * @memberof TransactionPayerDetails
     */
    'name'?: string;
    /**
     * The account identifications that identify the Payer\'s bank account.
     * @type {Array<TransactionPayeeDetailsAccountIdentificationsInner>}
     * @memberof TransactionPayerDetails
     */
    'accountIdentifications'?: Array<TransactionPayeeDetailsAccountIdentificationsInner>;
}
/**
 * The frequency at which transactions occurred.
 * @export
 * @interface TransactionSchedule
 */
export interface TransactionSchedule {
    /**
     * How often the transaction happens.  Can be \'Monthly\', \'Twice monthly\', \'Every two weeks\', \'Every four weeks\', \'Daily\', \'Weekly\', \'Every weekday\', \'Twice daily\', \'Twice every weekday\'
     * @type {string}
     * @memberof TransactionSchedule
     */
    'frequency'?: string;
    /**
     * When in the cycle the transaction occurs.  Can be \'Daily\', \'Twice daily\', \'Twice every weekday\', \'Every weekday\', \'Weekly on day n\', \'Every two weeks on day n\', \'Monthly on working day before day n of month\', \'Monthly on last working day of month\', \'Twice a month on 15th and last working day of month\', \'Every four weeks on day n\'
     * @type {string}
     * @memberof TransactionSchedule
     */
    'detailedFrequency'?: string;
    /**
     * The n in detailedFrequency where there is one - for week-based frequencies, an integer from 0 to 6 where 0 is Monday or for month-based frequencies, an integer from 0 to 27 where 0 is the first day of the month
     * @type {number}
     * @memberof TransactionSchedule
     */
    'detailedFrequencyParameter'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionStatusEnum = {
    Booked: 'BOOKED',
    Pending: 'PENDING'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];


/**
 * Lists all possible transaction streams identified for the `Application User`.
 * @export
 * @interface TransactionStream
 */
export interface TransactionStream {
    /**
     * The name of the Transaction Stream.
     * @type {string}
     * @memberof TransactionStream
     */
    'name'?: string;
    /**
     * A list of transaction details, identified by Yapily data services.
     * @type {Array<EnrichedTransaction>}
     * @memberof TransactionStream
     */
    'transactions'?: Array<EnrichedTransaction>;
    /**
     * 
     * @type {TransactionSchedule}
     * @memberof TransactionStream
     */
    'transactionSchedule'?: TransactionSchedule;
    /**
     * The consistency of the transaction.  This is a number between 0 and 1 with 1 being the most consistent schedule.
     * @type {number}
     * @memberof TransactionStream
     */
    'scheduleConsistencyScore'?: number;
    /**
     * When is the transaction expected to occur next.
     * @type {string}
     * @memberof TransactionStream
     */
    'nextExpectedTransactionDate'?: string;
    /**
     * When is the first recorded transaction date
     * @type {string}
     * @memberof TransactionStream
     */
    'earliestTransactionDate'?: string;
    /**
     * When is the most recent transaction date
     * @type {string}
     * @memberof TransactionStream
     */
    'mostRecentTransactionDate'?: string;
    /**
     * The consistency of the amount of the transaction.  This is a number between 0 and 1 with 1 being the most consistent amount.
     * @type {number}
     * @memberof TransactionStream
     */
    'amountConsistencyScore'?: number;
    /**
     * The average amount of the transaction stream
     * @type {number}
     * @memberof TransactionStream
     */
    'averageAmount'?: number;
}
/**
 * The `SCA` method type available for the user
 * @export
 * @enum {string}
 */

export const Type = {
    SmsOtp: 'SMS_OTP',
    ChipOtp: 'CHIP_OTP',
    PhotoOtp: 'PHOTO_OTP',
    PushOtp: 'PUSH_OTP'
} as const;

export type Type = typeof Type[keyof typeof Type];


/**
 * 
 * @export
 * @interface UpdateVirtualAccountRequest
 */
export interface UpdateVirtualAccountRequest {
    /**
     * New reference that can be provided in order to help with identification of the account
     * @type {string}
     * @memberof UpdateVirtualAccountRequest
     */
    'nickname'?: string;
    /**
     * New state of the Account: CLOSED - The account has been permanently closed and cannot be used
     * @type {string}
     * @memberof UpdateVirtualAccountRequest
     */
    'status'?: string;
}
/**
 * The customer segment of the account.
 * @export
 * @enum {string}
 */

export const UsageType = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Other: 'OTHER',
    Unknown: 'UNKNOWN'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * __Conditional__. Used to capture the user\'s credentials to allow them to login to an `Institution` that uses the embedded account authorisation flow. <br><br>This is the first step required in the embedded account authorisation flow to authorise the `Consent`.
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * __Mandatory__. The login id for the user for a particular `Institution`.
     * @type {string}
     * @memberof UserCredentials
     */
    'id': string;
    /**
     * __Conditional__. The corporate login for the user for a particular corporate `Institution`.
     * @type {string}
     * @memberof UserCredentials
     */
    'corporateId'?: string;
    /**
     * __Mandatory__. The password of the user to login to a particular `Institution`.
     * @type {string}
     * @memberof UserCredentials
     */
    'password': string;
}
/**
 * Deletion of the user. Includes the user profile and all associate consents.
 * @export
 * @interface UserDeleteResponse
 */
export interface UserDeleteResponse {
    /**
     * Unique identifier of the user.
     * @type {string}
     * @memberof UserDeleteResponse
     */
    'id'?: string;
    /**
     * 
     * @type {DeleteStatusEnum}
     * @memberof UserDeleteResponse
     */
    'deleteStatus'?: DeleteStatusEnum;
    /**
     * Date and time that the user was created.
     * @type {string}
     * @memberof UserDeleteResponse
     */
    'creationDate'?: string;
    /**
     * 
     * @type {Set<ConsentDeleteResponse>}
     * @memberof UserDeleteResponse
     */
    'userConsents'?: Set<ConsentDeleteResponse>;
}


/**
 * Specifies the language and location preferences of the user.
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    /**
     * 2 letter ISO Language code which denotes the language preference for the `User`.
     * @type {string}
     * @memberof UserSettings
     */
    'language'?: string;
    /**
     * 2 letter ISO Country code which denotes the location preference for the `User`.
     * @type {string}
     * @memberof UserSettings
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface VRPSetup
 */
export interface VRPSetup {
    /**
     * 
     * @type {HostedVrpPayerResponse}
     * @memberof VRPSetup
     */
    'payer'?: HostedVrpPayerResponse;
    /**
     * 
     * @type {Payee}
     * @memberof VRPSetup
     */
    'payee': Payee;
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof VRPSetup
     */
    'reference'?: string;
    /**
     * 
     * @type {HostedVRPLimits}
     * @memberof VRPSetup
     */
    'limits'?: HostedVRPLimits;
    /**
     * __Optional__. Start date when the consent becomes valid.
     * @type {string}
     * @memberof VRPSetup
     */
    'validFrom'?: string;
    /**
     * __Optional__. End date when the consent expires and becomes invalid.
     * @type {string}
     * @memberof VRPSetup
     */
    'validTo'?: string;
    /**
     * The use-case for the VRP consent supported by the bank. Allowed values: <br>`ONGOING` <br>`SUBSCRIPTION`
     * @type {string}
     * @memberof VRPSetup
     */
    'recurringPaymentCategory'?: string;
    /**
     * __Optional__. Initial payment to be charged under this consent. If enforced, this amount must match the first payment amount executed using this consent.
     * @type {Amount}
     * @memberof VRPSetup
     */
    'initialPayment'?: Amount;
    /**
     * 
     * @type {PaymentRisk}
     * @memberof VRPSetup
     */
    'risk'?: PaymentRisk;
}
/**
 * 
 * @export
 * @interface VRPSetupRequest
 */
export interface VRPSetupRequest {
    /**
     * 
     * @type {Payer}
     * @memberof VRPSetupRequest
     */
    'payer'?: Payer;
    /**
     * 
     * @type {Payee}
     * @memberof VRPSetupRequest
     */
    'payee': Payee;
    /**
     * __Optional__. The payment reference or description. Limited to a maximum of 18 characters long.
     * @type {string}
     * @memberof VRPSetupRequest
     */
    'reference'?: string;
    /**
     * 
     * @type {HostedVRPLimitsRequest}
     * @memberof VRPSetupRequest
     */
    'limits'?: HostedVRPLimitsRequest;
    /**
     * __Optional__. Start date when the consent becomes valid.
     * @type {string}
     * @memberof VRPSetupRequest
     */
    'validFrom'?: string;
    /**
     * __Optional__. End date when the consent expires and becomes invalid.
     * @type {string}
     * @memberof VRPSetupRequest
     */
    'validTo'?: string;
    /**
     * The use-case for the VRP consent supported by the bank. Allowed values: <br>`ONGOING` <br>`SUBSCRIPTION`
     * @type {string}
     * @memberof VRPSetupRequest
     */
    'recurringPaymentCategory'?: string;
    /**
     * __Optional__. Initial payment to be charged under this consent. If enforced, this amount must match the first payment amount executed using this consent.
     * @type {Amount}
     * @memberof VRPSetupRequest
     */
    'initialPayment'?: Amount;
    /**
     * 
     * @type {PaymentRisk}
     * @memberof VRPSetupRequest
     */
    'risk'?: PaymentRisk;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * name of the field with error
     * @type {string}
     * @memberof ValidationError
     */
    'fieldName': string;
    /**
     * 
     * @type {EnumError}
     * @memberof ValidationError
     */
    'error': EnumError;
}


/**
 * 
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof ValidationErrorResponse
     */
    'errors'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface VirtualAccount
 */
export interface VirtualAccount {
    /**
     * Unique id of the account
     * @type {string}
     * @memberof VirtualAccount
     */
    'id'?: string;
    /**
     * Date and time that the account was created
     * @type {string}
     * @memberof VirtualAccount
     */
    'createdDateTime'?: string;
    /**
     * The current state of the Account <br> PENDING - Creation of the account is in progress <br> ACTIVE - The account is active and in use <br> FAILED - An issue occured during account creation <br> SUSPENDED - The account has been temporarily suspended by the account provider. It cannot currently be used <br> CLOSED - The account has been permanently closed and cannot be used
     * @type {string}
     * @memberof VirtualAccount
     */
    'status'?: string;
    /**
     * Reference that can be provided in order to help with identification of the account
     * @type {string}
     * @memberof VirtualAccount
     */
    'nickname'?: string;
    /**
     * Three-letter ISO 4217 currency code
     * @type {string}
     * @memberof VirtualAccount
     */
    'currency'?: string;
    /**
     * 
     * @type {Array<VirtualAccountBalance>}
     * @memberof VirtualAccount
     */
    'balances'?: Array<VirtualAccountBalance>;
    /**
     * 
     * @type {VirtualAccountBankAccount}
     * @memberof VirtualAccount
     */
    'bankAccount'?: VirtualAccountBankAccount;
}
/**
 * 
 * @export
 * @interface VirtualAccountAddress
 */
export interface VirtualAccountAddress {
    /**
     * __Mandatory__. AddressLine1 of the sub-client
     * @type {string}
     * @memberof VirtualAccountAddress
     */
    'addressLine1': string;
    /**
     * __Optional__. AddressLine2 of the sub-client
     * @type {string}
     * @memberof VirtualAccountAddress
     */
    'addressLine2'?: string;
    /**
     * __Mandatory__. Town name of the sub-client
     * @type {string}
     * @memberof VirtualAccountAddress
     */
    'townName': string;
    /**
     * __Optional__. Address postcode of the sub-client
     * @type {string}
     * @memberof VirtualAccountAddress
     */
    'postCode'?: string;
    /**
     * __Optional__. Country of the sub-client
     * @type {string}
     * @memberof VirtualAccountAddress
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountBalance
 */
export interface VirtualAccountBalance {
    /**
     * 
     * @type {VirtualAccountBalanceType}
     * @memberof VirtualAccountBalance
     */
    'type'?: VirtualAccountBalanceType;
    /**
     * 
     * @type {Amount}
     * @memberof VirtualAccountBalance
     */
    'balanceAmount'?: Amount;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualAccountBalanceType = {
    Available: 'INTERIM_AVAILABLE',
    Booked: 'INTERIM_BOOKED'
} as const;

export type VirtualAccountBalanceType = typeof VirtualAccountBalanceType[keyof typeof VirtualAccountBalanceType];


/**
 * 
 * @export
 * @interface VirtualAccountBankAccount
 */
export interface VirtualAccountBankAccount {
    /**
     * Three-letter ISO 4217 currency code
     * @type {string}
     * @memberof VirtualAccountBankAccount
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBankAccount
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBankAccount
     */
    'bankAddress'?: string;
    /**
     * Two-letter ISO 3166 country code
     * @type {string}
     * @memberof VirtualAccountBankAccount
     */
    'bankCountry'?: string;
    /**
     * The account identifications that identify the Beneficiary bank account.
     * @type {Set<AccountIdentification>}
     * @memberof VirtualAccountBankAccount
     */
    'accountIdentifications'?: Set<AccountIdentification>;
    /**
     * Reference required for paying into the account. When no reference is provided, then one is not required to pay into the acount.
     * @type {string}
     * @memberof VirtualAccountBankAccount
     */
    'payInReference'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountBeneficiary
 */
export interface VirtualAccountBeneficiary {
    /**
     * Unique id of the Beneficiary
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'id'?: string;
    /**
     * Beneficiary payment schemes
     * @type {Array<string>}
     * @memberof VirtualAccountBeneficiary
     */
    'paymentSchemes'?: Array<string>;
    /**
     * Reference that can be provided in order to help with identification of the Beneficiary
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'nickname'?: string;
    /**
     * Indicates the type of Beneficiary as either a INDIVIDUAL or BUSINESS
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'birthDate'?: string;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAddress}
     * @memberof VirtualAccountBeneficiary
     */
    'address'?: VirtualAccountBeneficiaryAddress;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAccount}
     * @memberof VirtualAccountBeneficiary
     */
    'account'?: VirtualAccountBeneficiaryAccount;
    /**
     * The current status of the Beneficiary <br> PENDING - Beneficiary is awaiting verification <br> ACTIVE - Beneficiary can be used in a Pay Out <br> BLOCKED - Beneficiary cannot be used in a Pay Out
     * @type {string}
     * @memberof VirtualAccountBeneficiary
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountBeneficiaryAccount
 */
export interface VirtualAccountBeneficiaryAccount {
    /**
     * Three-letter ISO 4217 currency code
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAccount
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAccount
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAccount
     */
    'bankAddress'?: string;
    /**
     * Two-letter ISO 3166 country code
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAccount
     */
    'bankCountry'?: string;
    /**
     * The account identifications that identify the Beneficiary bank account.
     * @type {Set<AccountIdentification>}
     * @memberof VirtualAccountBeneficiaryAccount
     */
    'accountIdentifications': Set<AccountIdentification>;
}
/**
 * 
 * @export
 * @interface VirtualAccountBeneficiaryAddress
 */
export interface VirtualAccountBeneficiaryAddress {
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAddress
     */
    'addressLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAddress
     */
    'townName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAddress
     */
    'postCode'?: string;
    /**
     * Two-letter ISO 3166 country code
     * @type {string}
     * @memberof VirtualAccountBeneficiaryAddress
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountBeneficiaryRequest
 */
export interface VirtualAccountBeneficiaryRequest {
    /**
     * Reference that can be provided in order to help with identification of the Beneficiary
     * @type {string}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'nickname': string;
    /**
     * Indicates the type of Beneficiary as either an INDIVIDUAL or BUSINESS
     * @type {string}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'birthDate'?: string;
    /**
     * Beneficiary payment schemes
     * @type {Array<string>}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'paymentSchemes': Array<string>;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAddress}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'address': VirtualAccountBeneficiaryAddress;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAccount}
     * @memberof VirtualAccountBeneficiaryRequest
     */
    'account': VirtualAccountBeneficiaryAccount;
}
/**
 * 
 * @export
 * @interface VirtualAccountBusinessClient
 */
export interface VirtualAccountBusinessClient {
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBusinessClient
     */
    'name': string;
    /**
     * 
     * @type {VirtualAccountClientBusinessType}
     * @memberof VirtualAccountBusinessClient
     */
    'type': VirtualAccountClientBusinessType;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBusinessClient
     */
    'registrationNumber': string;
    /**
     * 
     * @type {VirtualAccountAddress}
     * @memberof VirtualAccountBusinessClient
     */
    'registeredAddress': VirtualAccountAddress;
    /**
     * 
     * @type {VirtualAccountAddress}
     * @memberof VirtualAccountBusinessClient
     */
    'tradingAddress'?: VirtualAccountAddress;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBusinessClient
     */
    'contactName': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBusinessClient
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountBusinessClient
     */
    'phone': string;
}


/**
 * 
 * @export
 * @interface VirtualAccountClient
 */
export interface VirtualAccountClient {
    /**
     * The id generated in the on-boarding process, it will be used as client-id for virtual accounts request
     * @type {string}
     * @memberof VirtualAccountClient
     */
    'id'?: string;
    /**
     * 
     * @type {VirtualAccountClientType}
     * @memberof VirtualAccountClient
     */
    'type'?: VirtualAccountClientType;
    /**
     * 
     * @type {VirtualAccountKycStatus}
     * @memberof VirtualAccountClient
     */
    'kycStatus'?: VirtualAccountKycStatus;
    /**
     * 
     * @type {VirtualAccountClientStatus}
     * @memberof VirtualAccountClient
     */
    'status'?: VirtualAccountClientStatus;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountClient
     */
    'createdDateTime'?: string;
    /**
     * 
     * @type {VirtualAccountIndividualClient}
     * @memberof VirtualAccountClient
     */
    'individual'?: VirtualAccountIndividualClient;
    /**
     * 
     * @type {VirtualAccountBusinessClient}
     * @memberof VirtualAccountClient
     */
    'business'?: VirtualAccountBusinessClient;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualAccountClientBusinessType = {
    SoleTrader: 'SOLE_TRADER',
    LimitedLiability: 'LIMITED_LIABILITY',
    Charity: 'CHARITY',
    PublicLimitedCompany: 'PUBLIC_LIMITED_COMPANY',
    OrdinaryPartnership: 'ORDINARY_PARTNERSHIP',
    LimitedPartnership: 'LIMITED_PARTNERSHIP'
} as const;

export type VirtualAccountClientBusinessType = typeof VirtualAccountClientBusinessType[keyof typeof VirtualAccountClientBusinessType];


/**
 * 
 * @export
 * @interface VirtualAccountClientRequest
 */
export interface VirtualAccountClientRequest {
    /**
     * 
     * @type {VirtualAccountClientType}
     * @memberof VirtualAccountClientRequest
     */
    'type': VirtualAccountClientType;
    /**
     * 
     * @type {VirtualAccountIndividualClient}
     * @memberof VirtualAccountClientRequest
     */
    'individual'?: VirtualAccountIndividualClient;
    /**
     * 
     * @type {VirtualAccountBusinessClient}
     * @memberof VirtualAccountClientRequest
     */
    'business'?: VirtualAccountBusinessClient;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualAccountClientStatus = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED'
} as const;

export type VirtualAccountClientStatus = typeof VirtualAccountClientStatus[keyof typeof VirtualAccountClientStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualAccountClientType = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS'
} as const;

export type VirtualAccountClientType = typeof VirtualAccountClientType[keyof typeof VirtualAccountClientType];


/**
 * 
 * @export
 * @interface VirtualAccountIndividualClient
 */
export interface VirtualAccountIndividualClient {
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'lastName': string;
    /**
     * 
     * @type {VirtualAccountAddress}
     * @memberof VirtualAccountIndividualClient
     */
    'address'?: VirtualAccountAddress;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'birthDate': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountIndividualClient
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VirtualAccountKycStatus = {
    Unverified: 'UNVERIFIED',
    Verified: 'VERIFIED'
} as const;

export type VirtualAccountKycStatus = typeof VirtualAccountKycStatus[keyof typeof VirtualAccountKycStatus];


/**
 * 
 * @export
 * @interface VirtualAccountOriginalPayment
 */
export interface VirtualAccountOriginalPayment {
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountOriginalPayment
     */
    'paymentInitiationId'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPayInDetails
 */
export interface VirtualAccountPayInDetails {
    /**
     * Unique id of the payment
     * @type {string}
     * @memberof VirtualAccountPayInDetails
     */
    'id'?: string;
    /**
     * Method of settlement to complete the payment. One of: <br> FASTER_PAYMENTS <br> SEPA_CREDIT <br> SEPA_INSTANT <br> SWIFT <br> SWIFT_EXPRESS <br> CHAPS <br> IAT <br> WIRE <br> TRANSFER
     * @type {string}
     * @memberof VirtualAccountPayInDetails
     */
    'paymentScheme'?: string;
    /**
     * 
     * @type {VirtualAccountPaymentAmount}
     * @memberof VirtualAccountPayInDetails
     */
    'amount'?: VirtualAccountPaymentAmount;
    /**
     * Reference associated with the payment and which appears on the beneficiary\'s bank statement
     * @type {string}
     * @memberof VirtualAccountPayInDetails
     */
    'reference'?: string;
    /**
     * 
     * @type {VirtualAccountPaymentSource}
     * @memberof VirtualAccountPayInDetails
     */
    'source'?: VirtualAccountPaymentSource;
    /**
     * Account source name
     * @type {string}
     * @memberof VirtualAccountPayInDetails
     */
    'name'?: string;
    /**
     * The address of the source bank account
     * @type {string}
     * @memberof VirtualAccountPayInDetails
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPayOutRequest
 */
export interface VirtualAccountPayOutRequest {
    /**
     * Unique id of the source / payer account
     * @type {string}
     * @memberof VirtualAccountPayOutRequest
     */
    'accountId': string;
    /**
     * 
     * @type {VirtualAccountPaymentAmount}
     * @memberof VirtualAccountPayOutRequest
     */
    'amount': VirtualAccountPaymentAmount;
    /**
     * Reference to be associated with the payment. This will be appear on the beneficiary\'s bank statement
     * @type {string}
     * @memberof VirtualAccountPayOutRequest
     */
    'reference': string;
    /**
     * Unique id of the beneficiary to whom the payment will be made
     * @type {string}
     * @memberof VirtualAccountPayOutRequest
     */
    'beneficiaryId': string;
    /**
     * Method of settlement to complete the payment. One of: <br> FASTER_PAYMENTS <br> SEPA_CREDIT <br> SEPA_INSTANT <br> SWIFT <br> SWIFT_EXPRESS <br> CHAPS <br> IAT <br> WIRE
     * @type {string}
     * @memberof VirtualAccountPayOutRequest
     */
    'paymentScheme': string;
    /**
     * Date on which a payment instruction will be executed, that must be in the future
     * @type {string}
     * @memberof VirtualAccountPayOutRequest
     */
    'paymentDate'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPayment
 */
export interface VirtualAccountPayment {
    /**
     * Unique id of the payment
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'id'?: string;
    /**
     * Date and time that the payment was created
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'createdDateTime'?: string;
    /**
     * Date on which the payment instruction will be executed, that may be in the future
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'paymentDate'?: string;
    /**
     * Type of payment. One of PAY_IN, PAY_OUT, RETURN_IN or RETURN_OUT
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'type'?: string;
    /**
     * Method of settlement to complete the payment. One of: <br> FASTER_PAYMENTS <br> SEPA_CREDIT <br> SEPA_INSTANT <br> SWIFT <br> SWIFT_EXPRESS <br> CHAPS <br> IAT <br> WIRE <br> TRANSFER
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'paymentScheme'?: string;
    /**
     * 
     * @type {VirtualAccountPaymentAmount}
     * @memberof VirtualAccountPayment
     */
    'amount'?: VirtualAccountPaymentAmount;
    /**
     * Reference to be associated with the payment. This will be appear on the beneficiary\'s bank statement
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'reference'?: string;
    /**
     * The current state of the transaction <br> INITIATED - The transaction request is acknowledged and will not undergo validation checks <br> PENDING - Initial checks were successful and the payment is pending processing. This is primarily used for future dated payments that have not yet reached their payment date <br> PROCESSING - Initial checks succeeded and the transaction request is now being processed <br> COMPLETED - The transaction has been successfully processed (terminal status) <br> FAILED - An failure occured during transaction processing (terminal status)
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'status'?: string;
    /**
     * 
     * @type {VirtualAccountPaymentSource}
     * @memberof VirtualAccountPayment
     */
    'source'?: VirtualAccountPaymentSource;
    /**
     * 
     * @type {VirtualAccountPaymentDestination}
     * @memberof VirtualAccountPayment
     */
    'destination'?: VirtualAccountPaymentDestination;
    /**
     * Unique id of the original payment that was refunded
     * @type {string}
     * @memberof VirtualAccountPayment
     */
    'originalPaymentId'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPaymentAmount
 */
export interface VirtualAccountPaymentAmount {
    /**
     * __Mandatory__. The monetary value
     * @type {number}
     * @memberof VirtualAccountPaymentAmount
     */
    'amount': number;
    /**
     * __Mandatory__. The [ISO 4217](https://www.xe.com/iso4217.php) currency code
     * @type {string}
     * @memberof VirtualAccountPaymentAmount
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPaymentDestination
 */
export interface VirtualAccountPaymentDestination {
    /**
     * Type of destination for a payment. One of ACCOUNT, EXTERNAL or BENEFICIARY
     * @type {string}
     * @memberof VirtualAccountPaymentDestination
     */
    'type': string;
    /**
     * Only present if type is ACCOUNT. Identifies the Virtual Account to which the payment was made
     * @type {string}
     * @memberof VirtualAccountPaymentDestination
     */
    'accountId'?: string;
    /**
     * Only present if type is EXTERNAL. The account identifications that identify an external destination
     * @type {Set<AccountIdentification>}
     * @memberof VirtualAccountPaymentDestination
     */
    'accountIdentifications'?: Set<AccountIdentification>;
    /**
     * Only present if type is BENEFICIARY. Unique id of the beneficiary
     * @type {string}
     * @memberof VirtualAccountPaymentDestination
     */
    'beneficiaryId'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountPaymentSource
 */
export interface VirtualAccountPaymentSource {
    /**
     * Type of source for a payment. One of ACCOUNT or EXTERNAL
     * @type {string}
     * @memberof VirtualAccountPaymentSource
     */
    'type': string;
    /**
     * Only present if type is ACCOUNT. Identifies the Virtual Account from which the payment was made
     * @type {string}
     * @memberof VirtualAccountPaymentSource
     */
    'accountId'?: string;
    /**
     * Only present if type is BENEFICIARY. Identifies the Virtual Account Beneficiary from which the payment was made
     * @type {string}
     * @memberof VirtualAccountPaymentSource
     */
    'beneficiaryId'?: string;
    /**
     * Only present if type is EXTERNAL. The account identifications that identify an external source
     * @type {Set<AccountIdentification>}
     * @memberof VirtualAccountPaymentSource
     */
    'accountIdentifications'?: Set<AccountIdentification>;
}
/**
 * 
 * @export
 * @interface VirtualAccountRefund
 */
export interface VirtualAccountRefund {
    /**
     * Unique id of the refund
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'id'?: string;
    /**
     * 
     * @type {VirtualAccountOriginalPayment}
     * @memberof VirtualAccountRefund
     */
    'originalPayment'?: VirtualAccountOriginalPayment;
    /**
     * The current state of the transaction <br> INITIATED - The transaction request is acknowledged and will not undergo validation checks <br> PENDING - Initial checks were successful and the payment is pending processing. This is primarily used for future dated payments that have not yet reached their payment date <br> PROCESSING - Initial checks succeeded and the transaction request is now being processed <br> COMPLETED - The transaction has been successfully processed (terminal status) <br> FAILED - An failure occured during transaction processing (terminal status)
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'status'?: string;
    /**
     * 
     * @type {VirtualAccountPaymentAmount}
     * @memberof VirtualAccountRefund
     */
    'amount'?: VirtualAccountPaymentAmount;
    /**
     * List of issues relating to a FAILED status
     * @type {Array<ErrorIssue>}
     * @memberof VirtualAccountRefund
     */
    'issues'?: Array<ErrorIssue>;
    /**
     * The reason of the refund request
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'reason'?: string;
    /**
     * Date on which the refund instruction will be executed, that may be in the future
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'paymentDate'?: string;
    /**
     * Reference to be associated with the refund. This will appear on the beneficiary\'s bank statement
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'reference'?: string;
    /**
     * Indicates which account will be used for refund.
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'refundTo'?: string;
    /**
     * Indicates if the refund is back to the original payer.
     * @type {boolean}
     * @memberof VirtualAccountRefund
     */
    'refundToOriginalPayer'?: boolean;
    /**
     * Indicates the type of Beneficiary as either an INDIVIDUAL or BUSINESS
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'beneficiaryType'?: string;
    /**
     * Unique id of the beneficiary to whom the payment will be made
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'beneficiaryId'?: string;
    /**
     * Date and time that the refund was created
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'createdDateTime'?: string;
    /**
     * Date and time that the refund was updated
     * @type {string}
     * @memberof VirtualAccountRefund
     */
    'updatedDateTime'?: string;
}
/**
 * 
 * @export
 * @interface VirtualAccountRefundRequest
 */
export interface VirtualAccountRefundRequest {
    /**
     * 
     * @type {VirtualAccountOriginalPayment}
     * @memberof VirtualAccountRefundRequest
     */
    'originalPayment': VirtualAccountOriginalPayment;
    /**
     * 
     * @type {VirtualAccountRefundRequestAmount}
     * @memberof VirtualAccountRefundRequest
     */
    'amount'?: VirtualAccountRefundRequestAmount;
    /**
     * Reason for the refund. Allowed values [REQUESTED_BY_CUSTOMER, DUPLICATE_PAYMENT, OTHER]
     * @type {string}
     * @memberof VirtualAccountRefundRequest
     */
    'reason'?: string;
    /**
     * The date that the refund instruction will be executed. Must be in the present or future
     * @type {string}
     * @memberof VirtualAccountRefundRequest
     */
    'paymentDate'?: string;
    /**
     * Reference to be associated with the refund. This will appear on the beneficiary\'s bank statement
     * @type {string}
     * @memberof VirtualAccountRefundRequest
     */
    'reference'?: string;
    /**
     * Indicates which account will be used for refund. Allowed value: SOURCE
     * @type {string}
     * @memberof VirtualAccountRefundRequest
     */
    'refundTo': string;
    /**
     * __Conditional__. This field is required when refundTo is BENEFICIARY. Indicates if the refund is back to the original payer. Allowed value: true
     * @type {boolean}
     * @memberof VirtualAccountRefundRequest
     */
    'refundToOriginalPayer'?: boolean;
    /**
     * __Conditional__. This field is required when refundTo is SOURCE. Indicates the type of Beneficiary as either an INDIVIDUAL or BUSINESS.
     * @type {string}
     * @memberof VirtualAccountRefundRequest
     */
    'beneficiaryType'?: string;
    /**
     * 
     * @type {VirtualAccountRefundRequestBeneficiary}
     * @memberof VirtualAccountRefundRequest
     */
    'beneficiary'?: VirtualAccountRefundRequestBeneficiary;
}
/**
 * 
 * @export
 * @interface VirtualAccountRefundRequestAmount
 */
export interface VirtualAccountRefundRequestAmount {
    /**
     * __Mandatory__. The monetary value
     * @type {number}
     * @memberof VirtualAccountRefundRequestAmount
     */
    'amount': number;
    /**
     * __Mandatory__. The [ISO 4217](https://www.xe.com/iso4217.php) currency code
     * @type {string}
     * @memberof VirtualAccountRefundRequestAmount
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountRefundRequestBeneficiary
 */
export interface VirtualAccountRefundRequestBeneficiary {
    /**
     * Reference that can be provided in order to help with identification of the Beneficiary
     * @type {string}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'nickname': string;
    /**
     * Indicates the type of Beneficiary as either an INDIVIDUAL or BUSINESS
     * @type {string}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'birthDate'?: string;
    /**
     * Beneficiary payment schemes
     * @type {Array<string>}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'paymentSchemes': Array<string>;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAddress}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'address': VirtualAccountBeneficiaryAddress;
    /**
     * 
     * @type {VirtualAccountBeneficiaryAccount}
     * @memberof VirtualAccountRefundRequestBeneficiary
     */
    'account': VirtualAccountBeneficiaryAccount;
}
/**
 * 
 * @export
 * @interface VirtualAccountRequest
 */
export interface VirtualAccountRequest {
    /**
     * Reference that can be provided in order to help with identification of the account
     * @type {string}
     * @memberof VirtualAccountRequest
     */
    'nickname': string;
    /**
     * Three-letter ISO 4217 currency code
     * @type {string}
     * @memberof VirtualAccountRequest
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountTransferDestination
 */
export interface VirtualAccountTransferDestination {
    /**
     * Identifies the Virtual Account to which the transfer was made
     * @type {string}
     * @memberof VirtualAccountTransferDestination
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface VirtualAccountTransferRequest
 */
export interface VirtualAccountTransferRequest {
    /**
     * 
     * @type {VirtualAccountPaymentAmount}
     * @memberof VirtualAccountTransferRequest
     */
    'amount': VirtualAccountPaymentAmount;
    /**
     * Reference to be associated with the transfer. This will be appear on the destination\'s bank statement
     * @type {string}
     * @memberof VirtualAccountTransferRequest
     */
    'reference': string;
    /**
     * 
     * @type {VirtualAccountTransferSource}
     * @memberof VirtualAccountTransferRequest
     */
    'source': VirtualAccountTransferSource;
    /**
     * 
     * @type {VirtualAccountTransferDestination}
     * @memberof VirtualAccountTransferRequest
     */
    'destination': VirtualAccountTransferDestination;
}
/**
 * 
 * @export
 * @interface VirtualAccountTransferSource
 */
export interface VirtualAccountTransferSource {
    /**
     * Identifies the Virtual Account from which the transfer was made
     * @type {string}
     * @memberof VirtualAccountTransferSource
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface VrpConfiguration
 */
export interface VrpConfiguration {
    /**
     * Maximum amount per transaction
     * @type {Amount}
     * @memberof VrpConfiguration
     */
    'maximumIndividualAmount'?: Amount;
    /**
     * Maximum cumulative amount
     * @type {Amount}
     * @memberof VrpConfiguration
     */
    'maximumCumulativeAmount'?: Amount;
    /**
     * Maximum cumulative number of payments
     * @type {number}
     * @memberof VrpConfiguration
     */
    'maximumCumulativeNumberOfPayments'?: number;
    /**
     * 
     * @type {Array<VrpPeriodicLimit>}
     * @memberof VrpConfiguration
     */
    'periodicLimits'?: Array<VrpPeriodicLimit>;
    /**
     * Payment Category with allowed values: ONGOING, SUBSCRIPTION
     * @type {string}
     * @memberof VrpConfiguration
     */
    'recurringPaymentCategory'?: string;
}
/**
 * 
 * @export
 * @interface VrpPeriodicLimit
 */
export interface VrpPeriodicLimit {
    /**
     * __Mandatory__. Maximum amount that can be specified in all payment instructions in a given period under this VRP consent. If the Alignment is Calendar, the limit is pro-rated in the first period to the remaining number of days.
     * @type {Amount}
     * @memberof VrpPeriodicLimit
     */
    'maximumAmount': Amount;
    /**
     * 
     * @type {FrequencyEnum}
     * @memberof VrpPeriodicLimit
     */
    'frequency': FrequencyEnum;
    /**
     * 
     * @type {AlignmentEnum}
     * @memberof VrpPeriodicLimit
     */
    'alignment': AlignmentEnum;
}



/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the information about the institutions configured in your application
         * @summary Get Application Self
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the information about the institutions configured in your application
         * @summary Get Application Self
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.getApplicationMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Get the information about the institutions configured in your application
         * @summary Get Application Self
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMe(options?: any): AxiosPromise<Application> {
            return localVarFp.getApplicationMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Get the information about the institutions configured in your application
     * @summary Get Application Self
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationMe(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).getApplicationMe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationManagementApi - axios parameter creator
 * @export
 */
export const ApplicationManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create application vrp configuration
         * @summary Create application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationVRPConfigurationByApplicationId: async (applicationId: string, vrpConfiguration: VrpConfiguration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationVRPConfigurationByApplicationId', 'applicationId', applicationId)
            // verify required parameter 'vrpConfiguration' is not null or undefined
            assertParamExists('createApplicationVRPConfigurationByApplicationId', 'vrpConfiguration', vrpConfiguration)
            const localVarPath = `/applications/{applicationId}/vrp`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vrpConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a sub-application under the given root application id provided in the authentication token. The sub-application can use the root\'s credentials to call the API
         * @summary Creates a sub-application for the root application id provided in the authentication token
         * @param {ApplicationRequest} applicationRequest The sub-application to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubApplication: async (applicationRequest: ApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('createSubApplication', 'applicationRequest', applicationRequest)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the application with the given ID in the path
         * @summary Delete an application
         * @param {string} applicationId The id of the application being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an application by the id provided in the path
         * @summary Get application details
         * @param {string} applicationId The id of the application being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationById: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationById', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application vrp configuration
         * @summary Get application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationVRPConfigurationByApplicationId: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationVRPConfigurationByApplicationId', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/vrp`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves sub-applications for the root application provided in the authentication token. If a sub-application is provided in the authentication token, it will return an empty list.
         * @summary Retrieve sub-applications for the root application provided in the authentication token.
         * @param {SearchApplicationsPublicFilterValuesParameter} [publicFilterValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApplications: async (publicFilterValues?: SearchApplicationsPublicFilterValuesParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (publicFilterValues !== undefined) {
                for (const [key, value] of Object.entries(publicFilterValues)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the application properties for the application with the given ID in the path
         * @summary Update an Application
         * @param {string} applicationId The id of the application being updated
         * @param {ApplicationRequest} applicationRequest The application to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (applicationId: string, applicationRequest: ApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplication', 'applicationId', applicationId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('updateApplication', 'applicationRequest', applicationRequest)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application vrp configuration
         * @summary Update application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationVRPConfigurationByApplicationId: async (applicationId: string, vrpConfiguration: VrpConfiguration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationVRPConfigurationByApplicationId', 'applicationId', applicationId)
            // verify required parameter 'vrpConfiguration' is not null or undefined
            assertParamExists('updateApplicationVRPConfigurationByApplicationId', 'vrpConfiguration', vrpConfiguration)
            const localVarPath = `/applications/{applicationId}/vrp`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vrpConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationManagementApi - functional programming interface
 * @export
 */
export const ApplicationManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Create application vrp configuration
         * @summary Create application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.createApplicationVRPConfigurationByApplicationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a sub-application under the given root application id provided in the authentication token. The sub-application can use the root\'s credentials to call the API
         * @summary Creates a sub-application for the root application id provided in the authentication token
         * @param {ApplicationRequest} applicationRequest The sub-application to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubApplication(applicationRequest: ApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubApplication(applicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.createSubApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the application with the given ID in the path
         * @summary Delete an application
         * @param {string} applicationId The id of the application being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.deleteApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves an application by the id provided in the path
         * @summary Get application details
         * @param {string} applicationId The id of the application being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationById(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationById(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.getApplicationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application vrp configuration
         * @summary Get application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationVRPConfigurationByApplicationId(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VrpConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationVRPConfigurationByApplicationId(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.getApplicationVRPConfigurationByApplicationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves sub-applications for the root application provided in the authentication token. If a sub-application is provided in the authentication token, it will return an empty list.
         * @summary Retrieve sub-applications for the root application provided in the authentication token.
         * @param {SearchApplicationsPublicFilterValuesParameter} [publicFilterValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchApplications(publicFilterValues?: SearchApplicationsPublicFilterValuesParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListOfApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchApplications(publicFilterValues, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.searchApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the application properties for the application with the given ID in the path
         * @summary Update an Application
         * @param {string} applicationId The id of the application being updated
         * @param {ApplicationRequest} applicationRequest The application to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(applicationId: string, applicationRequest: ApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(applicationId, applicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.updateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application vrp configuration
         * @summary Update application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationManagementApi.updateApplicationVRPConfigurationByApplicationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationManagementApi - factory interface
 * @export
 */
export const ApplicationManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationManagementApiFp(configuration)
    return {
        /**
         * Create application vrp configuration
         * @summary Create application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.createApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a sub-application under the given root application id provided in the authentication token. The sub-application can use the root\'s credentials to call the API
         * @summary Creates a sub-application for the root application id provided in the authentication token
         * @param {ApplicationRequest} applicationRequest The sub-application to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubApplication(applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApiResponseOfApplicationResponse> {
            return localVarFp.createSubApplication(applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the application with the given ID in the path
         * @summary Delete an application
         * @param {string} applicationId The id of the application being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves an application by the id provided in the path
         * @summary Get application details
         * @param {string} applicationId The id of the application being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationById(applicationId: string, options?: any): AxiosPromise<ApiResponseOfApplicationResponse> {
            return localVarFp.getApplicationById(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application vrp configuration
         * @summary Get application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationVRPConfigurationByApplicationId(applicationId: string, options?: any): AxiosPromise<VrpConfiguration> {
            return localVarFp.getApplicationVRPConfigurationByApplicationId(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves sub-applications for the root application provided in the authentication token. If a sub-application is provided in the authentication token, it will return an empty list.
         * @summary Retrieve sub-applications for the root application provided in the authentication token.
         * @param {SearchApplicationsPublicFilterValuesParameter} [publicFilterValues] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApplications(publicFilterValues?: SearchApplicationsPublicFilterValuesParameter, options?: any): AxiosPromise<ApiListOfApplicationResponse> {
            return localVarFp.searchApplications(publicFilterValues, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the application properties for the application with the given ID in the path
         * @summary Update an Application
         * @param {string} applicationId The id of the application being updated
         * @param {ApplicationRequest} applicationRequest The application to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(applicationId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApiResponseOfApplicationResponse> {
            return localVarFp.updateApplication(applicationId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application vrp configuration
         * @summary Update application VRP configuration by Application Id
         * @param {string} applicationId The id of the application that vrp configuration being created for
         * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.updateApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationManagementApi - object-oriented interface
 * @export
 * @class ApplicationManagementApi
 * @extends {BaseAPI}
 */
export class ApplicationManagementApi extends BaseAPI {
    /**
     * Create application vrp configuration
     * @summary Create application VRP configuration by Application Id
     * @param {string} applicationId The id of the application that vrp configuration being created for
     * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public createApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).createApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a sub-application under the given root application id provided in the authentication token. The sub-application can use the root\'s credentials to call the API
     * @summary Creates a sub-application for the root application id provided in the authentication token
     * @param {ApplicationRequest} applicationRequest The sub-application to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public createSubApplication(applicationRequest: ApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).createSubApplication(applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the application with the given ID in the path
     * @summary Delete an application
     * @param {string} applicationId The id of the application being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public deleteApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).deleteApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves an application by the id provided in the path
     * @summary Get application details
     * @param {string} applicationId The id of the application being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public getApplicationById(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).getApplicationById(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application vrp configuration
     * @summary Get application VRP configuration by Application Id
     * @param {string} applicationId The id of the application that vrp configuration being created for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public getApplicationVRPConfigurationByApplicationId(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).getApplicationVRPConfigurationByApplicationId(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves sub-applications for the root application provided in the authentication token. If a sub-application is provided in the authentication token, it will return an empty list.
     * @summary Retrieve sub-applications for the root application provided in the authentication token.
     * @param {SearchApplicationsPublicFilterValuesParameter} [publicFilterValues] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public searchApplications(publicFilterValues?: SearchApplicationsPublicFilterValuesParameter, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).searchApplications(publicFilterValues, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the application properties for the application with the given ID in the path
     * @summary Update an Application
     * @param {string} applicationId The id of the application being updated
     * @param {ApplicationRequest} applicationRequest The application to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public updateApplication(applicationId: string, applicationRequest: ApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).updateApplication(applicationId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application vrp configuration
     * @summary Update application VRP configuration by Application Id
     * @param {string} applicationId The id of the application that vrp configuration being created for
     * @param {VrpConfiguration} vrpConfiguration The vrp configuration to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationManagementApi
     */
    public updateApplicationVRPConfigurationByApplicationId(applicationId: string, vrpConfiguration: VrpConfiguration, options?: RawAxiosRequestConfig) {
        return ApplicationManagementApiFp(this.configuration).updateApplicationVRPConfigurationByApplicationId(applicationId, vrpConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthorisationsApi - axios parameter creator
 * @export
 */
export const AuthorisationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_BULK_PAYMENT`
         * @summary Create Bulk Payment Authorisation
         * @param {BulkPaymentAuthorisationRequest} bulkPaymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkPaymentAuthorisation: async (bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkPaymentAuthorisationRequest' is not null or undefined
            assertParamExists('createBulkPaymentAuthorisation', 'bulkPaymentAuthorisationRequest', bulkPaymentAuthorisationRequest)
            const localVarPath = `/bulk-payment-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkPaymentAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_BULK_PAYMENT` feature in order to obtain the the user\'s authorisation for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Create Embedded Bulk Payment Authorisation
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedBulkPaymentAuthorisation: async (bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkPaymentEmbeddedAuthorisationRequest' is not null or undefined
            assertParamExists('createEmbeddedBulkPaymentAuthorisation', 'bulkPaymentEmbeddedAuthorisationRequest', bulkPaymentEmbeddedAuthorisationRequest)
            const localVarPath = `/embedded-bulk-payment-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkPaymentEmbeddedAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT` feature in order to obtain the the user\'s authorisation for a payment.<br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Create Embedded Payment Authorisation
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedPaymentAuthorisation: async (paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentEmbeddedAuthorisationRequest' is not null or undefined
            assertParamExists('createEmbeddedPaymentAuthorisation', 'paymentEmbeddedAuthorisationRequest', paymentEmbeddedAuthorisationRequest)
            const localVarPath = `/embedded-payment-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentEmbeddedAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a payment. This endpoint is used to initiate all the different payment listed below. Based on the type of payment you wish to make, you may be required to provide specific properties in [PaymentRequest](https://docs.yapily.com/api/reference/#operation/createPaymentAuthorisation!path=paymentRequest&t=request). First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/reference/#operation/getInstitution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`INITIATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment Authorisation
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentAuthorisation: async (paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentAuthorisationRequest' is not null or undefined
            assertParamExists('createPaymentAuthorisation', 'paymentAuthorisationRequest', paymentAuthorisationRequest)
            const localVarPath = `/payment-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the pre-authorisation process for payments for CBI Globe institutions that contain the `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS` feature to authenticate the user. <br><br>Feature: `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS`
         * @summary Create Payment Pre-authorisation
         * @param {PaymentPreAuthorisationRequest} paymentPreAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentPreAuthorisationRequest: async (paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentPreAuthorisationRequest' is not null or undefined
            assertParamExists('createPaymentPreAuthorisationRequest', 'paymentPreAuthorisationRequest', paymentPreAuthorisationRequest)
            const localVarPath = `/payment-pre-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPreAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the pre-authorisation process for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature to authenticate the user. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Create Pre-authorisation
         * @param {PreAuthorisationRequest} preAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreAuthorisationRequest: async (preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'preAuthorisationRequest' is not null or undefined
            assertParamExists('createPreAuthorisationRequest', 'preAuthorisationRequest', preAuthorisationRequest)
            const localVarPath = `/pre-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial institution in order to give consent to access account data.<br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_ACCOUNT_REQUEST`
         * @summary Create Account Authorisation
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateAccountRequest: async (accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAuthorisationRequest' is not null or undefined
            assertParamExists('initiateAccountRequest', 'accountAuthorisationRequest', accountAuthorisationRequest)
            const localVarPath = `/account-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_ACCOUNT_REQUEST` feature in order to obtain the the user\'s authorisation to access their account information. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Create Embedded Account Authorisation
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateEmbeddedAccountRequest: async (embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'embeddedAccountAuthorisationRequest' is not null or undefined
            assertParamExists('initiateEmbeddedAccountRequest', 'embeddedAccountAuthorisationRequest', embeddedAccountAuthorisationRequest)
            const localVarPath = `/embedded-account-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddedAccountAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to prompt the account holder for continued access to their financial data. This endpoint should be used when a `Consent` that was previously `AUTHORIZED` can no longer be used to retrieve data.<br><br>See [Re-Authorisation](https://docs.yapily.com/pages/key-concepts/account-data/account-consents/#re-authorisation) for more information.
         * @summary Re-authorise Account Consent
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reAuthoriseAccount: async (consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('reAuthoriseAccount', 'consent', consent)
            const localVarPath = `/account-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to access the user\'s financial data. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Update Embedded Account Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedAccountRequest: async (consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('updateEmbeddedAccountRequest', 'consentId', consentId)
            // verify required parameter 'embeddedAccountAuthorisationRequest' is not null or undefined
            assertParamExists('updateEmbeddedAccountRequest', 'embeddedAccountAuthorisationRequest', embeddedAccountAuthorisationRequest)
            const localVarPath = `/embedded-account-auth-requests/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddedAccountAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Update Embedded Bulk Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedBulkPaymentAuthorisation: async (consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('updateEmbeddedBulkPaymentAuthorisation', 'consentId', consentId)
            // verify required parameter 'bulkPaymentEmbeddedAuthorisationRequest' is not null or undefined
            assertParamExists('updateEmbeddedBulkPaymentAuthorisation', 'bulkPaymentEmbeddedAuthorisationRequest', bulkPaymentEmbeddedAuthorisationRequest)
            const localVarPath = `/embedded-bulk-payment-auth-requests/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkPaymentEmbeddedAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a payment. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/embedded/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Update Embedded Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedPaymentAuthorisation: async (consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('updateEmbeddedPaymentAuthorisation', 'consentId', consentId)
            // verify required parameter 'paymentEmbeddedAuthorisationRequest' is not null or undefined
            assertParamExists('updateEmbeddedPaymentAuthorisation', 'paymentEmbeddedAuthorisationRequest', paymentEmbeddedAuthorisationRequest)
            const localVarPath = `/embedded-payment-auth-requests/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentEmbeddedAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to initiate a payment. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Update Payment Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentAuthorisation: async (consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('updatePaymentAuthorisation', 'consent', consent)
            // verify required parameter 'paymentAuthorisationRequest' is not null or undefined
            assertParamExists('updatePaymentAuthorisation', 'paymentAuthorisationRequest', paymentAuthorisationRequest)
            const localVarPath = `/payment-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to access account data. <br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow. <br><br>Features: <ul><li>`INITIATE_ACCOUNT_REQUEST`</li><li>`INITIATE_PRE_AUTHORISATION`</li></ul>
         * @summary Update Account Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreAuthoriseAccountConsent: async (consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('updatePreAuthoriseAccountConsent', 'consent', consent)
            // verify required parameter 'accountAuthorisationRequest' is not null or undefined
            assertParamExists('updatePreAuthoriseAccountConsent', 'accountAuthorisationRequest', accountAuthorisationRequest)
            const localVarPath = `/account-auth-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorisationsApi - functional programming interface
 * @export
 */
export const AuthorisationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorisationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_BULK_PAYMENT`
         * @summary Create Bulk Payment Authorisation
         * @param {BulkPaymentAuthorisationRequest} bulkPaymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createBulkPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_BULK_PAYMENT` feature in order to obtain the the user\'s authorisation for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Create Embedded Bulk Payment Authorisation
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createEmbeddedBulkPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT` feature in order to obtain the the user\'s authorisation for a payment.<br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Create Embedded Payment Authorisation
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createEmbeddedPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a payment. This endpoint is used to initiate all the different payment listed below. Based on the type of payment you wish to make, you may be required to provide specific properties in [PaymentRequest](https://docs.yapily.com/api/reference/#operation/createPaymentAuthorisation!path=paymentRequest&t=request). First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/reference/#operation/getInstitution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`INITIATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment Authorisation
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentAuthorisation(paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the pre-authorisation process for payments for CBI Globe institutions that contain the `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS` feature to authenticate the user. <br><br>Feature: `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS`
         * @summary Create Payment Pre-authorisation
         * @param {PaymentPreAuthorisationRequest} paymentPreAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPreAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest, raw, psuIpAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createPaymentPreAuthorisationRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the pre-authorisation process for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature to authenticate the user. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Create Pre-authorisation
         * @param {PreAuthorisationRequest} preAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPreAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPreAuthorisationRequest(preAuthorisationRequest, raw, psuId, psuCorporateId, psuIpAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.createPreAuthorisationRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial institution in order to give consent to access account data.<br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_ACCOUNT_REQUEST`
         * @summary Create Account Authorisation
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfAccountAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateAccountRequest(accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.initiateAccountRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_ACCOUNT_REQUEST` feature in order to obtain the the user\'s authorisation to access their account information. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Create Embedded Account Authorisation
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfEmbeddedAccountAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.initiateEmbeddedAccountRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to prompt the account holder for continued access to their financial data. This endpoint should be used when a `Consent` that was previously `AUTHORIZED` can no longer be used to retrieve data.<br><br>See [Re-Authorisation](https://docs.yapily.com/pages/key-concepts/account-data/account-consents/#re-authorisation) for more information.
         * @summary Re-authorise Account Consent
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfAccountAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reAuthoriseAccount(consent, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.reAuthoriseAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to access the user\'s financial data. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Update Embedded Account Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfEmbeddedAccountAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmbeddedAccountRequest(consentId, embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.updateEmbeddedAccountRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Update Embedded Bulk Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmbeddedBulkPaymentAuthorisation(consentId, bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.updateEmbeddedBulkPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a payment. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/embedded/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Update Embedded Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmbeddedPaymentAuthorisation(consentId, paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.updateEmbeddedPaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to initiate a payment. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Update Payment Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentAuthorisation(consent, paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.updatePaymentAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to access account data. <br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow. <br><br>Features: <ul><li>`INITIATE_ACCOUNT_REQUEST`</li><li>`INITIATE_PRE_AUTHORISATION`</li></ul>
         * @summary Update Account Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfAccountAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreAuthoriseAccountConsent(consent, accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorisationsApi.updatePreAuthoriseAccountConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorisationsApi - factory interface
 * @export
 */
export const AuthorisationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorisationsApiFp(configuration)
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_BULK_PAYMENT`
         * @summary Create Bulk Payment Authorisation
         * @param {BulkPaymentAuthorisationRequest} bulkPaymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse> {
            return localVarFp.createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_BULK_PAYMENT` feature in order to obtain the the user\'s authorisation for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Create Embedded Bulk Payment Authorisation
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse> {
            return localVarFp.createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT` feature in order to obtain the the user\'s authorisation for a payment.<br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Create Embedded Payment Authorisation
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse> {
            return localVarFp.createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a payment. This endpoint is used to initiate all the different payment listed below. Based on the type of payment you wish to make, you may be required to provide specific properties in [PaymentRequest](https://docs.yapily.com/api/reference/#operation/createPaymentAuthorisation!path=paymentRequest&t=request). First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/reference/#operation/getInstitution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`INITIATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment Authorisation
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse> {
            return localVarFp.createPaymentAuthorisation(paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the pre-authorisation process for payments for CBI Globe institutions that contain the `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS` feature to authenticate the user. <br><br>Feature: `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS`
         * @summary Create Payment Pre-authorisation
         * @param {PaymentPreAuthorisationRequest} paymentPreAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, options?: any): AxiosPromise<ApiResponseOfPreAuthorisationResponse> {
            return localVarFp.createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest, raw, psuIpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the pre-authorisation process for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature to authenticate the user. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Create Pre-authorisation
         * @param {PreAuthorisationRequest} preAuthorisationRequest 
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, options?: any): AxiosPromise<ApiResponseOfPreAuthorisationResponse> {
            return localVarFp.createPreAuthorisationRequest(preAuthorisationRequest, raw, psuId, psuCorporateId, psuIpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial institution in order to give consent to access account data.<br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_ACCOUNT_REQUEST`
         * @summary Create Account Authorisation
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfAccountAuthorisationResponse> {
            return localVarFp.initiateAccountRequest(accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_ACCOUNT_REQUEST` feature in order to obtain the the user\'s authorisation to access their account information. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Create Embedded Account Authorisation
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfEmbeddedAccountAuthorisationResponse> {
            return localVarFp.initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to prompt the account holder for continued access to their financial data. This endpoint should be used when a `Consent` that was previously `AUTHORIZED` can no longer be used to retrieve data.<br><br>See [Re-Authorisation](https://docs.yapily.com/pages/key-concepts/account-data/account-consents/#re-authorisation) for more information.
         * @summary Re-authorise Account Consent
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfAccountAuthorisationResponse> {
            return localVarFp.reAuthoriseAccount(consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to access the user\'s financial data. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
         * @summary Update Embedded Account Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfEmbeddedAccountAuthorisationResponse> {
            return localVarFp.updateEmbeddedAccountRequest(consentId, embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
         * @summary Update Embedded Bulk Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse> {
            return localVarFp.updateEmbeddedBulkPaymentAuthorisation(consentId, bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a payment. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/embedded/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
         * @summary Update Embedded Payment Authorisation
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentEmbeddedAuthorisationRequestResponse> {
            return localVarFp.updateEmbeddedPaymentAuthorisation(consentId, paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to initiate a payment. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
         * @summary Update Payment Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentAuthorisationRequestResponse> {
            return localVarFp.updatePaymentAuthorisation(consent, paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to access account data. <br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow. <br><br>Features: <ul><li>`INITIATE_ACCOUNT_REQUEST`</li><li>`INITIATE_PRE_AUTHORISATION`</li></ul>
         * @summary Update Account Pre-authorisation
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfAccountAuthorisationResponse> {
            return localVarFp.updatePreAuthoriseAccountConsent(consent, accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorisationsApi - object-oriented interface
 * @export
 * @class AuthorisationsApi
 * @extends {BaseAPI}
 */
export class AuthorisationsApi extends BaseAPI {
    /**
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_BULK_PAYMENT`
     * @summary Create Bulk Payment Authorisation
     * @param {BulkPaymentAuthorisationRequest} bulkPaymentAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest: BulkPaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createBulkPaymentAuthorisation(bulkPaymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_BULK_PAYMENT` feature in order to obtain the the user\'s authorisation for a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
     * @summary Create Embedded Bulk Payment Authorisation
     * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createEmbeddedBulkPaymentAuthorisation(bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT` feature in order to obtain the the user\'s authorisation for a payment.<br><br> See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
     * @summary Create Embedded Payment Authorisation
     * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createEmbeddedPaymentAuthorisation(paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for a payment. This endpoint is used to initiate all the different payment listed below. Based on the type of payment you wish to make, you may be required to provide specific properties in [PaymentRequest](https://docs.yapily.com/api/reference/#operation/createPaymentAuthorisation!path=paymentRequest&t=request). First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/reference/#operation/getInstitution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`INITIATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`INITIATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`INITIATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
     * @summary Create Payment Authorisation
     * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createPaymentAuthorisation(paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createPaymentAuthorisation(paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the pre-authorisation process for payments for CBI Globe institutions that contain the `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS` feature to authenticate the user. <br><br>Feature: `INITIATE_ONETIME_PRE_AUTHORISATION_PAYMENTS`
     * @summary Create Payment Pre-authorisation
     * @param {PaymentPreAuthorisationRequest} paymentPreAuthorisationRequest 
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest: PaymentPreAuthorisationRequest, raw?: boolean, psuIpAddress?: string, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createPaymentPreAuthorisationRequest(paymentPreAuthorisationRequest, raw, psuIpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the pre-authorisation process for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature to authenticate the user. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
     * @summary Create Pre-authorisation
     * @param {PreAuthorisationRequest} preAuthorisationRequest 
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public createPreAuthorisationRequest(preAuthorisationRequest: PreAuthorisationRequest, raw?: boolean, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).createPreAuthorisationRequest(preAuthorisationRequest, raw, psuId, psuCorporateId, psuIpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the authorisation process and direct users to the login screen of their financial institution in order to give consent to access account data.<br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_ACCOUNT_REQUEST`
     * @summary Create Account Authorisation
     * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public initiateAccountRequest(accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).initiateAccountRequest(accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the embedded authorisation process for an `Institution` that contains the `INITIATE_EMBEDDED_ACCOUNT_REQUEST` feature in order to obtain the the user\'s authorisation to access their account information. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
     * @summary Create Embedded Account Authorisation
     * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).initiateEmbeddedAccountRequest(embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to prompt the account holder for continued access to their financial data. This endpoint should be used when a `Consent` that was previously `AUTHORIZED` can no longer be used to retrieve data.<br><br>See [Re-Authorisation](https://docs.yapily.com/pages/key-concepts/account-data/account-consents/#re-authorisation) for more information.
     * @summary Re-authorise Account Consent
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public reAuthoriseAccount(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).reAuthoriseAccount(consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to access the user\'s financial data. <br><br>See [Embedded Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/embedded-account-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_ACCOUNT_REQUEST`
     * @summary Update Embedded Account Authorisation
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {EmbeddedAccountAuthorisationRequest} embeddedAccountAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public updateEmbeddedAccountRequest(consentId: string, embeddedAccountAuthorisationRequest: EmbeddedAccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).updateEmbeddedAccountRequest(consentId, embeddedAccountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a bulk payment. See [Bulk Payments](https://docs.yapily.com/pages/key-concepts/payments/payment-execution/bulk-payments/) for more information. <br><br>See [Embedded Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/embedded-payment-flows/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_BULK_PAYMENT`
     * @summary Update Embedded Bulk Payment Authorisation
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {BulkPaymentEmbeddedAuthorisationRequest} bulkPaymentEmbeddedAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public updateEmbeddedBulkPaymentAuthorisation(consentId: string, bulkPaymentEmbeddedAuthorisationRequest: BulkPaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).updateEmbeddedBulkPaymentAuthorisation(consentId, bulkPaymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to pass the SCA Code received from the `Institution` (and the SCA method selected by the user where multiple SCA methods are supported by the `Institution`) in order to complete the embedded authorisation to initiate a payment. <br><br> See [Embedded Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/embedded/) for more information about this flow.<br><br>Feature: `INITIATE_EMBEDDED_DOMESTIC_SINGLE_PAYMENT`
     * @summary Update Embedded Payment Authorisation
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {PaymentEmbeddedAuthorisationRequest} paymentEmbeddedAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public updateEmbeddedPaymentAuthorisation(consentId: string, paymentEmbeddedAuthorisationRequest: PaymentEmbeddedAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).updateEmbeddedPaymentAuthorisation(consentId, paymentEmbeddedAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to initiate a payment. <br><br>See [Redirect Payment Flows](https://docs.yapily.com/pages/key-concepts/payments/payment-authorisation/redirect-payment-flows/) for more information about this flow. <br><br>Feature: `INITIATE_PRE_AUTHORISATION`
     * @summary Update Payment Pre-authorisation
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {PaymentAuthorisationRequest} paymentAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public updatePaymentAuthorisation(consent: string, paymentAuthorisationRequest: PaymentAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).updatePaymentAuthorisation(consent, paymentAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to continue the authorisation process and for any `Institution` that contains the `INITIATE_PRE_AUTHORISATION` feature and direct user to the login screen of their financial institution in order to give consent to access account data. <br><br>See [Redirect Account Flows](https://docs.yapily.com/pages/key-concepts/account-data/account-authorisation/redirect-account-flows/) for more information about this flow. <br><br>Features: <ul><li>`INITIATE_ACCOUNT_REQUEST`</li><li>`INITIATE_PRE_AUTHORISATION`</li></ul>
     * @summary Update Account Pre-authorisation
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {AccountAuthorisationRequest} accountAuthorisationRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationsApi
     */
    public updatePreAuthoriseAccountConsent(consent: string, accountAuthorisationRequest: AccountAuthorisationRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return AuthorisationsApiFp(this.configuration).updatePreAuthoriseAccountConsent(consent, accountAuthorisationRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsentsApi - axios parameter creator
 * @export
 */
export const ConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a consent using the consent Id
         * @summary Delete Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {boolean} [forceDelete] __Optional__. Whether to force the deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (consentId: string, forceDelete?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('_delete', 'consentId', consentId)
            const localVarPath = `/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (forceDelete !== undefined) {
                localVarQueryParameter['forceDelete'] = forceDelete;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to obtain a Yapily Consent object containing the `consentToken` once the user has authenticated and you have an OAuth2 authorisation code `auth-code` and state `auth-state`.
         * @summary Exchange OAuth2 Code
         * @param {ConsentAuthCodeRequest} consentAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsentWithCode: async (consentAuthCodeRequest: ConsentAuthCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentAuthCodeRequest' is not null or undefined
            assertParamExists('createConsentWithCode', 'consentAuthCodeRequest', consentAuthCodeRequest)
            const localVarPath = `/consent-auth-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(consentAuthCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to indicate to Yapily that reconfirmation has occurred for a given Consent, and to update lastUpdatedAt and reconfirmBy for that Consent. Returns the Consent.
         * @summary Extend Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {ExtendConsentRequest} extendConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendConsent: async (consentId: string, extendConsentRequest: ExtendConsentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('extendConsent', 'consentId', consentId)
            // verify required parameter 'extendConsentRequest' is not null or undefined
            assertParamExists('extendConsent', 'extendConsentRequest', extendConsentRequest)
            const localVarPath = `/consents/{consentId}/extend`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extendConsentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get consent using the consent Id
         * @summary Get Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentById: async (consentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getConsentById', 'consentId', consentId)
            const localVarPath = `/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a One-time-token for the consent token
         * @summary Exchange One Time Token
         * @param {OneTimeTokenRequest} oneTimeTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentBySingleAccessConsent: async (oneTimeTokenRequest: OneTimeTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oneTimeTokenRequest' is not null or undefined
            assertParamExists('getConsentBySingleAccessConsent', 'oneTimeTokenRequest', oneTimeTokenRequest)
            const localVarPath = `/consent-one-time-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oneTimeTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve all the consents created for each user within an application
         * @summary Get Consents
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {Set<string>} [filterUserUuid] __Optional__. Filter records based on the list of &#x60;userUuid&#x60; users provided.
         * @param {Set<string>} [filterInstitution] __Optional__. Filter records based on the list of &#x60;Institution&#x60; provided.
         * @param {Set<string>} [filterStatus] __Optional__. Filter records based on the list of &#x60;Consent&#x60; [statuses](https://docs.yapily.com/api/reference/#operation/getConsents!c&#x3D;200&amp;path&#x3D;data/status&amp;t&#x3D;response).
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsents: async (filterApplicationUserId?: Set<string>, filterUserUuid?: Set<string>, filterInstitution?: Set<string>, filterStatus?: Set<string>, from?: string, before?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filterApplicationUserId) {
                localVarQueryParameter['filter[applicationUserId]'] = Array.from(filterApplicationUserId);
            }

            if (filterUserUuid) {
                localVarQueryParameter['filter[userUuid]'] = Array.from(filterUserUuid);
            }

            if (filterInstitution) {
                localVarQueryParameter['filter[institution]'] = Array.from(filterInstitution);
            }

            if (filterStatus) {
                localVarQueryParameter['filter[status]'] = Array.from(filterStatus);
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsentsApi - functional programming interface
 * @export
 */
export const ConsentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a consent using the consent Id
         * @summary Delete Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {boolean} [forceDelete] __Optional__. Whether to force the deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(consentId: string, forceDelete?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfConsentDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(consentId, forceDelete, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to obtain a Yapily Consent object containing the `consentToken` once the user has authenticated and you have an OAuth2 authorisation code `auth-code` and state `auth-state`.
         * @summary Exchange OAuth2 Code
         * @param {ConsentAuthCodeRequest} consentAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConsentWithCode(consentAuthCodeRequest: ConsentAuthCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConsentWithCode(consentAuthCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi.createConsentWithCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to indicate to Yapily that reconfirmation has occurred for a given Consent, and to update lastUpdatedAt and reconfirmBy for that Consent. Returns the Consent.
         * @summary Extend Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {ExtendConsentRequest} extendConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendConsent(consentId: string, extendConsentRequest: ExtendConsentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfConsent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendConsent(consentId, extendConsentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi.extendConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get consent using the consent Id
         * @summary Get Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentById(consentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfConsent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentById(consentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi.getConsentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a One-time-token for the consent token
         * @summary Exchange One Time Token
         * @param {OneTimeTokenRequest} oneTimeTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentBySingleAccessConsent(oneTimeTokenRequest: OneTimeTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentBySingleAccessConsent(oneTimeTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi.getConsentBySingleAccessConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve all the consents created for each user within an application
         * @summary Get Consents
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {Set<string>} [filterUserUuid] __Optional__. Filter records based on the list of &#x60;userUuid&#x60; users provided.
         * @param {Set<string>} [filterInstitution] __Optional__. Filter records based on the list of &#x60;Institution&#x60; provided.
         * @param {Set<string>} [filterStatus] __Optional__. Filter records based on the list of &#x60;Consent&#x60; [statuses](https://docs.yapily.com/api/reference/#operation/getConsents!c&#x3D;200&amp;path&#x3D;data/status&amp;t&#x3D;response).
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsents(filterApplicationUserId?: Set<string>, filterUserUuid?: Set<string>, filterInstitution?: Set<string>, filterStatus?: Set<string>, from?: string, before?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfConsent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsents(filterApplicationUserId, filterUserUuid, filterInstitution, filterStatus, from, before, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsentsApi.getConsents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsentsApi - factory interface
 * @export
 */
export const ConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsentsApiFp(configuration)
    return {
        /**
         * Delete a consent using the consent Id
         * @summary Delete Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {boolean} [forceDelete] __Optional__. Whether to force the deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(consentId: string, forceDelete?: boolean, options?: any): AxiosPromise<ApiResponseOfConsentDeleteResponse> {
            return localVarFp._delete(consentId, forceDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to obtain a Yapily Consent object containing the `consentToken` once the user has authenticated and you have an OAuth2 authorisation code `auth-code` and state `auth-state`.
         * @summary Exchange OAuth2 Code
         * @param {ConsentAuthCodeRequest} consentAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsentWithCode(consentAuthCodeRequest: ConsentAuthCodeRequest, options?: any): AxiosPromise<Consent> {
            return localVarFp.createConsentWithCode(consentAuthCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to indicate to Yapily that reconfirmation has occurred for a given Consent, and to update lastUpdatedAt and reconfirmBy for that Consent. Returns the Consent.
         * @summary Extend Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {ExtendConsentRequest} extendConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendConsent(consentId: string, extendConsentRequest: ExtendConsentRequest, options?: any): AxiosPromise<ApiResponseOfConsent> {
            return localVarFp.extendConsent(consentId, extendConsentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get consent using the consent Id
         * @summary Get Consent
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentById(consentId: string, options?: any): AxiosPromise<ApiResponseOfConsent> {
            return localVarFp.getConsentById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a One-time-token for the consent token
         * @summary Exchange One Time Token
         * @param {OneTimeTokenRequest} oneTimeTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentBySingleAccessConsent(oneTimeTokenRequest: OneTimeTokenRequest, options?: any): AxiosPromise<Consent> {
            return localVarFp.getConsentBySingleAccessConsent(oneTimeTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve all the consents created for each user within an application
         * @summary Get Consents
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {Set<string>} [filterUserUuid] __Optional__. Filter records based on the list of &#x60;userUuid&#x60; users provided.
         * @param {Set<string>} [filterInstitution] __Optional__. Filter records based on the list of &#x60;Institution&#x60; provided.
         * @param {Set<string>} [filterStatus] __Optional__. Filter records based on the list of &#x60;Consent&#x60; [statuses](https://docs.yapily.com/api/reference/#operation/getConsents!c&#x3D;200&amp;path&#x3D;data/status&amp;t&#x3D;response).
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsents(filterApplicationUserId?: Set<string>, filterUserUuid?: Set<string>, filterInstitution?: Set<string>, filterStatus?: Set<string>, from?: string, before?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ApiListResponseOfConsent> {
            return localVarFp.getConsents(filterApplicationUserId, filterUserUuid, filterInstitution, filterStatus, from, before, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsentsApi - object-oriented interface
 * @export
 * @class ConsentsApi
 * @extends {BaseAPI}
 */
export class ConsentsApi extends BaseAPI {
    /**
     * Delete a consent using the consent Id
     * @summary Delete Consent
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {boolean} [forceDelete] __Optional__. Whether to force the deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public _delete(consentId: string, forceDelete?: boolean, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration)._delete(consentId, forceDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to obtain a Yapily Consent object containing the `consentToken` once the user has authenticated and you have an OAuth2 authorisation code `auth-code` and state `auth-state`.
     * @summary Exchange OAuth2 Code
     * @param {ConsentAuthCodeRequest} consentAuthCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public createConsentWithCode(consentAuthCodeRequest: ConsentAuthCodeRequest, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration).createConsentWithCode(consentAuthCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to indicate to Yapily that reconfirmation has occurred for a given Consent, and to update lastUpdatedAt and reconfirmBy for that Consent. Returns the Consent.
     * @summary Extend Consent
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {ExtendConsentRequest} extendConsentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public extendConsent(consentId: string, extendConsentRequest: ExtendConsentRequest, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration).extendConsent(consentId, extendConsentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get consent using the consent Id
     * @summary Get Consent
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Consent&#x60; to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public getConsentById(consentId: string, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration).getConsentById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a One-time-token for the consent token
     * @summary Exchange One Time Token
     * @param {OneTimeTokenRequest} oneTimeTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public getConsentBySingleAccessConsent(oneTimeTokenRequest: OneTimeTokenRequest, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration).getConsentBySingleAccessConsent(oneTimeTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve all the consents created for each user within an application
     * @summary Get Consents
     * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
     * @param {Set<string>} [filterUserUuid] __Optional__. Filter records based on the list of &#x60;userUuid&#x60; users provided.
     * @param {Set<string>} [filterInstitution] __Optional__. Filter records based on the list of &#x60;Institution&#x60; provided.
     * @param {Set<string>} [filterStatus] __Optional__. Filter records based on the list of &#x60;Consent&#x60; [statuses](https://docs.yapily.com/api/reference/#operation/getConsents!c&#x3D;200&amp;path&#x3D;data/status&amp;t&#x3D;response).
     * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
     * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public getConsents(filterApplicationUserId?: Set<string>, filterUserUuid?: Set<string>, filterInstitution?: Set<string>, filterStatus?: Set<string>, from?: string, before?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ConsentsApiFp(this.configuration).getConsents(filterApplicationUserId, filterUserUuid, filterInstitution, filterStatus, from, before, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConstraintsApi - axios parameter creator
 * @export
 */
export const ConstraintsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Data Constraints Rules against an Institution for Account Authorisation requests
         * @summary Get Data Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Data Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetAccountConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConstraintsRulesByInstitution: async (institutionIds: Array<string>, institutionCountryCode: string, endpointPath?: string, endpointMethod?: GetAccountConstraintsRulesByInstitutionEndpointMethodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionIds' is not null or undefined
            assertParamExists('getAccountConstraintsRulesByInstitution', 'institutionIds', institutionIds)
            // verify required parameter 'institutionCountryCode' is not null or undefined
            assertParamExists('getAccountConstraintsRulesByInstitution', 'institutionCountryCode', institutionCountryCode)
            const localVarPath = `/institutions/constraints/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (institutionIds) {
                localVarQueryParameter['institutionIds'] = institutionIds;
            }

            if (institutionCountryCode !== undefined) {
                localVarQueryParameter['institutionCountryCode'] = institutionCountryCode;
            }

            if (endpointPath !== undefined) {
                localVarQueryParameter['endpointPath'] = endpointPath;
            }

            if (endpointMethod !== undefined) {
                localVarQueryParameter['endpointMethod'] = endpointMethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve institution specific constraints for payment authorisation and submission requests
         * @summary Get Payment Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Payment Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum} paymentType Type of payment to retrieve payment constraints for
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentConstraintsRulesByInstitution: async (institutionIds: Array<string>, institutionCountryCode: string, paymentType: GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum, endpointPath?: string, endpointMethod?: GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionIds' is not null or undefined
            assertParamExists('getPaymentConstraintsRulesByInstitution', 'institutionIds', institutionIds)
            // verify required parameter 'institutionCountryCode' is not null or undefined
            assertParamExists('getPaymentConstraintsRulesByInstitution', 'institutionCountryCode', institutionCountryCode)
            // verify required parameter 'paymentType' is not null or undefined
            assertParamExists('getPaymentConstraintsRulesByInstitution', 'paymentType', paymentType)
            const localVarPath = `/institutions/constraints/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (institutionIds) {
                localVarQueryParameter['institutionIds'] = institutionIds;
            }

            if (institutionCountryCode !== undefined) {
                localVarQueryParameter['institutionCountryCode'] = institutionCountryCode;
            }

            if (paymentType !== undefined) {
                localVarQueryParameter['paymentType'] = paymentType;
            }

            if (endpointPath !== undefined) {
                localVarQueryParameter['endpointPath'] = endpointPath;
            }

            if (endpointMethod !== undefined) {
                localVarQueryParameter['endpointMethod'] = endpointMethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConstraintsApi - functional programming interface
 * @export
 */
export const ConstraintsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConstraintsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Data Constraints Rules against an Institution for Account Authorisation requests
         * @summary Get Data Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Data Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetAccountConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, endpointPath?: string, endpointMethod?: GetAccountConstraintsRulesByInstitutionEndpointMethodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfDataConstraints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountConstraintsRulesByInstitution(institutionIds, institutionCountryCode, endpointPath, endpointMethod, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConstraintsApi.getAccountConstraintsRulesByInstitution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve institution specific constraints for payment authorisation and submission requests
         * @summary Get Payment Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Payment Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum} paymentType Type of payment to retrieve payment constraints for
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, paymentType: GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum, endpointPath?: string, endpointMethod?: GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfPaymentConstraints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentConstraintsRulesByInstitution(institutionIds, institutionCountryCode, paymentType, endpointPath, endpointMethod, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConstraintsApi.getPaymentConstraintsRulesByInstitution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConstraintsApi - factory interface
 * @export
 */
export const ConstraintsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConstraintsApiFp(configuration)
    return {
        /**
         * Get Data Constraints Rules against an Institution for Account Authorisation requests
         * @summary Get Data Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Data Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetAccountConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, endpointPath?: string, endpointMethod?: GetAccountConstraintsRulesByInstitutionEndpointMethodEnum, options?: any): AxiosPromise<ApiListResponseOfDataConstraints> {
            return localVarFp.getAccountConstraintsRulesByInstitution(institutionIds, institutionCountryCode, endpointPath, endpointMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve institution specific constraints for payment authorisation and submission requests
         * @summary Get Payment Constraints Rules
         * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Payment Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
         * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
         * @param {GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum} paymentType Type of payment to retrieve payment constraints for
         * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
         * @param {GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, paymentType: GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum, endpointPath?: string, endpointMethod?: GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum, options?: any): AxiosPromise<ApiListResponseOfPaymentConstraints> {
            return localVarFp.getPaymentConstraintsRulesByInstitution(institutionIds, institutionCountryCode, paymentType, endpointPath, endpointMethod, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConstraintsApi - object-oriented interface
 * @export
 * @class ConstraintsApi
 * @extends {BaseAPI}
 */
export class ConstraintsApi extends BaseAPI {
    /**
     * Get Data Constraints Rules against an Institution for Account Authorisation requests
     * @summary Get Data Constraints Rules
     * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Data Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
     * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
     * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
     * @param {GetAccountConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstraintsApi
     */
    public getAccountConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, endpointPath?: string, endpointMethod?: GetAccountConstraintsRulesByInstitutionEndpointMethodEnum, options?: RawAxiosRequestConfig) {
        return ConstraintsApiFp(this.configuration).getAccountConstraintsRulesByInstitution(institutionIds, institutionCountryCode, endpointPath, endpointMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve institution specific constraints for payment authorisation and submission requests
     * @summary Get Payment Constraints Rules
     * @param {Array<string>} institutionIds Unique Id(s) of the &#x60;Institution&#x60;(s) to retrieve the Payment Constraints for. Multiple institutionIds need to be separated by &#x60;,&#x60;
     * @param {string} institutionCountryCode Country code of the &#x60;Institution&#x60;(s). Ensure that the country code matches the respective institutionIds; any mismatch will result in an HTTP 404 error response.
     * @param {GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum} paymentType Type of payment to retrieve payment constraints for
     * @param {string} [endpointPath] The path on the API that is associated with the operation for which constraints are to be retrieved
     * @param {GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum} [endpointMethod] The HTTP method that is associated with the operation for which constraints are to be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstraintsApi
     */
    public getPaymentConstraintsRulesByInstitution(institutionIds: Array<string>, institutionCountryCode: string, paymentType: GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum, endpointPath?: string, endpointMethod?: GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum, options?: RawAxiosRequestConfig) {
        return ConstraintsApiFp(this.configuration).getPaymentConstraintsRulesByInstitution(institutionIds, institutionCountryCode, paymentType, endpointPath, endpointMethod, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAccountConstraintsRulesByInstitutionEndpointMethodEnum = {
    Post: 'POST',
    Patch: 'PATCH',
    Put: 'PUT',
    Get: 'GET',
    Delete: 'DELETE'
} as const;
export type GetAccountConstraintsRulesByInstitutionEndpointMethodEnum = typeof GetAccountConstraintsRulesByInstitutionEndpointMethodEnum[keyof typeof GetAccountConstraintsRulesByInstitutionEndpointMethodEnum];
/**
 * @export
 */
export const GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum = {
    DomesticPayment: 'DOMESTIC_PAYMENT',
    DomesticInstantPayment: 'DOMESTIC_INSTANT_PAYMENT',
    DomesticVariableRecurringPayment: 'DOMESTIC_VARIABLE_RECURRING_PAYMENT',
    DomesticScheduledPayment: 'DOMESTIC_SCHEDULED_PAYMENT',
    DomesticPeriodicPayment: 'DOMESTIC_PERIODIC_PAYMENT',
    InternationalPayment: 'INTERNATIONAL_PAYMENT',
    InternationalScheduledPayment: 'INTERNATIONAL_SCHEDULED_PAYMENT',
    InternationalPeriodicPayment: 'INTERNATIONAL_PERIODIC_PAYMENT',
    BulkPayment: 'BULK_PAYMENT'
} as const;
export type GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum = typeof GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum[keyof typeof GetPaymentConstraintsRulesByInstitutionPaymentTypeEnum];
/**
 * @export
 */
export const GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum = {
    Post: 'POST',
    Patch: 'PATCH',
    Put: 'PUT',
    Get: 'GET',
    Delete: 'DELETE'
} as const;
export type GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum = typeof GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum[keyof typeof GetPaymentConstraintsRulesByInstitutionEndpointMethodEnum];


/**
 * FinancialDataApi - axios parameter creator
 * @export
 */
export const FinancialDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account and balance information for a user\'s specified account.<br><br>Feature: `ACCOUNT`
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccount', 'consent', consent)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`
         * @summary Get Account Balances
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances: async (accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBalances', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccountBalances', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`
         * @summary Get Account Direct Debits
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDirectDebits: async (accountId: string, consent: string, limit?: number, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountDirectDebits', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccountDirectDebits', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/direct-debits`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`
         * @summary Get Account Periodic Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPeriodicPayments: async (accountId: string, consent: string, limit?: number, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountPeriodicPayments', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccountPeriodicPayments', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/periodic-payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`
         * @summary Get Account Scheduled Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountScheduledPayments: async (accountId: string, consent: string, limit?: number, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountScheduledPayments', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccountScheduledPayments', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/scheduled-payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`
         * @summary Get Accounts
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getAccounts', 'consent', consent)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the beneficiaries of a user\'s account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`
         * @summary Get Account Beneficiaries
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiaries: async (accountId: string, consent: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getBeneficiaries', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getBeneficiaries', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/beneficiaries`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.
         * @summary Get Categories
         * @param {string} country __Mandatory__. The 2 letter country code e.g. \&#39;GB\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (country: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('getCategories', 'country', country)
            const localVarPath = `/categories/{country}`
                .replace(`{${"country"}}`, encodeURIComponent(String(country)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the identity information for an account.<br><br>Feature: `IDENTITY`
         * @summary Get Identity
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity: async (consent: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getIdentity', 'consent', consent)
            const localVarPath = `/identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Real Time Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [cursor] __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealTimeTransactions: async (accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, from?: string, before?: string, cursor?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getRealTimeTransactions', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getRealTimeTransactions', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/real-time/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`
         * @summary Get Account Statement
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatement: async (consent: string, accountId: string, statementId: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getStatement', 'consent', consent)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getStatement', 'accountId', accountId)
            // verify required parameter 'statementId' is not null or undefined
            assertParamExists('getStatement', 'statementId', statementId)
            const localVarPath = `/accounts/{accountId}/statements/{statementId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"statementId"}}`, encodeURIComponent(String(statementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`
         * @summary Get Account Statement File
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementFile: async (consent: string, accountId: string, statementId: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getStatementFile', 'consent', consent)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getStatementFile', 'accountId', accountId)
            // verify required parameter 'statementId' is not null or undefined
            assertParamExists('getStatementFile', 'statementId', statementId)
            const localVarPath = `/accounts/{accountId}/statements/{statementId}/file`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"statementId"}}`, encodeURIComponent(String(statementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`
         * @summary Get Account Statements
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements: async (consent: string, accountId: string, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getStatements', 'consent', consent)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getStatements', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/statements`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {Array<string>} [_with] __Optional__. Acceptable value: &#x60;categorisation&#x60;. When set, will include enrichment data in the transactions returned. &lt;br&gt;&lt;br&gt;Enrichment data is optional, e.g. when \&#39;categorisation\&#39; enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {string} [cursor] __Optional__. This property is not currently in use.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, _with?: Array<string>, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, cursor?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactions', 'accountId', accountId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getTransactions', 'consent', consent)
            const localVarPath = `/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (_with) {
                localVarQueryParameter['with'] = _with;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinancialDataApi - functional programming interface
 * @export
 */
export const FinancialDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinancialDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account and balance information for a user\'s specified account.<br><br>Feature: `ACCOUNT`
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`
         * @summary Get Account Balances
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBalances(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBalances(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccountBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`
         * @summary Get Account Direct Debits
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDirectDebits(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfDirectDebitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountDirectDebits(accountId, consent, limit, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccountDirectDebits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`
         * @summary Get Account Periodic Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPeriodicPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPeriodicPayments(accountId, consent, limit, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccountPeriodicPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`
         * @summary Get Account Scheduled Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountScheduledPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountScheduledPayments(accountId, consent, limit, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccountScheduledPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`
         * @summary Get Accounts
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountApiListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(consent, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all the beneficiaries of a user\'s account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`
         * @summary Get Account Beneficiaries
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBeneficiaries(accountId: string, consent: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBeneficiaries(accountId, consent, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getBeneficiaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.
         * @summary Get Categories
         * @param {string} country __Mandatory__. The 2 letter country code e.g. \&#39;GB\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(country: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the identity information for an account.<br><br>Feature: `IDENTITY`
         * @summary Get Identity
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentity(consent: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfIdentity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(consent, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getIdentity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Real Time Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [cursor] __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealTimeTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, from?: string, before?: string, cursor?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfRealTimeTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealTimeTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, from, before, cursor, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getRealTimeTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`
         * @summary Get Account Statement
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatement(consent: string, accountId: string, statementId: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfAccountStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatement(consent, accountId, statementId, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getStatement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`
         * @summary Get Account Statement File
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementFile(consent: string, accountId: string, statementId: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementFile(consent, accountId, statementId, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getStatementFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`
         * @summary Get Account Statements
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatements(consent: string, accountId: string, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfAccountStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatements(consent, accountId, from, before, limit, sort, offset, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {Array<string>} [_with] __Optional__. Acceptable value: &#x60;categorisation&#x60;. When set, will include enrichment data in the transactions returned. &lt;br&gt;&lt;br&gt;Enrichment data is optional, e.g. when \&#39;categorisation\&#39; enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {string} [cursor] __Optional__. This property is not currently in use.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, _with?: Array<string>, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, cursor?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, _with, from, before, limit, sort, offset, cursor, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialDataApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FinancialDataApi - factory interface
 * @export
 */
export const FinancialDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinancialDataApiFp(configuration)
    return {
        /**
         * Returns the account and balance information for a user\'s specified account.<br><br>Feature: `ACCOUNT`
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfAccount> {
            return localVarFp.getAccount(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`
         * @summary Get Account Balances
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfBalances> {
            return localVarFp.getAccountBalances(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`
         * @summary Get Account Direct Debits
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDirectDebits(accountId: string, consent: string, limit?: number, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfDirectDebitResponse> {
            return localVarFp.getAccountDirectDebits(accountId, consent, limit, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`
         * @summary Get Account Periodic Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPeriodicPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfPaymentResponse> {
            return localVarFp.getAccountPeriodicPayments(accountId, consent, limit, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`
         * @summary Get Account Scheduled Payments
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountScheduledPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfPaymentResponse> {
            return localVarFp.getAccountScheduledPayments(accountId, consent, limit, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`
         * @summary Get Accounts
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<AccountApiListResponse> {
            return localVarFp.getAccounts(consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the beneficiaries of a user\'s account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`
         * @summary Get Account Beneficiaries
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBeneficiaries(accountId: string, consent: string, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfBeneficiary> {
            return localVarFp.getBeneficiaries(accountId, consent, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.
         * @summary Get Categories
         * @param {string} country __Mandatory__. The 2 letter country code e.g. \&#39;GB\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(country: string, options?: any): AxiosPromise<ApiListResponseOfCategory> {
            return localVarFp.getCategories(country, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the identity information for an account.<br><br>Feature: `IDENTITY`
         * @summary Get Identity
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity(consent: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfIdentity> {
            return localVarFp.getIdentity(consent, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Real Time Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {string} [cursor] __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealTimeTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, from?: string, before?: string, cursor?: string, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfRealTimeTransaction> {
            return localVarFp.getRealTimeTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, from, before, cursor, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`
         * @summary Get Account Statement
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatement(consent: string, accountId: string, statementId: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfAccountStatement> {
            return localVarFp.getStatement(consent, accountId, statementId, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`
         * @summary Get Account Statement File
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} statementId __Mandatory__. The statement Id of the statement file.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementFile(consent: string, accountId: string, statementId: string, raw?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.getStatementFile(consent, accountId, statementId, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`
         * @summary Get Account Statements
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(consent: string, accountId: string, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfAccountStatement> {
            return localVarFp.getStatements(consent, accountId, from, before, limit, sort, offset, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`
         * @summary Get Account Transactions
         * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {Array<string>} [_with] __Optional__. Acceptable value: &#x60;categorisation&#x60;. When set, will include enrichment data in the transactions returned. &lt;br&gt;&lt;br&gt;Enrichment data is optional, e.g. when \&#39;categorisation\&#39; enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently.
         * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
         * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
         * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
         * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
         * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
         * @param {string} [cursor] __Optional__. This property is not currently in use.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, _with?: Array<string>, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, cursor?: string, raw?: boolean, options?: any): AxiosPromise<ApiListResponseOfTransaction> {
            return localVarFp.getTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, _with, from, before, limit, sort, offset, cursor, raw, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FinancialDataApi - object-oriented interface
 * @export
 * @class FinancialDataApi
 * @extends {BaseAPI}
 */
export class FinancialDataApi extends BaseAPI {
    /**
     * Returns the account and balance information for a user\'s specified account.<br><br>Feature: `ACCOUNT`
     * @summary Get Account
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccount(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccount(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`
     * @summary Get Account Balances
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccountBalances(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccountBalances(accountId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`
     * @summary Get Account Direct Debits
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccountDirectDebits(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccountDirectDebits(accountId, consent, limit, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`
     * @summary Get Account Periodic Payments
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccountPeriodicPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccountPeriodicPayments(accountId, consent, limit, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`
     * @summary Get Account Scheduled Payments
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccountScheduledPayments(accountId: string, consent: string, limit?: number, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccountScheduledPayments(accountId, consent, limit, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`
     * @summary Get Accounts
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getAccounts(consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getAccounts(consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the beneficiaries of a user\'s account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`
     * @summary Get Account Beneficiaries
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getBeneficiaries(accountId: string, consent: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getBeneficiaries(accountId, consent, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.
     * @summary Get Categories
     * @param {string} country __Mandatory__. The 2 letter country code e.g. \&#39;GB\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getCategories(country: string, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getCategories(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the identity information for an account.<br><br>Feature: `IDENTITY`
     * @summary Get Identity
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getIdentity(consent: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getIdentity(consent, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`
     * @summary Get Real Time Account Transactions
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
     * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
     * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
     * @param {string} [cursor] __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getRealTimeTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, from?: string, before?: string, cursor?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getRealTimeTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, from, before, cursor, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`
     * @summary Get Account Statement
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} statementId __Mandatory__. The statement Id of the statement file.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getStatement(consent: string, accountId: string, statementId: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getStatement(consent, accountId, statementId, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`
     * @summary Get Account Statement File
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} statementId __Mandatory__. The statement Id of the statement file.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getStatementFile(consent: string, accountId: string, statementId: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getStatementFile(consent, accountId, statementId, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`
     * @summary Get Account Statements
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
     * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
     * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getStatements(consent: string, accountId: string, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getStatements(consent, accountId, from, before, limit, sort, offset, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`
     * @summary Get Account Transactions
     * @param {string} accountId __Mandatory__. The account Id of the user\&#39;s bank account.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {Array<string>} [_with] __Optional__. Acceptable value: &#x60;categorisation&#x60;. When set, will include enrichment data in the transactions returned. &lt;br&gt;&lt;br&gt;Enrichment data is optional, e.g. when \&#39;categorisation\&#39; enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently.
     * @param {string} [from] __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ). 
     * @param {string} [before] __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ).
     * @param {number} [limit] __Optional__. The maximum number of transaction records to be returned. Must be between 0 and 1000.
     * @param {SortEnum} [sort] __Optional__. Sort transaction records by date ascending with \&#39;date\&#39; or descending with \&#39;-date\&#39;. The default sort order is descending
     * @param {number} [offset] __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
     * @param {string} [cursor] __Optional__. This property is not currently in use.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialDataApi
     */
    public getTransactions(accountId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, _with?: Array<string>, from?: string, before?: string, limit?: number, sort?: SortEnum, offset?: number, cursor?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return FinancialDataApiFp(this.configuration).getTransactions(accountId, consent, psuId, psuCorporateId, psuIpAddress, _with, from, before, limit, sort, offset, cursor, raw, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FinancialProfileApi - axios parameter creator
 * @export
 */
export const FinancialProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to add a consent to a `Financial Profile` for a `User`.  The response is asynchronous, returned with pending status, while retrieval of financial data is commenced.  There is a limit of 10,000 transactions for enrichment.
         * @summary Create Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; obtained from the original authorisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileConsent: async (userUuid: string, consent: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('createProfileConsent', 'userUuid', userUuid)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('createProfileConsent', 'consent', consent)
            const localVarPath = `/users/{userUuid}/profile/consents`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to delete a `ProfileConsent` for a `User`. This will remove the consent and all associated financial data from the \'Financial Profile\'.
         * @summary Delete Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileConsent: async (userUuid: string, profileConsentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('deleteProfileConsent', 'userUuid', userUuid)
            // verify required parameter 'profileConsentId' is not null or undefined
            assertParamExists('deleteProfileConsent', 'profileConsentId', profileConsentId)
            const localVarPath = `/users/{userUuid}/profile/consents/{profileConsentId}`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)))
                .replace(`{${"profileConsentId"}}`, encodeURIComponent(String(profileConsentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve a `Balance Prediction Profile` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Predicted Balances
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancePrediction: async (userUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('getBalancePrediction', 'userUuid', userUuid)
            const localVarPath = `/users/{userUuid}/profile/predicted-balances`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve a specific ProfileConsent for a User.
         * @summary Get Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileConsent: async (userUuid: string, profileConsentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('getProfileConsent', 'userUuid', userUuid)
            // verify required parameter 'profileConsentId' is not null or undefined
            assertParamExists('getProfileConsent', 'profileConsentId', profileConsentId)
            const localVarPath = `/users/{userUuid}/profile/consents/{profileConsentId}`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)))
                .replace(`{${"profileConsentId"}}`, encodeURIComponent(String(profileConsentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve a `TransactionGroups` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Transaction Groups
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (userUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('getUserProfile', 'userUuid', userUuid)
            const localVarPath = `/users/{userUuid}/profile/transaction-groups`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinancialProfileApi - functional programming interface
 * @export
 */
export const FinancialProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinancialProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to add a consent to a `Financial Profile` for a `User`.  The response is asynchronous, returned with pending status, while retrieval of financial data is commenced.  There is a limit of 10,000 transactions for enrichment.
         * @summary Create Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; obtained from the original authorisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileConsent(userUuid: string, consent: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFinancialProfileAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileConsent(userUuid, consent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialProfileApi.createProfileConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to delete a `ProfileConsent` for a `User`. This will remove the consent and all associated financial data from the \'Financial Profile\'.
         * @summary Delete Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfileConsent(userUuid: string, profileConsentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFinancialProfileConsentRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfileConsent(userUuid, profileConsentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialProfileApi.deleteProfileConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve a `Balance Prediction Profile` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Predicted Balances
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancePrediction(userUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFinancialProfileBalancePrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancePrediction(userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialProfileApi.getBalancePrediction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve a specific ProfileConsent for a User.
         * @summary Get Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileConsent(userUuid: string, profileConsentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFinancialProfileConsent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileConsent(userUuid, profileConsentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialProfileApi.getProfileConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve a `TransactionGroups` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Transaction Groups
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(userUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFinancialProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialProfileApi.getUserProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FinancialProfileApi - factory interface
 * @export
 */
export const FinancialProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinancialProfileApiFp(configuration)
    return {
        /**
         * Used to add a consent to a `Financial Profile` for a `User`.  The response is asynchronous, returned with pending status, while retrieval of financial data is commenced.  There is a limit of 10,000 transactions for enrichment.
         * @summary Create Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; obtained from the original authorisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileConsent(userUuid: string, consent: string, options?: any): AxiosPromise<ApiResponseOfFinancialProfileAuthorisationResponse> {
            return localVarFp.createProfileConsent(userUuid, consent, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to delete a `ProfileConsent` for a `User`. This will remove the consent and all associated financial data from the \'Financial Profile\'.
         * @summary Delete Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileConsent(userUuid: string, profileConsentId: string, options?: any): AxiosPromise<ApiResponseOfFinancialProfileConsentRemoveResponse> {
            return localVarFp.deleteProfileConsent(userUuid, profileConsentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve a `Balance Prediction Profile` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Predicted Balances
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancePrediction(userUuid: string, options?: any): AxiosPromise<ApiResponseOfFinancialProfileBalancePrediction> {
            return localVarFp.getBalancePrediction(userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve a specific ProfileConsent for a User.
         * @summary Get Profile Consent
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileConsent(userUuid: string, profileConsentId: string, options?: any): AxiosPromise<ApiResponseOfFinancialProfileConsent> {
            return localVarFp.getProfileConsent(userUuid, profileConsentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve a `TransactionGroups` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
         * @summary Get Transaction Groups
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(userUuid: string, options?: any): AxiosPromise<ApiResponseOfFinancialProfile> {
            return localVarFp.getUserProfile(userUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FinancialProfileApi - object-oriented interface
 * @export
 * @class FinancialProfileApi
 * @extends {BaseAPI}
 */
export class FinancialProfileApi extends BaseAPI {
    /**
     * Used to add a consent to a `Financial Profile` for a `User`.  The response is asynchronous, returned with pending status, while retrieval of financial data is commenced.  There is a limit of 10,000 transactions for enrichment.
     * @summary Create Profile Consent
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; obtained from the original authorisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialProfileApi
     */
    public createProfileConsent(userUuid: string, consent: string, options?: RawAxiosRequestConfig) {
        return FinancialProfileApiFp(this.configuration).createProfileConsent(userUuid, consent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to delete a `ProfileConsent` for a `User`. This will remove the consent and all associated financial data from the \'Financial Profile\'.
     * @summary Delete Profile Consent
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialProfileApi
     */
    public deleteProfileConsent(userUuid: string, profileConsentId: string, options?: RawAxiosRequestConfig) {
        return FinancialProfileApiFp(this.configuration).deleteProfileConsent(userUuid, profileConsentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve a `Balance Prediction Profile` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
     * @summary Get Predicted Balances
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialProfileApi
     */
    public getBalancePrediction(userUuid: string, options?: RawAxiosRequestConfig) {
        return FinancialProfileApiFp(this.configuration).getBalancePrediction(userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve a specific ProfileConsent for a User.
     * @summary Get Profile Consent
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {string} profileConsentId __Mandatory__. The ID of the ProfileConsent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialProfileApi
     */
    public getProfileConsent(userUuid: string, profileConsentId: string, options?: RawAxiosRequestConfig) {
        return FinancialProfileApiFp(this.configuration).getProfileConsent(userUuid, profileConsentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve a `TransactionGroups` for a `User`.  Status will be `PENDING` until all ProfileConsents are `COMPLETED`.
     * @summary Get Transaction Groups
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinancialProfileApi
     */
    public getUserProfile(userUuid: string, options?: RawAxiosRequestConfig) {
        return FinancialProfileApiFp(this.configuration).getUserProfile(userUuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HostedPagesApi - axios parameter creator
 * @export
 */
export const HostedPagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to initiate a payment request using Yapily Hosted Pages.
         * @summary Create Hosted payment request
         * @param {CreateHostedPaymentRequest} createHostedPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedPaymentRequest: async (createHostedPaymentRequest: CreateHostedPaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHostedPaymentRequest' is not null or undefined
            assertParamExists('createHostedPaymentRequest', 'createHostedPaymentRequest', createHostedPaymentRequest)
            const localVarPath = `/hosted/payment-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHostedPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to created a long lived payment request for Pay By Link
         * @summary Create Pay By Link
         * @param {CreateHostedPaymentRequestLink} createHostedPaymentRequestLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedPaymentRequestLink: async (createHostedPaymentRequestLink: CreateHostedPaymentRequestLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHostedPaymentRequestLink' is not null or undefined
            assertParamExists('createHostedPaymentRequestLink', 'createHostedPaymentRequestLink', createHostedPaymentRequestLink)
            const localVarPath = `/hosted/payment-requests/links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHostedPaymentRequestLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate a VRP consent / mandate request through Yapily Hosted Pages
         * @summary Create VRP Consent
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {CreateHostedVRPConsentRequest} createHostedVRPConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVRPConsentRequest: async (subApplication: string, createHostedVRPConsentRequest: CreateHostedVRPConsentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subApplication' is not null or undefined
            assertParamExists('createHostedVRPConsentRequest', 'subApplication', subApplication)
            // verify required parameter 'createHostedVRPConsentRequest' is not null or undefined
            assertParamExists('createHostedVRPConsentRequest', 'createHostedVRPConsentRequest', createHostedVRPConsentRequest)
            const localVarPath = `/hosted/vrp/consent-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHostedVRPConsentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Check Funds Availability
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVrpFundsConfirmation: async (consentRequestId: string, consentToken: string, fundsConfirmationRequest: FundsConfirmationRequest, subApplication?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentRequestId' is not null or undefined
            assertParamExists('createHostedVrpFundsConfirmation', 'consentRequestId', consentRequestId)
            // verify required parameter 'consentToken' is not null or undefined
            assertParamExists('createHostedVrpFundsConfirmation', 'consentToken', consentToken)
            // verify required parameter 'fundsConfirmationRequest' is not null or undefined
            assertParamExists('createHostedVrpFundsConfirmation', 'fundsConfirmationRequest', fundsConfirmationRequest)
            const localVarPath = `/hosted/vrp/consent-requests/{consentRequestId}/funds-confirmation`
                .replace(`{${"consentRequestId"}}`, encodeURIComponent(String(consentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consentToken != null) {
                localVarHeaderParameter['consent-token'] = String(consentToken);
            }

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundsConfirmationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Variable Recurring Payment
         * @summary Create VRP Payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {CreateHostedVRPPaymentRequest} createHostedVRPPaymentRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVrpPayment: async (consentRequestId: string, consentToken: string, createHostedVRPPaymentRequest: CreateHostedVRPPaymentRequest, subApplication?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentRequestId' is not null or undefined
            assertParamExists('createHostedVrpPayment', 'consentRequestId', consentRequestId)
            // verify required parameter 'consentToken' is not null or undefined
            assertParamExists('createHostedVrpPayment', 'consentToken', consentToken)
            // verify required parameter 'createHostedVRPPaymentRequest' is not null or undefined
            assertParamExists('createHostedVrpPayment', 'createHostedVRPPaymentRequest', createHostedVRPPaymentRequest)
            const localVarPath = `/hosted/vrp/consent-requests/{consentRequestId}/payments`
                .replace(`{${"consentRequestId"}}`, encodeURIComponent(String(consentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consentToken != null) {
                localVarHeaderParameter['consent-token'] = String(consentToken);
            }

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHostedVRPPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get details of a VRP Consent Request
         * @summary Get Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedConsentRequest: async (consentRequestId: string, subApplication?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentRequestId' is not null or undefined
            assertParamExists('getHostedConsentRequest', 'consentRequestId', consentRequestId)
            const localVarPath = `/hosted/vrp/consent-requests/{consentRequestId}`
                .replace(`{${"consentRequestId"}}`, encodeURIComponent(String(consentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get details of a payment request
         * @summary Get Hosted payment request
         * @param {string} paymentRequestId Unique Identifier of the payment request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedPaymentRequest: async (paymentRequestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentRequestId' is not null or undefined
            assertParamExists('getHostedPaymentRequest', 'paymentRequestId', paymentRequestId)
            const localVarPath = `/hosted/payment-requests/{paymentRequestId}`
                .replace(`{${"paymentRequestId"}}`, encodeURIComponent(String(paymentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get all VRP consent requests initiated through Yapily Hosted Pages
         * @summary Get Hosted VRP Consent Requests
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedVRPConsentRequests: async (subApplication: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subApplication' is not null or undefined
            assertParamExists('getHostedVRPConsentRequests', 'subApplication', subApplication)
            const localVarPath = `/hosted/vrp/consent-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get details of a VRP Payment
         * @summary Get VRP payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} paymentId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedVRPPaymentRequest: async (consentRequestId: string, paymentId: string, subApplication?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentRequestId' is not null or undefined
            assertParamExists('getHostedVRPPaymentRequest', 'consentRequestId', consentRequestId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getHostedVRPPaymentRequest', 'paymentId', paymentId)
            const localVarPath = `/hosted/vrp/consent-requests/{consentRequestId}/payments/{paymentId}`
                .replace(`{${"consentRequestId"}}`, encodeURIComponent(String(consentRequestId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke Hosted VRP Consent Request
         * @summary Revoke Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeHostedConsentRequest: async (consentRequestId: string, subApplication?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentRequestId' is not null or undefined
            assertParamExists('revokeHostedConsentRequest', 'consentRequestId', consentRequestId)
            const localVarPath = `/hosted/vrp/consent-requests/{consentRequestId}/revoke`
                .replace(`{${"consentRequestId"}}`, encodeURIComponent(String(consentRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subApplication != null) {
                localVarHeaderParameter['sub-application'] = String(subApplication);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostedPagesApi - functional programming interface
 * @export
 */
export const HostedPagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HostedPagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to initiate a payment request using Yapily Hosted Pages.
         * @summary Create Hosted payment request
         * @param {CreateHostedPaymentRequest} createHostedPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedPaymentRequest(createHostedPaymentRequest: CreateHostedPaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfCreateHostedPaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedPaymentRequest(createHostedPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.createHostedPaymentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to created a long lived payment request for Pay By Link
         * @summary Create Pay By Link
         * @param {CreateHostedPaymentRequestLink} createHostedPaymentRequestLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedPaymentRequestLink(createHostedPaymentRequestLink: CreateHostedPaymentRequestLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfCreateHostedPaymentRequestLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedPaymentRequestLink(createHostedPaymentRequestLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.createHostedPaymentRequestLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate a VRP consent / mandate request through Yapily Hosted Pages
         * @summary Create VRP Consent
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {CreateHostedVRPConsentRequest} createHostedVRPConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedVRPConsentRequest(subApplication: string, createHostedVRPConsentRequest: CreateHostedVRPConsentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfCreateHostedVRPConsentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedVRPConsentRequest(subApplication, createHostedVRPConsentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.createHostedVRPConsentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Check Funds Availability
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedVrpFundsConfirmation(consentRequestId: string, consentToken: string, fundsConfirmationRequest: FundsConfirmationRequest, subApplication?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFundsConfirmationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedVrpFundsConfirmation(consentRequestId, consentToken, fundsConfirmationRequest, subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.createHostedVrpFundsConfirmation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Variable Recurring Payment
         * @summary Create VRP Payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {CreateHostedVRPPaymentRequest} createHostedVRPPaymentRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHostedVrpPayment(consentRequestId: string, consentToken: string, createHostedVRPPaymentRequest: CreateHostedVRPPaymentRequest, subApplication?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfCreateHostedVRPPaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHostedVrpPayment(consentRequestId, consentToken, createHostedVRPPaymentRequest, subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.createHostedVrpPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get details of a VRP Consent Request
         * @summary Get Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfGetHostedVRPConsentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedConsentRequest(consentRequestId, subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.getHostedConsentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get details of a payment request
         * @summary Get Hosted payment request
         * @param {string} paymentRequestId Unique Identifier of the payment request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedPaymentRequest(paymentRequestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfGetHostedPaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedPaymentRequest(paymentRequestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.getHostedPaymentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get all VRP consent requests initiated through Yapily Hosted Pages
         * @summary Get Hosted VRP Consent Requests
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedVRPConsentRequests(subApplication: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfGetHostedVRPConsentsRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedVRPConsentRequests(subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.getHostedVRPConsentRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get details of a VRP Payment
         * @summary Get VRP payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} paymentId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHostedVRPPaymentRequest(consentRequestId: string, paymentId: string, subApplication?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfGetHostedVRPPaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHostedVRPPaymentRequest(consentRequestId, paymentId, subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.getHostedVRPPaymentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke Hosted VRP Consent Request
         * @summary Revoke Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfRevokeHostedVRPConsentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeHostedConsentRequest(consentRequestId, subApplication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HostedPagesApi.revokeHostedConsentRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HostedPagesApi - factory interface
 * @export
 */
export const HostedPagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HostedPagesApiFp(configuration)
    return {
        /**
         * Used to initiate a payment request using Yapily Hosted Pages.
         * @summary Create Hosted payment request
         * @param {CreateHostedPaymentRequest} createHostedPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedPaymentRequest(createHostedPaymentRequest: CreateHostedPaymentRequest, options?: any): AxiosPromise<ApiResponseOfCreateHostedPaymentRequest> {
            return localVarFp.createHostedPaymentRequest(createHostedPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to created a long lived payment request for Pay By Link
         * @summary Create Pay By Link
         * @param {CreateHostedPaymentRequestLink} createHostedPaymentRequestLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedPaymentRequestLink(createHostedPaymentRequestLink: CreateHostedPaymentRequestLink, options?: any): AxiosPromise<ApiResponseOfCreateHostedPaymentRequestLink> {
            return localVarFp.createHostedPaymentRequestLink(createHostedPaymentRequestLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate a VRP consent / mandate request through Yapily Hosted Pages
         * @summary Create VRP Consent
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {CreateHostedVRPConsentRequest} createHostedVRPConsentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVRPConsentRequest(subApplication: string, createHostedVRPConsentRequest: CreateHostedVRPConsentRequest, options?: any): AxiosPromise<ApiResponseOfCreateHostedVRPConsentRequest> {
            return localVarFp.createHostedVRPConsentRequest(subApplication, createHostedVRPConsentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Check Funds Availability
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVrpFundsConfirmation(consentRequestId: string, consentToken: string, fundsConfirmationRequest: FundsConfirmationRequest, subApplication?: string, options?: any): AxiosPromise<ApiResponseOfFundsConfirmationResponse> {
            return localVarFp.createHostedVrpFundsConfirmation(consentRequestId, consentToken, fundsConfirmationRequest, subApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Variable Recurring Payment
         * @summary Create VRP Payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {CreateHostedVRPPaymentRequest} createHostedVRPPaymentRequest 
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHostedVrpPayment(consentRequestId: string, consentToken: string, createHostedVRPPaymentRequest: CreateHostedVRPPaymentRequest, subApplication?: string, options?: any): AxiosPromise<ApiResponseOfCreateHostedVRPPaymentRequest> {
            return localVarFp.createHostedVrpPayment(consentRequestId, consentToken, createHostedVRPPaymentRequest, subApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get details of a VRP Consent Request
         * @summary Get Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: any): AxiosPromise<ApiResponseOfGetHostedVRPConsentRequest> {
            return localVarFp.getHostedConsentRequest(consentRequestId, subApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get details of a payment request
         * @summary Get Hosted payment request
         * @param {string} paymentRequestId Unique Identifier of the payment request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedPaymentRequest(paymentRequestId: string, options?: any): AxiosPromise<ApiResponseOfGetHostedPaymentRequest> {
            return localVarFp.getHostedPaymentRequest(paymentRequestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get all VRP consent requests initiated through Yapily Hosted Pages
         * @summary Get Hosted VRP Consent Requests
         * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedVRPConsentRequests(subApplication: string, options?: any): AxiosPromise<ApiResponseOfGetHostedVRPConsentsRequest> {
            return localVarFp.getHostedVRPConsentRequests(subApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get details of a VRP Payment
         * @summary Get VRP payment
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} paymentId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHostedVRPPaymentRequest(consentRequestId: string, paymentId: string, subApplication?: string, options?: any): AxiosPromise<ApiResponseOfGetHostedVRPPaymentRequest> {
            return localVarFp.getHostedVRPPaymentRequest(consentRequestId, paymentId, subApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke Hosted VRP Consent Request
         * @summary Revoke Hosted VRP Consent Request
         * @param {string} consentRequestId Unique Identifier of the Consent Request
         * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: any): AxiosPromise<ApiResponseOfRevokeHostedVRPConsentRequest> {
            return localVarFp.revokeHostedConsentRequest(consentRequestId, subApplication, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HostedPagesApi - object-oriented interface
 * @export
 * @class HostedPagesApi
 * @extends {BaseAPI}
 */
export class HostedPagesApi extends BaseAPI {
    /**
     * Used to initiate a payment request using Yapily Hosted Pages.
     * @summary Create Hosted payment request
     * @param {CreateHostedPaymentRequest} createHostedPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public createHostedPaymentRequest(createHostedPaymentRequest: CreateHostedPaymentRequest, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).createHostedPaymentRequest(createHostedPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to created a long lived payment request for Pay By Link
     * @summary Create Pay By Link
     * @param {CreateHostedPaymentRequestLink} createHostedPaymentRequestLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public createHostedPaymentRequestLink(createHostedPaymentRequestLink: CreateHostedPaymentRequestLink, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).createHostedPaymentRequestLink(createHostedPaymentRequestLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate a VRP consent / mandate request through Yapily Hosted Pages
     * @summary Create VRP Consent
     * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {CreateHostedVRPConsentRequest} createHostedVRPConsentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public createHostedVRPConsentRequest(subApplication: string, createHostedVRPConsentRequest: CreateHostedVRPConsentRequest, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).createHostedVRPConsentRequest(subApplication, createHostedVRPConsentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
     * @summary Check Funds Availability
     * @param {string} consentRequestId Unique Identifier of the Consent Request
     * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {FundsConfirmationRequest} fundsConfirmationRequest 
     * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public createHostedVrpFundsConfirmation(consentRequestId: string, consentToken: string, fundsConfirmationRequest: FundsConfirmationRequest, subApplication?: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).createHostedVrpFundsConfirmation(consentRequestId, consentToken, fundsConfirmationRequest, subApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Variable Recurring Payment
     * @summary Create VRP Payment
     * @param {string} consentRequestId Unique Identifier of the Consent Request
     * @param {string} consentToken __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {CreateHostedVRPPaymentRequest} createHostedVRPPaymentRequest 
     * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public createHostedVrpPayment(consentRequestId: string, consentToken: string, createHostedVRPPaymentRequest: CreateHostedVRPPaymentRequest, subApplication?: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).createHostedVrpPayment(consentRequestId, consentToken, createHostedVRPPaymentRequest, subApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get details of a VRP Consent Request
     * @summary Get Hosted VRP Consent Request
     * @param {string} consentRequestId Unique Identifier of the Consent Request
     * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public getHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).getHostedConsentRequest(consentRequestId, subApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get details of a payment request
     * @summary Get Hosted payment request
     * @param {string} paymentRequestId Unique Identifier of the payment request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public getHostedPaymentRequest(paymentRequestId: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).getHostedPaymentRequest(paymentRequestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get all VRP consent requests initiated through Yapily Hosted Pages
     * @summary Get Hosted VRP Consent Requests
     * @param {string} subApplication __Mandatory__. The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public getHostedVRPConsentRequests(subApplication: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).getHostedVRPConsentRequests(subApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get details of a VRP Payment
     * @summary Get VRP payment
     * @param {string} consentRequestId Unique Identifier of the Consent Request
     * @param {string} paymentId Unique Identifier of the Consent Request
     * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public getHostedVRPPaymentRequest(consentRequestId: string, paymentId: string, subApplication?: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).getHostedVRPPaymentRequest(consentRequestId, paymentId, subApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke Hosted VRP Consent Request
     * @summary Revoke Hosted VRP Consent Request
     * @param {string} consentRequestId Unique Identifier of the Consent Request
     * @param {string} [subApplication] The unique identifier of the sub application the request is being submitted on behalf of (e.g. an underlying merchant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostedPagesApi
     */
    public revokeHostedConsentRequest(consentRequestId: string, subApplication?: string, options?: RawAxiosRequestConfig) {
        return HostedPagesApiFp(this.configuration).revokeHostedConsentRequest(consentRequestId, subApplication, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstitutionsApi - axios parameter creator
 * @export
 */
export const InstitutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to retrieve all features available from Yapily. Each `Institution` supports a one, many or all of these features and can be seen in the features field of the `Institution` object.<br><br>Note: Every `Institution` does not necessarily support every feature. To see which features are available for a particular Institution, use either the [Get Institutions](https://docs.yapily.com/api/reference/#operation/getInstitutions) or [Get Institution](https://docs.yapily.com/api/reference/#operation/getInstitution) endpoint and check the features array within the `Institution` payload.
         * @summary Get Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieves details of a specific `Institution` within an application
         * @summary Get Institution
         * @param {string} institutionId __Mandatory__. The Yapily institution Id for the &#x60;Institution&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution: async (institutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionId' is not null or undefined
            assertParamExists('getInstitution', 'institutionId', institutionId)
            const localVarPath = `/institutions/{institutionId}`
                .replace(`{${"institutionId"}}`, encodeURIComponent(String(institutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve all `Institutions` within an application
         * @summary Get Institutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/institutions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstitutionsApi - functional programming interface
 * @export
 */
export const InstitutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstitutionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to retrieve all features available from Yapily. Each `Institution` supports a one, many or all of these features and can be seen in the features field of the `Institution` object.<br><br>Note: Every `Institution` does not necessarily support every feature. To see which features are available for a particular Institution, use either the [Get Institutions](https://docs.yapily.com/api/reference/#operation/getInstitutions) or [Get Institution](https://docs.yapily.com/api/reference/#operation/getInstitution) endpoint and check the features array within the `Institution` payload.
         * @summary Get Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfFeatureDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureDetails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstitutionsApi.getFeatureDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieves details of a specific `Institution` within an application
         * @summary Get Institution
         * @param {string} institutionId __Mandatory__. The Yapily institution Id for the &#x60;Institution&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitution(institutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(institutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstitutionsApi.getInstitution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to retrieve all `Institutions` within an application
         * @summary Get Institutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstitutions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfInstitution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitutions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstitutionsApi.getInstitutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstitutionsApi - factory interface
 * @export
 */
export const InstitutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstitutionsApiFp(configuration)
    return {
        /**
         * Used to retrieve all features available from Yapily. Each `Institution` supports a one, many or all of these features and can be seen in the features field of the `Institution` object.<br><br>Note: Every `Institution` does not necessarily support every feature. To see which features are available for a particular Institution, use either the [Get Institutions](https://docs.yapily.com/api/reference/#operation/getInstitutions) or [Get Institution](https://docs.yapily.com/api/reference/#operation/getInstitution) endpoint and check the features array within the `Institution` payload.
         * @summary Get Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureDetails(options?: any): AxiosPromise<ApiListResponseOfFeatureDetails> {
            return localVarFp.getFeatureDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieves details of a specific `Institution` within an application
         * @summary Get Institution
         * @param {string} institutionId __Mandatory__. The Yapily institution Id for the &#x60;Institution&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitution(institutionId: string, options?: any): AxiosPromise<Institution> {
            return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve all `Institutions` within an application
         * @summary Get Institutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstitutions(options?: any): AxiosPromise<ApiListResponseOfInstitution> {
            return localVarFp.getInstitutions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstitutionsApi - object-oriented interface
 * @export
 * @class InstitutionsApi
 * @extends {BaseAPI}
 */
export class InstitutionsApi extends BaseAPI {
    /**
     * Used to retrieve all features available from Yapily. Each `Institution` supports a one, many or all of these features and can be seen in the features field of the `Institution` object.<br><br>Note: Every `Institution` does not necessarily support every feature. To see which features are available for a particular Institution, use either the [Get Institutions](https://docs.yapily.com/api/reference/#operation/getInstitutions) or [Get Institution](https://docs.yapily.com/api/reference/#operation/getInstitution) endpoint and check the features array within the `Institution` payload.
     * @summary Get Features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public getFeatureDetails(options?: RawAxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).getFeatureDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieves details of a specific `Institution` within an application
     * @summary Get Institution
     * @param {string} institutionId __Mandatory__. The Yapily institution Id for the &#x60;Institution&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public getInstitution(institutionId: string, options?: RawAxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).getInstitution(institutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve all `Institutions` within an application
     * @summary Get Institutions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public getInstitutions(options?: RawAxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).getInstitutions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to subscribe to notifications relating to a specified event type.
         * @summary Create Event Subscription
         * @param {EventSubscriptionRequest} eventSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSubscription: async (eventSubscriptionRequest: EventSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventSubscriptionRequest' is not null or undefined
            assertParamExists('createEventSubscription', 'eventSubscriptionRequest', eventSubscriptionRequest)
            const localVarPath = `/notifications/event-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to unsubscribe to notifications relating to a specified event type.
         * @summary Delete Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSubscriptionById: async (eventTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventTypeId' is not null or undefined
            assertParamExists('deleteEventSubscriptionById', 'eventTypeId', eventTypeId)
            const localVarPath = `/notifications/event-subscriptions/{eventTypeId}`
                .replace(`{${"eventTypeId"}}`, encodeURIComponent(String(eventTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to get details of your subscription to a specified event type.
         * @summary Get Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionById: async (eventTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventTypeId' is not null or undefined
            assertParamExists('getEventSubscriptionById', 'eventTypeId', eventTypeId)
            const localVarPath = `/notifications/event-subscriptions/{eventTypeId}`
                .replace(`{${"eventTypeId"}}`, encodeURIComponent(String(eventTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all event subscriptions that your application is subscribed to
         * @summary Get Event Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/event-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to subscribe to notifications relating to a specified event type.
         * @summary Create Event Subscription
         * @param {EventSubscriptionRequest} eventSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSubscription(eventSubscriptionRequest: EventSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfEventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSubscription(eventSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.createEventSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to unsubscribe to notifications relating to a specified event type.
         * @summary Delete Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSubscriptionById(eventTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfEventSubscriptionDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSubscriptionById(eventTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.deleteEventSubscriptionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to get details of your subscription to a specified event type.
         * @summary Get Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptionById(eventTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfEventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptionById(eventTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.getEventSubscriptionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all event subscriptions that your application is subscribed to
         * @summary Get Event Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSubscriptions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfEventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSubscriptions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.getEventSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Used to subscribe to notifications relating to a specified event type.
         * @summary Create Event Subscription
         * @param {EventSubscriptionRequest} eventSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSubscription(eventSubscriptionRequest: EventSubscriptionRequest, options?: any): AxiosPromise<ApiResponseOfEventSubscriptionResponse> {
            return localVarFp.createEventSubscription(eventSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to unsubscribe to notifications relating to a specified event type.
         * @summary Delete Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSubscriptionById(eventTypeId: string, options?: any): AxiosPromise<ApiResponseOfEventSubscriptionDeleteResponse> {
            return localVarFp.deleteEventSubscriptionById(eventTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to get details of your subscription to a specified event type.
         * @summary Get Event Subscription
         * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionById(eventTypeId: string, options?: any): AxiosPromise<ApiResponseOfEventSubscriptionResponse> {
            return localVarFp.getEventSubscriptionById(eventTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all event subscriptions that your application is subscribed to
         * @summary Get Event Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(options?: any): AxiosPromise<ApiListResponseOfEventSubscriptionResponse> {
            return localVarFp.getEventSubscriptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Used to subscribe to notifications relating to a specified event type.
     * @summary Create Event Subscription
     * @param {EventSubscriptionRequest} eventSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createEventSubscription(eventSubscriptionRequest: EventSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createEventSubscription(eventSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to unsubscribe to notifications relating to a specified event type.
     * @summary Delete Event Subscription
     * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteEventSubscriptionById(eventTypeId: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteEventSubscriptionById(eventTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to get details of your subscription to a specified event type.
     * @summary Get Event Subscription
     * @param {string} eventTypeId Unique identifier of the event type (for which notifications will be sent). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getEventSubscriptionById(eventTypeId: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getEventSubscriptionById(eventTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all event subscriptions that your application is subscribed to
     * @summary Get Event Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getEventSubscriptions(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getEventSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a bulk payment after obtaining the user\'s authorisation. <br><br>Feature: `CREATE_BULK_PAYMENT`
         * @summary Create Bulk Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {BulkPaymentRequest} bulkPaymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkPayment: async (consent: string, bulkPaymentRequest: BulkPaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('createBulkPayment', 'consent', consent)
            // verify required parameter 'bulkPaymentRequest' is not null or undefined
            assertParamExists('createBulkPayment', 'bulkPaymentRequest', bulkPaymentRequest)
            const localVarPath = `/bulk-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`CREATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`CREATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`CREATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentRequest} paymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (consent: string, paymentRequest: PaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('createPayment', 'consent', consent)
            // verify required parameter 'paymentRequest' is not null or undefined
            assertParamExists('createPayment', 'paymentRequest', paymentRequest)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a payment. <br><br>Most commonly used to check for payment status updates. <br><br>Feature: `EXISTING_PAYMENTS_DETAILS`
         * @summary Get Payment Details
         * @param {string} paymentId __Mandatory__. The payment Id of the payment.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: async (paymentId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayments', 'paymentId', paymentId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getPayments', 'consent', consent)
            const localVarPath = `/payments/{paymentId}/details`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }

            if (psuId != null) {
                localVarHeaderParameter['psu-id'] = String(psuId);
            }

            if (psuCorporateId != null) {
                localVarHeaderParameter['psu-corporate-id'] = String(psuCorporateId);
            }

            if (psuIpAddress != null) {
                localVarHeaderParameter['psu-ip-address'] = String(psuIpAddress);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a bulk payment after obtaining the user\'s authorisation. <br><br>Feature: `CREATE_BULK_PAYMENT`
         * @summary Create Bulk Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {BulkPaymentRequest} bulkPaymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBulkPayment(consent: string, bulkPaymentRequest: BulkPaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBulkPayment(consent, bulkPaymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.createBulkPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`CREATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`CREATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`CREATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentRequest} paymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(consent: string, paymentRequest: PaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(consent, paymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.createPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of a payment. <br><br>Most commonly used to check for payment status updates. <br><br>Feature: `EXISTING_PAYMENTS_DETAILS`
         * @summary Get Payment Details
         * @param {string} paymentId __Mandatory__. The payment Id of the payment.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayments(paymentId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfPaymentResponses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayments(paymentId, consent, psuId, psuCorporateId, psuIpAddress, raw, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Creates a bulk payment after obtaining the user\'s authorisation. <br><br>Feature: `CREATE_BULK_PAYMENT`
         * @summary Create Bulk Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {BulkPaymentRequest} bulkPaymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkPayment(consent: string, bulkPaymentRequest: BulkPaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentResponse> {
            return localVarFp.createBulkPayment(consent, bulkPaymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`CREATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`CREATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`CREATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
         * @summary Create Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {PaymentRequest} paymentRequest 
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(consent: string, paymentRequest: PaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentResponse> {
            return localVarFp.createPayment(consent, paymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a payment. <br><br>Most commonly used to check for payment status updates. <br><br>Feature: `EXISTING_PAYMENTS_DETAILS`
         * @summary Get Payment Details
         * @param {string} paymentId __Mandatory__. The payment Id of the payment.
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
         * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(paymentId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: any): AxiosPromise<ApiResponseOfPaymentResponses> {
            return localVarFp.getPayments(paymentId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Creates a bulk payment after obtaining the user\'s authorisation. <br><br>Feature: `CREATE_BULK_PAYMENT`
     * @summary Create Bulk Payment
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {BulkPaymentRequest} bulkPaymentRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createBulkPayment(consent: string, bulkPaymentRequest: BulkPaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createBulkPayment(consent, bulkPaymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`CREATE_DOMESTIC_PERIODIC_PAYMENT`</li><li>`CREATE_DOMESTIC_SCHEDULED_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_INSTANT_PAYMENT`</li><li>`CREATE_DOMESTIC_SINGLE_PAYMENT`</li><li>`CREATE_INTERNATIONAL_PERIODIC_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SCHEDULED_PAYMENT`</li><li>`CREATE_INTERNATIONAL_SINGLE_PAYMENT`</li></ul>
     * @summary Create Payment
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {PaymentRequest} paymentRequest 
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(consent: string, paymentRequest: PaymentRequest, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(consent, paymentRequest, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of a payment. <br><br>Most commonly used to check for payment status updates. <br><br>Feature: `EXISTING_PAYMENTS_DETAILS`
     * @summary Get Payment Details
     * @param {string} paymentId __Mandatory__. The payment Id of the payment.
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {string} [psuId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a personal account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuCorporateId] __Conditional__. Represents the user\&#39;s login ID for the &#x60;Institution&#x60; to a business account. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {string} [psuIpAddress] __Conditional__. The IP address of the PSU. &lt;br&gt;&lt;br&gt;See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
     * @param {boolean} [raw] __Optional__. Used to obtain the raw request and response to and from the &lt;code&gt;Institution&lt;/code&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayments(paymentId: string, consent: string, psuId?: string, psuCorporateId?: string, psuIpAddress?: string, raw?: boolean, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayments(paymentId, consent, psuId, psuCorporateId, psuIpAddress, raw, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user in your application
         * @summary Create User
         * @param {NewApplicationUser} newApplicationUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (newApplicationUser: NewApplicationUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newApplicationUser' is not null or undefined
            assertParamExists('addUser', 'newApplicationUser', newApplicationUser)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newApplicationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from your application along with any sub-resources (including consent resources on institution APIs if they exist)
         * @summary Delete User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('deleteUser', 'userUuid', userUuid)
            const localVarPath = `/users/{userUuid}`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user using the user UUID
         * @summary Get User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUuid' is not null or undefined
            assertParamExists('getUser', 'userUuid', userUuid)
            const localVarPath = `/users/{userUuid}`
                .replace(`{${"userUuid"}}`, encodeURIComponent(String(userUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the users configured in your application
         * @summary Get Users
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (filterApplicationUserId?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (filterApplicationUserId) {
                localVarQueryParameter['filter[applicationUserId]'] = Array.from(filterApplicationUserId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user in your application
         * @summary Create User
         * @param {NewApplicationUser} newApplicationUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(newApplicationUser: NewApplicationUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(newApplicationUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user from your application along with any sub-resources (including consent resources on institution APIs if they exist)
         * @summary Delete User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfUserDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific user using the user UUID
         * @summary Get User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the users configured in your application
         * @summary Get Users
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(filterApplicationUserId?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(filterApplicationUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user in your application
         * @summary Create User
         * @param {NewApplicationUser} newApplicationUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(newApplicationUser: NewApplicationUser, options?: any): AxiosPromise<ApplicationUser> {
            return localVarFp.addUser(newApplicationUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user from your application along with any sub-resources (including consent resources on institution APIs if they exist)
         * @summary Delete User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userUuid: string, options?: any): AxiosPromise<ApiResponseOfUserDeleteResponse> {
            return localVarFp.deleteUser(userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific user using the user UUID
         * @summary Get User
         * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userUuid: string, options?: any): AxiosPromise<ApplicationUser> {
            return localVarFp.getUser(userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the users configured in your application
         * @summary Get Users
         * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(filterApplicationUserId?: Set<string>, options?: any): AxiosPromise<Array<ApplicationUser>> {
            return localVarFp.getUsers(filterApplicationUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user in your application
     * @summary Create User
     * @param {NewApplicationUser} newApplicationUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(newApplicationUser: NewApplicationUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUser(newApplicationUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user from your application along with any sub-resources (including consent resources on institution APIs if they exist)
     * @summary Delete User
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userUuid: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific user using the user UUID
     * @summary Get User
     * @param {string} userUuid __Mandatory__. The Yapily generated UUID for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userUuid: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the users configured in your application
     * @summary Get Users
     * @param {Set<string>} [filterApplicationUserId] __Optional__. Filter records based on the list of &#x60;applicationUserId&#x60; users provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(filterApplicationUserId?: Set<string>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(filterApplicationUserId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariableRecurringPaymentsApi - axios parameter creator
 * @export
 */
export const VariableRecurringPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Non-Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Non-Sweeping Variable Recurring Payment Authorisation
         * @param {NonSweepingAuthorisationRequest} nonSweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonSweepingAuthorisation: async (nonSweepingAuthorisationRequest: NonSweepingAuthorisationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonSweepingAuthorisationRequest' is not null or undefined
            assertParamExists('createNonSweepingAuthorisation', 'nonSweepingAuthorisationRequest', nonSweepingAuthorisationRequest)
            const localVarPath = `/variable-recurring-payments/non-sweeping/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonSweepingAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li></ul>
         * @summary Create Sweeping Variable Recurring Payment Authorisation
         * @param {SweepingAuthorisationRequest} sweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSweepingAuthorisation: async (sweepingAuthorisationRequest: SweepingAuthorisationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sweepingAuthorisationRequest' is not null or undefined
            assertParamExists('createSweepingAuthorisation', 'sweepingAuthorisationRequest', sweepingAuthorisationRequest)
            const localVarPath = `/variable-recurring-payments/sweeping/consents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sweepingAuthorisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Confirm Funds for Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVrpFundsConfirmation: async (consent: string, fundsConfirmationRequest: FundsConfirmationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('createVrpFundsConfirmation', 'consent', consent)
            // verify required parameter 'fundsConfirmationRequest' is not null or undefined
            assertParamExists('createVrpFundsConfirmation', 'fundsConfirmationRequest', fundsConfirmationRequest)
            const localVarPath = `/variable-recurring-payments/funds-confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundsConfirmationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Variable Recurring Payment transaction after obtaining the user\'s authorisation.<br><br>Features:<ul><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {SubmissionRequest} submissionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVrpPayment: async (consent: string, submissionRequest: SubmissionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('createVrpPayment', 'consent', consent)
            // verify required parameter 'submissionRequest' is not null or undefined
            assertParamExists('createVrpPayment', 'submissionRequest', submissionRequest)
            const localVarPath = `/variable-recurring-payments/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submissionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Non-Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Non-Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSweepingVrpConsentById: async (consentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getNonSweepingVrpConsentById', 'consentId', consentId)
            const localVarPath = `/variable-recurring-payments/non-sweeping/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSweepingVrpConsentById: async (consentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consentId' is not null or undefined
            assertParamExists('getSweepingVrpConsentById', 'consentId', consentId)
            const localVarPath = `/variable-recurring-payments/sweeping/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Variable Recurring Payment details using the Payment Id
         * @summary Get Variable Recurring Payment Details
         * @param {string} paymentId __Mandatory__. The Payment Id of the &#x60;Variable Recurring Payments&#x60; to retrieve.
         * @param {string} consent __Mandatory__. The consent token containing the user\&#39;s authorisation to make the &#x60;Variable Recurring Payments&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVrpPaymentDetails: async (paymentId: string, consent: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getVrpPaymentDetails', 'paymentId', paymentId)
            // verify required parameter 'consent' is not null or undefined
            assertParamExists('getVrpPaymentDetails', 'consent', consent)
            const localVarPath = `/variable-recurring-payments/payments/{paymentId}/details`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (consent != null) {
                localVarHeaderParameter['consent'] = String(consent);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableRecurringPaymentsApi - functional programming interface
 * @export
 */
export const VariableRecurringPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableRecurringPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Non-Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Non-Sweeping Variable Recurring Payment Authorisation
         * @param {NonSweepingAuthorisationRequest} nonSweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNonSweepingAuthorisation(nonSweepingAuthorisationRequest: NonSweepingAuthorisationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfNonSweepingAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNonSweepingAuthorisation(nonSweepingAuthorisationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.createNonSweepingAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li></ul>
         * @summary Create Sweeping Variable Recurring Payment Authorisation
         * @param {SweepingAuthorisationRequest} sweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSweepingAuthorisation(sweepingAuthorisationRequest: SweepingAuthorisationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfSweepingAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSweepingAuthorisation(sweepingAuthorisationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.createSweepingAuthorisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Confirm Funds for Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVrpFundsConfirmation(consent: string, fundsConfirmationRequest: FundsConfirmationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfFundsConfirmationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVrpFundsConfirmation(consent, fundsConfirmationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.createVrpFundsConfirmation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Variable Recurring Payment transaction after obtaining the user\'s authorisation.<br><br>Features:<ul><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {SubmissionRequest} submissionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVrpPayment(consent: string, submissionRequest: SubmissionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVrpPayment(consent, submissionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.createVrpPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Non-Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Non-Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNonSweepingVrpConsentById(consentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfNonSweepingAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonSweepingVrpConsentById(consentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.getNonSweepingVrpConsentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSweepingVrpConsentById(consentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfSweepingAuthorisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSweepingVrpConsentById(consentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.getSweepingVrpConsentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Variable Recurring Payment details using the Payment Id
         * @summary Get Variable Recurring Payment Details
         * @param {string} paymentId __Mandatory__. The Payment Id of the &#x60;Variable Recurring Payments&#x60; to retrieve.
         * @param {string} consent __Mandatory__. The consent token containing the user\&#39;s authorisation to make the &#x60;Variable Recurring Payments&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVrpPaymentDetails(paymentId: string, consent: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVrpPaymentDetails(paymentId, consent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableRecurringPaymentsApi.getVrpPaymentDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariableRecurringPaymentsApi - factory interface
 * @export
 */
export const VariableRecurringPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableRecurringPaymentsApiFp(configuration)
    return {
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Non-Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Non-Sweeping Variable Recurring Payment Authorisation
         * @param {NonSweepingAuthorisationRequest} nonSweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonSweepingAuthorisation(nonSweepingAuthorisationRequest: NonSweepingAuthorisationRequest, options?: any): AxiosPromise<ApiResponseOfNonSweepingAuthorisationResponse> {
            return localVarFp.createNonSweepingAuthorisation(nonSweepingAuthorisationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li></ul>
         * @summary Create Sweeping Variable Recurring Payment Authorisation
         * @param {SweepingAuthorisationRequest} sweepingAuthorisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSweepingAuthorisation(sweepingAuthorisationRequest: SweepingAuthorisationRequest, options?: any): AxiosPromise<ApiResponseOfSweepingAuthorisationResponse> {
            return localVarFp.createSweepingAuthorisation(sweepingAuthorisationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
         * @summary Confirm Funds for Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {FundsConfirmationRequest} fundsConfirmationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVrpFundsConfirmation(consent: string, fundsConfirmationRequest: FundsConfirmationRequest, options?: any): AxiosPromise<ApiResponseOfFundsConfirmationResponse> {
            return localVarFp.createVrpFundsConfirmation(consent, fundsConfirmationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Variable Recurring Payment transaction after obtaining the user\'s authorisation.<br><br>Features:<ul><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
         * @summary Create Variable Recurring Payment
         * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
         * @param {SubmissionRequest} submissionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVrpPayment(consent: string, submissionRequest: SubmissionRequest, options?: any): AxiosPromise<ApiResponseOfSubmissionResponse> {
            return localVarFp.createVrpPayment(consent, submissionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Non-Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Non-Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSweepingVrpConsentById(consentId: string, options?: any): AxiosPromise<ApiResponseOfNonSweepingAuthorisationResponse> {
            return localVarFp.getNonSweepingVrpConsentById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Sweeping Variable Recurring Payments consent details using the consent Id
         * @summary Get Sweeping Variable Recurring Payment Consent Details
         * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSweepingVrpConsentById(consentId: string, options?: any): AxiosPromise<ApiResponseOfSweepingAuthorisationResponse> {
            return localVarFp.getSweepingVrpConsentById(consentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Variable Recurring Payment details using the Payment Id
         * @summary Get Variable Recurring Payment Details
         * @param {string} paymentId __Mandatory__. The Payment Id of the &#x60;Variable Recurring Payments&#x60; to retrieve.
         * @param {string} consent __Mandatory__. The consent token containing the user\&#39;s authorisation to make the &#x60;Variable Recurring Payments&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVrpPaymentDetails(paymentId: string, consent: string, options?: any): AxiosPromise<ApiResponseOfSubmissionResponse> {
            return localVarFp.getVrpPaymentDetails(paymentId, consent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariableRecurringPaymentsApi - object-oriented interface
 * @export
 * @class VariableRecurringPaymentsApi
 * @extends {BaseAPI}
 */
export class VariableRecurringPaymentsApi extends BaseAPI {
    /**
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Non-Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
     * @summary Create Non-Sweeping Variable Recurring Payment Authorisation
     * @param {NonSweepingAuthorisationRequest} nonSweepingAuthorisationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public createNonSweepingAuthorisation(nonSweepingAuthorisationRequest: NonSweepingAuthorisationRequest, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).createNonSweepingAuthorisation(nonSweepingAuthorisationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to initiate the authorisation process and direct users to the login screen of their financial Institution in order to give their consent for Sweeping Variable Recurring Payments. The request would return an Authorization URL and an Identifier for the consent created at the Institution. First make sure that the payment feature you wish to execute is supported by the bank by checking the features array in [GET Institution](https://docs.yapily.com/api/#get-institution). <br><br>See [Redirect Payment Flows](https://docs.yapily.com/guides/payments/payment-authorisation-flows/redirect/) for more information about this flow.<br><br>Features:<ul><li>`INITIATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li></ul>
     * @summary Create Sweeping Variable Recurring Payment Authorisation
     * @param {SweepingAuthorisationRequest} sweepingAuthorisationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public createSweepingAuthorisation(sweepingAuthorisationRequest: SweepingAuthorisationRequest, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).createSweepingAuthorisation(sweepingAuthorisationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms whether there are available funds on the Payer account to execute a Variable Recurring Payment after obtaining the user\'s authorisation. <br><br>Features:<ul><li>`VARIABLE_RECURRING_PAYMENT_FUNDS_CONFIRMATION`</li></ul>
     * @summary Confirm Funds for Variable Recurring Payment
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {FundsConfirmationRequest} fundsConfirmationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public createVrpFundsConfirmation(consent: string, fundsConfirmationRequest: FundsConfirmationRequest, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).createVrpFundsConfirmation(consent, fundsConfirmationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Variable Recurring Payment transaction after obtaining the user\'s authorisation.<br><br>Features:<ul><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_SWEEPING`</li><li>`CREATE_DOMESTIC_VARIABLE_RECURRING_PAYMENT_NONSWEEPING`</li></ul>
     * @summary Create Variable Recurring Payment
     * @param {string} consent __Mandatory__. The &#x60;consent-token&#x60; containing the user\&#39;s authorisation to make the request.
     * @param {SubmissionRequest} submissionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public createVrpPayment(consent: string, submissionRequest: SubmissionRequest, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).createVrpPayment(consent, submissionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Non-Sweeping Variable Recurring Payments consent details using the consent Id
     * @summary Get Non-Sweeping Variable Recurring Payment Consent Details
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public getNonSweepingVrpConsentById(consentId: string, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).getNonSweepingVrpConsentById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Sweeping Variable Recurring Payments consent details using the consent Id
     * @summary Get Sweeping Variable Recurring Payment Consent Details
     * @param {string} consentId __Mandatory__. The consent Id of the &#x60;Variable Recurring Payments Consent&#x60; to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public getSweepingVrpConsentById(consentId: string, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).getSweepingVrpConsentById(consentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Variable Recurring Payment details using the Payment Id
     * @summary Get Variable Recurring Payment Details
     * @param {string} paymentId __Mandatory__. The Payment Id of the &#x60;Variable Recurring Payments&#x60; to retrieve.
     * @param {string} consent __Mandatory__. The consent token containing the user\&#39;s authorisation to make the &#x60;Variable Recurring Payments&#x60; request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableRecurringPaymentsApi
     */
    public getVrpPaymentDetails(paymentId: string, consent: string, options?: RawAxiosRequestConfig) {
        return VariableRecurringPaymentsApiFp(this.configuration).getVrpPaymentDetails(paymentId, consent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount: async (clientId: string, virtualAccountRequest: VirtualAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccount', 'clientId', clientId)
            // verify required parameter 'virtualAccountRequest' is not null or undefined
            assertParamExists('createVirtualAccount', 'virtualAccountRequest', virtualAccountRequest)
            const localVarPath = `/virtual-accounts/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountBeneficiary: async (clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountBeneficiary', 'clientId', clientId)
            // verify required parameter 'virtualAccountBeneficiaryRequest' is not null or undefined
            assertParamExists('createVirtualAccountBeneficiary', 'virtualAccountBeneficiaryRequest', virtualAccountBeneficiaryRequest)
            const localVarPath = `/virtual-accounts/beneficiaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountBeneficiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountClient: async (clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountClient', 'clientId', clientId)
            // verify required parameter 'virtualAccountClientRequest' is not null or undefined
            assertParamExists('createVirtualAccountClient', 'virtualAccountClientRequest', virtualAccountClientRequest)
            const localVarPath = `/virtual-accounts/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountPayOut: async (idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'clientId', clientId)
            // verify required parameter 'virtualAccountPayOutRequest' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'virtualAccountPayOutRequest', virtualAccountPayOutRequest)
            const localVarPath = `/virtual-accounts/payments/pay-outs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountPayOutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountRefund: async (idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'clientId', clientId)
            // verify required parameter 'virtualAccountRefundRequest' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'virtualAccountRefundRequest', virtualAccountRefundRequest)
            const localVarPath = `/virtual-accounts/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountTransfer: async (idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'clientId', clientId)
            // verify required parameter 'virtualAccountTransferRequest' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'virtualAccountTransferRequest', virtualAccountTransferRequest)
            const localVarPath = `/virtual-accounts/payments/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualAccountBeneficiary: async (beneficiaryId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('deleteVirtualAccountBeneficiary', 'beneficiaryId', beneficiaryId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteVirtualAccountBeneficiary', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayInDetails: async (paymentId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayInDetails', 'paymentId', paymentId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getPayInDetails', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments/{paymentId}/pay-in-details`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsById: async (id: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentsById', 'id', id)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getPaymentsById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiaries: async (clientId: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiaries', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiary: async (beneficiaryId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiary', 'beneficiaryId', beneficiaryId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiary', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountById: async (accountId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getVirtualAccountById', 'accountId', accountId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClientById: async (clientId: string, clientId2: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountClientById', 'clientId', clientId)
            // verify required parameter 'clientId2' is not null or undefined
            assertParamExists('getVirtualAccountClientById', 'clientId2', clientId2)
            const localVarPath = `/virtual-accounts/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId2 != null) {
                localVarHeaderParameter['client-id'] = String(clientId2);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClients: async (clientId: string, type?: string, status?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountClients', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountPayments: async (clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountPayments', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (createdDateTimeFrom !== undefined) {
                localVarQueryParameter['createdDateTimeFrom'] = (createdDateTimeFrom as any instanceof Date) ?
                    (createdDateTimeFrom as any).toISOString() :
                    createdDateTimeFrom;
            }

            if (createdDateTimeTo !== undefined) {
                localVarQueryParameter['createdDateTimeTo'] = (createdDateTimeTo as any instanceof Date) ?
                    (createdDateTimeTo as any).toISOString() :
                    createdDateTimeTo;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefundById: async (id: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVirtualAccountRefundById', 'id', id)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountRefundById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/refunds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefunds: async (clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountRefunds', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (paymentInitiationId !== undefined) {
                localVarQueryParameter['paymentInitiationId'] = paymentInitiationId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdDateTimeAfter !== undefined) {
                localVarQueryParameter['createdDateTimeAfter'] = (createdDateTimeAfter as any instanceof Date) ?
                    (createdDateTimeAfter as any).toISOString() :
                    createdDateTimeAfter;
            }

            if (createdDateTimeBefore !== undefined) {
                localVarQueryParameter['createdDateTimeBefore'] = (createdDateTimeBefore as any instanceof Date) ?
                    (createdDateTimeBefore as any).toISOString() :
                    createdDateTimeBefore;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccounts: async (clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccounts', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (nickname !== undefined) {
                localVarQueryParameter['nickname'] = nickname;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualAccountById: async (accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'accountId', accountId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'clientId', clientId)
            // verify required parameter 'updateVirtualAccountRequest' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'updateVirtualAccountRequest', updateVirtualAccountRequest)
            const localVarPath = `/virtual-accounts/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVirtualAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsApi - functional programming interface
 * @export
 */
export const VirtualAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccount(clientId, virtualAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountClient(clientId, virtualAccountClientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccountClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccountPayOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccountRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.createVirtualAccountTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.deleteVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayInDetails(paymentId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayInDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayInDetails(paymentId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getPayInDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsById(id: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsById(id, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getPaymentsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountBeneficiaries(clientId, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountBeneficiaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountBeneficiary(beneficiaryId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountById(accountId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountById(accountId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountClientById(clientId: string, clientId2: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountClientById(clientId, clientId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountClients(clientId, type, status, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountRefundById(id: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountRefundById(id, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountRefundById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccountRefunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccounts(clientId, nickname, currency, status, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.getVirtualAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsApi.updateVirtualAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsApi - factory interface
 * @export
 */
export const VirtualAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsApiFp(configuration)
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.createVirtualAccount(clientId, virtualAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountBeneficiary> {
            return localVarFp.createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountClient> {
            return localVarFp.createVirtualAccountClient(clientId, virtualAccountClientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountRefund> {
            return localVarFp.createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayInDetails(paymentId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayInDetails> {
            return localVarFp.getPayInDetails(paymentId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsById(id: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.getPaymentsById(id, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountBeneficiary> {
            return localVarFp.getVirtualAccountBeneficiaries(clientId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountBeneficiary> {
            return localVarFp.getVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountById(accountId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.getVirtualAccountById(accountId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClientById(clientId: string, clientId2: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountClient> {
            return localVarFp.getVirtualAccountClientById(clientId, clientId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountClient> {
            return localVarFp.getVirtualAccountClients(clientId, type, status, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountPayment> {
            return localVarFp.getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefundById(id: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountRefund> {
            return localVarFp.getVirtualAccountRefundById(id, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountRefund> {
            return localVarFp.getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccount> {
            return localVarFp.getVirtualAccounts(clientId, nickname, currency, status, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsApi - object-oriented interface
 * @export
 * @class VirtualAccountsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsApi extends BaseAPI {
    /**
     * Create a new virtual account
     * @summary Create Account
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountRequest} virtualAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccount(clientId, virtualAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
     * @summary Create Beneficiary
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
     * @summary Create Virtual Account Client
     * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccountClient(clientId, virtualAccountClientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
     * @summary Create Pay Out
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
     * @summary Create Refund
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a transfer between two virtual accounts
     * @summary Create Virtual Account Transfer
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific beneficiary (individual or business account)
     * @summary Delete Beneficiary
     * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a pay-in transaction
     * @summary Get Pay-In Details
     * @param {string} paymentId Uniquely identifies a transaction
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getPayInDetails(paymentId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getPayInDetails(paymentId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific payment using its Id
     * @summary Get Payment
     * @param {string} id __Mandatory__. The id of the payment
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getPaymentsById(id: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getPaymentsById(id, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
     * @summary Get List Of Beneficiaries
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountBeneficiaries(clientId, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
     * @summary Get Beneficiary
     * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific account using its Id
     * @summary Get Account
     * @param {string} accountId __Mandatory__. The Id of the account.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountById(accountId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountById(accountId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
     * @summary Get a Virtual Account Client by ID
     * @param {string} clientId __Mandatory__. The ID of the client.
     * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountClientById(clientId: string, clientId2: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountClientById(clientId, clientId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Virtual Account Clients (individual or business client).
     * @summary Get List of Virtual Account Clients
     * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
     * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountClients(clientId, type, status, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of virtual account payments
     * @summary Get Payments
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [accountId] __Optional__. Filter payments based on accountId
     * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
     * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
     * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
     * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a refund by its ID
     * @summary Get Refund By Id
     * @param {string} id __Mandatory__. The id of the refund
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountRefundById(id: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountRefundById(id, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of refunds
     * @summary Get list of refunds
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
     * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
     * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
     * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
     * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all virtual accounts held
     * @summary Get Accounts
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
     * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
     * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).getVirtualAccounts(clientId, nickname, currency, status, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific account using its Id
     * @summary Update Account
     * @param {string} accountId __Mandatory__. The Id of the account.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsApi
     */
    public updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsApiFp(this.configuration).updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsAccountsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount: async (clientId: string, virtualAccountRequest: VirtualAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccount', 'clientId', clientId)
            // verify required parameter 'virtualAccountRequest' is not null or undefined
            assertParamExists('createVirtualAccount', 'virtualAccountRequest', virtualAccountRequest)
            const localVarPath = `/virtual-accounts/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountById: async (accountId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getVirtualAccountById', 'accountId', accountId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccounts: async (clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccounts', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (nickname !== undefined) {
                localVarQueryParameter['nickname'] = nickname;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualAccountById: async (accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'accountId', accountId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'clientId', clientId)
            // verify required parameter 'updateVirtualAccountRequest' is not null or undefined
            assertParamExists('updateVirtualAccountById', 'updateVirtualAccountRequest', updateVirtualAccountRequest)
            const localVarPath = `/virtual-accounts/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVirtualAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsAccountsApi - functional programming interface
 * @export
 */
export const VirtualAccountsAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccount(clientId, virtualAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsAccountsApi.createVirtualAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountById(accountId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountById(accountId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsAccountsApi.getVirtualAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccounts(clientId, nickname, currency, status, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsAccountsApi.getVirtualAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsAccountsApi.updateVirtualAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsAccountsApi - factory interface
 * @export
 */
export const VirtualAccountsAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsAccountsApiFp(configuration)
    return {
        /**
         * Create a new virtual account
         * @summary Create Account
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRequest} virtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.createVirtualAccount(clientId, virtualAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific account using its Id
         * @summary Get Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountById(accountId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.getVirtualAccountById(accountId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all virtual accounts held
         * @summary Get Accounts
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
         * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
         * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccount> {
            return localVarFp.getVirtualAccounts(clientId, nickname, currency, status, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of a specific account using its Id
         * @summary Update Account
         * @param {string} accountId __Mandatory__. The Id of the account.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccount> {
            return localVarFp.updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsAccountsApi - object-oriented interface
 * @export
 * @class VirtualAccountsAccountsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsAccountsApi extends BaseAPI {
    /**
     * Create a new virtual account
     * @summary Create Account
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountRequest} virtualAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsAccountsApi
     */
    public createVirtualAccount(clientId: string, virtualAccountRequest: VirtualAccountRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsAccountsApiFp(this.configuration).createVirtualAccount(clientId, virtualAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific account using its Id
     * @summary Get Account
     * @param {string} accountId __Mandatory__. The Id of the account.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsAccountsApi
     */
    public getVirtualAccountById(accountId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsAccountsApiFp(this.configuration).getVirtualAccountById(accountId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all virtual accounts held
     * @summary Get Accounts
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [nickname] __Optional__. Filter accounts based on reference provided in order to help with identification of the account
     * @param {string} [currency] __Optional__. Filter accounts based on three-letter ISO 4217 currency code
     * @param {string} [status] __Optional__. Filter accounts based on their current state. One of PENDING, ACTIVE, FAILED, SUSPENDED or CLOSED
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsAccountsApi
     */
    public getVirtualAccounts(clientId: string, nickname?: string, currency?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsAccountsApiFp(this.configuration).getVirtualAccounts(clientId, nickname, currency, status, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of a specific account using its Id
     * @summary Update Account
     * @param {string} accountId __Mandatory__. The Id of the account.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {UpdateVirtualAccountRequest} updateVirtualAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsAccountsApi
     */
    public updateVirtualAccountById(accountId: string, clientId: string, updateVirtualAccountRequest: UpdateVirtualAccountRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsAccountsApiFp(this.configuration).updateVirtualAccountById(accountId, clientId, updateVirtualAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsBeneficiariesApi - axios parameter creator
 * @export
 */
export const VirtualAccountsBeneficiariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountBeneficiary: async (clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountBeneficiary', 'clientId', clientId)
            // verify required parameter 'virtualAccountBeneficiaryRequest' is not null or undefined
            assertParamExists('createVirtualAccountBeneficiary', 'virtualAccountBeneficiaryRequest', virtualAccountBeneficiaryRequest)
            const localVarPath = `/virtual-accounts/beneficiaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountBeneficiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualAccountBeneficiary: async (beneficiaryId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('deleteVirtualAccountBeneficiary', 'beneficiaryId', beneficiaryId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteVirtualAccountBeneficiary', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiaries: async (clientId: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiaries', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiary: async (beneficiaryId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'beneficiaryId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiary', 'beneficiaryId', beneficiaryId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountBeneficiary', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/beneficiaries/{beneficiaryId}`
                .replace(`{${"beneficiaryId"}}`, encodeURIComponent(String(beneficiaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsBeneficiariesApi - functional programming interface
 * @export
 */
export const VirtualAccountsBeneficiariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsBeneficiariesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsBeneficiariesApi.createVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsBeneficiariesApi.deleteVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountBeneficiaries(clientId, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsBeneficiariesApi.getVirtualAccountBeneficiaries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountBeneficiary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountBeneficiary(beneficiaryId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsBeneficiariesApi.getVirtualAccountBeneficiary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsBeneficiariesApi - factory interface
 * @export
 */
export const VirtualAccountsBeneficiariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsBeneficiariesApiFp(configuration)
    return {
        /**
         * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
         * @summary Create Beneficiary
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountBeneficiary> {
            return localVarFp.createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific beneficiary (individual or business account)
         * @summary Delete Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
         * @summary Get List Of Beneficiaries
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountBeneficiary> {
            return localVarFp.getVirtualAccountBeneficiaries(clientId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
         * @summary Get Beneficiary
         * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountBeneficiary> {
            return localVarFp.getVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsBeneficiariesApi - object-oriented interface
 * @export
 * @class VirtualAccountsBeneficiariesApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsBeneficiariesApi extends BaseAPI {
    /**
     * Create a new beneficiary (individual or business account) to which a Pay Out can be made. The beneficiary can be used from any virtual account that is held
     * @summary Create Beneficiary
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountBeneficiaryRequest} virtualAccountBeneficiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsBeneficiariesApi
     */
    public createVirtualAccountBeneficiary(clientId: string, virtualAccountBeneficiaryRequest: VirtualAccountBeneficiaryRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsBeneficiariesApiFp(this.configuration).createVirtualAccountBeneficiary(clientId, virtualAccountBeneficiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific beneficiary (individual or business account)
     * @summary Delete Beneficiary
     * @param {string} beneficiaryId __Mandatory__. The Id of the beneficiary that will be deleted
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsBeneficiariesApi
     */
    public deleteVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsBeneficiariesApiFp(this.configuration).deleteVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the list of beneficiaries (individual or business account) to which a Pay Out can be made.
     * @summary Get List Of Beneficiaries
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsBeneficiariesApi
     */
    public getVirtualAccountBeneficiaries(clientId: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsBeneficiariesApiFp(this.configuration).getVirtualAccountBeneficiaries(clientId, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific beneficiary (individual or business account) to which a Pay Out can be made from its id.
     * @summary Get Beneficiary
     * @param {string} beneficiaryId __Mandatory__. The Id of the requested beneficiary.
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsBeneficiariesApi
     */
    public getVirtualAccountBeneficiary(beneficiaryId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsBeneficiariesApiFp(this.configuration).getVirtualAccountBeneficiary(beneficiaryId, clientId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsClientsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountClient: async (clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountClient', 'clientId', clientId)
            // verify required parameter 'virtualAccountClientRequest' is not null or undefined
            assertParamExists('createVirtualAccountClient', 'virtualAccountClientRequest', virtualAccountClientRequest)
            const localVarPath = `/virtual-accounts/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClientById: async (clientId: string, clientId2: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountClientById', 'clientId', clientId)
            // verify required parameter 'clientId2' is not null or undefined
            assertParamExists('getVirtualAccountClientById', 'clientId2', clientId2)
            const localVarPath = `/virtual-accounts/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId2 != null) {
                localVarHeaderParameter['client-id'] = String(clientId2);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClients: async (clientId: string, type?: string, status?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountClients', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsClientsApi - functional programming interface
 * @export
 */
export const VirtualAccountsClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountClient(clientId, virtualAccountClientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsClientsApi.createVirtualAccountClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountClientById(clientId: string, clientId2: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountClientById(clientId, clientId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsClientsApi.getVirtualAccountClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountClients(clientId, type, status, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsClientsApi.getVirtualAccountClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsClientsApi - factory interface
 * @export
 */
export const VirtualAccountsClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsClientsApiFp(configuration)
    return {
        /**
         * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
         * @summary Create Virtual Account Client
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountClient> {
            return localVarFp.createVirtualAccountClient(clientId, virtualAccountClientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
         * @summary Get a Virtual Account Client by ID
         * @param {string} clientId __Mandatory__. The ID of the client.
         * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClientById(clientId: string, clientId2: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountClient> {
            return localVarFp.getVirtualAccountClientById(clientId, clientId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Virtual Account Clients (individual or business client).
         * @summary Get List of Virtual Account Clients
         * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
         * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
         * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountClient> {
            return localVarFp.getVirtualAccountClients(clientId, type, status, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsClientsApi - object-oriented interface
 * @export
 * @class VirtualAccountsClientsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsClientsApi extends BaseAPI {
    /**
     * Create a new virtual account client (individual or business client). Available for clients who have direct onboarding permissions only. Please contact your CSM to enquire about access
     * @summary Create Virtual Account Client
     * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {VirtualAccountClientRequest} virtualAccountClientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsClientsApi
     */
    public createVirtualAccountClient(clientId: string, virtualAccountClientRequest: VirtualAccountClientRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsClientsApiFp(this.configuration).createVirtualAccountClient(clientId, virtualAccountClientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Virtual Account Client using its ID. Restricted to applications with direct onboarding permissions only
     * @summary Get a Virtual Account Client by ID
     * @param {string} clientId __Mandatory__. The ID of the client.
     * @param {string} clientId2 __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsClientsApi
     */
    public getVirtualAccountClientById(clientId: string, clientId2: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsClientsApiFp(this.configuration).getVirtualAccountClientById(clientId, clientId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Virtual Account Clients (individual or business client).
     * @summary Get List of Virtual Account Clients
     * @param {string} clientId __Mandatory__. This must be your master client-id (and not one associated with one of your clients)
     * @param {string} [type] __Optional__.  Filter clients based on client type. One of BUSINESS or INDIVIDUAL
     * @param {string} [status] __Optional__.  Filter clients based on client status. One of ACTIVE, PENDING or SUSPENDED
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsClientsApi
     */
    public getVirtualAccountClients(clientId: string, type?: string, status?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsClientsApiFp(this.configuration).getVirtualAccountClients(clientId, type, status, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsPaymentsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountPayOut: async (idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'clientId', clientId)
            // verify required parameter 'virtualAccountPayOutRequest' is not null or undefined
            assertParamExists('createVirtualAccountPayOut', 'virtualAccountPayOutRequest', virtualAccountPayOutRequest)
            const localVarPath = `/virtual-accounts/payments/pay-outs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountPayOutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountTransfer: async (idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'clientId', clientId)
            // verify required parameter 'virtualAccountTransferRequest' is not null or undefined
            assertParamExists('createVirtualAccountTransfer', 'virtualAccountTransferRequest', virtualAccountTransferRequest)
            const localVarPath = `/virtual-accounts/payments/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayInDetails: async (paymentId: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayInDetails', 'paymentId', paymentId)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getPayInDetails', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments/{paymentId}/pay-in-details`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsById: async (id: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentsById', 'id', id)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getPaymentsById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountPayments: async (clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountPayments', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (createdDateTimeFrom !== undefined) {
                localVarQueryParameter['createdDateTimeFrom'] = (createdDateTimeFrom as any instanceof Date) ?
                    (createdDateTimeFrom as any).toISOString() :
                    createdDateTimeFrom;
            }

            if (createdDateTimeTo !== undefined) {
                localVarQueryParameter['createdDateTimeTo'] = (createdDateTimeTo as any instanceof Date) ?
                    (createdDateTimeTo as any).toISOString() :
                    createdDateTimeTo;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsPaymentsApi - functional programming interface
 * @export
 */
export const VirtualAccountsPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsPaymentsApi.createVirtualAccountPayOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsPaymentsApi.createVirtualAccountTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayInDetails(paymentId: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayInDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayInDetails(paymentId, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsPaymentsApi.getPayInDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsById(id: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsById(id, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsPaymentsApi.getPaymentsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsPaymentsApi.getVirtualAccountPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsPaymentsApi - factory interface
 * @export
 */
export const VirtualAccountsPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsPaymentsApiFp(configuration)
    return {
        /**
         * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
         * @summary Create Pay Out
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a transfer between two virtual accounts
         * @summary Create Virtual Account Transfer
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a pay-in transaction
         * @summary Get Pay-In Details
         * @param {string} paymentId Uniquely identifies a transaction
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayInDetails(paymentId: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayInDetails> {
            return localVarFp.getPayInDetails(paymentId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a specific payment using its Id
         * @summary Get Payment
         * @param {string} id __Mandatory__. The id of the payment
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsById(id: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountPayment> {
            return localVarFp.getPaymentsById(id, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of virtual account payments
         * @summary Get Payments
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [accountId] __Optional__. Filter payments based on accountId
         * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
         * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
         * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
         * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
         * @param {string} [cursor] __Optional__. Data required to provide pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountPayment> {
            return localVarFp.getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsPaymentsApi - object-oriented interface
 * @export
 * @class VirtualAccountsPaymentsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsPaymentsApi extends BaseAPI {
    /**
     * Initiate a payment from a specified virtual account to a previously added beneficiary using any of the schemes that it supports <br> When subscribed to virtualAccount.payOut.status notifications, further updates on payment processing status will be delivered asynchronously 
     * @summary Create Pay Out
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountPayOutRequest} virtualAccountPayOutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsPaymentsApi
     */
    public createVirtualAccountPayOut(idempotencyKey: string, clientId: string, virtualAccountPayOutRequest: VirtualAccountPayOutRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsPaymentsApiFp(this.configuration).createVirtualAccountPayOut(idempotencyKey, clientId, virtualAccountPayOutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a transfer between two virtual accounts
     * @summary Create Virtual Account Transfer
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountTransferRequest} virtualAccountTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsPaymentsApi
     */
    public createVirtualAccountTransfer(idempotencyKey: string, clientId: string, virtualAccountTransferRequest: VirtualAccountTransferRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsPaymentsApiFp(this.configuration).createVirtualAccountTransfer(idempotencyKey, clientId, virtualAccountTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a pay-in transaction
     * @summary Get Pay-In Details
     * @param {string} paymentId Uniquely identifies a transaction
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsPaymentsApi
     */
    public getPayInDetails(paymentId: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsPaymentsApiFp(this.configuration).getPayInDetails(paymentId, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a specific payment using its Id
     * @summary Get Payment
     * @param {string} id __Mandatory__. The id of the payment
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsPaymentsApi
     */
    public getPaymentsById(id: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsPaymentsApiFp(this.configuration).getPaymentsById(id, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of virtual account payments
     * @summary Get Payments
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [accountId] __Optional__. Filter payments based on accountId
     * @param {string} [createdDateTimeFrom] __Optional__. Filter payments based on the createdDateTime
     * @param {string} [createdDateTimeTo] __Optional__. Filter payments based on the createdDateTime
     * @param {Array<string>} [status] __Optional__. Filter payments based on the payment status. One of INITIATED, PENDING, PROCESSING, COMPLETED, FAILED
     * @param {Array<string>} [type] __Optional__. Filter payments based on the payment type. One of PAY_IN, PAY_OUT, RETURN_IN, RETURN_OUT
     * @param {string} [cursor] __Optional__. Data required to provide pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsPaymentsApi
     */
    public getVirtualAccountPayments(clientId: string, accountId?: string, createdDateTimeFrom?: string, createdDateTimeTo?: string, status?: Array<string>, type?: Array<string>, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsPaymentsApiFp(this.configuration).getVirtualAccountPayments(clientId, accountId, createdDateTimeFrom, createdDateTimeTo, status, type, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VirtualAccountsRefundsApi - axios parameter creator
 * @export
 */
export const VirtualAccountsRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountRefund: async (idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'clientId', clientId)
            // verify required parameter 'virtualAccountRefundRequest' is not null or undefined
            assertParamExists('createVirtualAccountRefund', 'virtualAccountRefundRequest', virtualAccountRefundRequest)
            const localVarPath = `/virtual-accounts/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(virtualAccountRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefundById: async (id: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVirtualAccountRefundById', 'id', id)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountRefundById', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/refunds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefunds: async (clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getVirtualAccountRefunds', 'clientId', clientId)
            const localVarPath = `/virtual-accounts/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (paymentInitiationId !== undefined) {
                localVarQueryParameter['paymentInitiationId'] = paymentInitiationId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdDateTimeAfter !== undefined) {
                localVarQueryParameter['createdDateTimeAfter'] = (createdDateTimeAfter as any instanceof Date) ?
                    (createdDateTimeAfter as any).toISOString() :
                    createdDateTimeAfter;
            }

            if (createdDateTimeBefore !== undefined) {
                localVarQueryParameter['createdDateTimeBefore'] = (createdDateTimeBefore as any instanceof Date) ?
                    (createdDateTimeBefore as any).toISOString() :
                    createdDateTimeBefore;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (clientId != null) {
                localVarHeaderParameter['client-id'] = String(clientId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualAccountsRefundsApi - functional programming interface
 * @export
 */
export const VirtualAccountsRefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualAccountsRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsRefundsApi.createVirtualAccountRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountRefundById(id: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountRefundById(id, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsRefundsApi.getVirtualAccountRefundById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiListResponseOfVirtualAccountRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VirtualAccountsRefundsApi.getVirtualAccountRefunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VirtualAccountsRefundsApi - factory interface
 * @export
 */
export const VirtualAccountsRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualAccountsRefundsApiFp(configuration)
    return {
        /**
         * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
         * @summary Create Refund
         * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: any): AxiosPromise<ApiResponseOfVirtualAccountRefund> {
            return localVarFp.createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a refund by its ID
         * @summary Get Refund By Id
         * @param {string} id __Mandatory__. The id of the refund
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefundById(id: string, clientId: string, options?: any): AxiosPromise<ApiResponseOfVirtualAccountRefund> {
            return localVarFp.getVirtualAccountRefundById(id, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of refunds
         * @summary Get list of refunds
         * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
         * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
         * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
         * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
         * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: any): AxiosPromise<ApiListResponseOfVirtualAccountRefund> {
            return localVarFp.getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VirtualAccountsRefundsApi - object-oriented interface
 * @export
 * @class VirtualAccountsRefundsApi
 * @extends {BaseAPI}
 */
export class VirtualAccountsRefundsApi extends BaseAPI {
    /**
     * Create a refund for a payment received into a virtual account. Funds are returned to the source account. When subscribed to `virtualAccount.refund.status` notifications, updates on the refund status are delivered asynchronously.
     * @summary Create Refund
     * @param {string} idempotencyKey Uniquely identifies a request, such that requests made with a same value are considered retries &lt;br&gt; We recommend that a v4 UUID is supplied 
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {VirtualAccountRefundRequest} virtualAccountRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsRefundsApi
     */
    public createVirtualAccountRefund(idempotencyKey: string, clientId: string, virtualAccountRefundRequest: VirtualAccountRefundRequest, options?: RawAxiosRequestConfig) {
        return VirtualAccountsRefundsApiFp(this.configuration).createVirtualAccountRefund(idempotencyKey, clientId, virtualAccountRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a refund by its ID
     * @summary Get Refund By Id
     * @param {string} id __Mandatory__. The id of the refund
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsRefundsApi
     */
    public getVirtualAccountRefundById(id: string, clientId: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsRefundsApiFp(this.configuration).getVirtualAccountRefundById(id, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of refunds
     * @summary Get list of refunds
     * @param {string} clientId The customer or sub-customer ID. Identifies the customer to perform the request for
     * @param {string} [paymentInitiationId] __Optional__. Filter refunds based on unique ID of the original payment
     * @param {string} [status] __Optional__.  Filter refunds based on refund status. One of INITIATED, SCHEDULED, PROCESSING, COMPLETED, FAILED
     * @param {string} [createdDateTimeAfter] __Optional__.  Filter to get refunds created on or after this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
     * @param {string} [createdDateTimeBefore] __Optional__.  Filter to get refunds created on or before this date (yyyy-MM-dd\&#39;T\&#39;HH:mm:ss.SSSZ)
     * @param {string} [cursor] __Optional__. Encoded pagination cursor to fetch next page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualAccountsRefundsApi
     */
    public getVirtualAccountRefunds(clientId: string, paymentInitiationId?: string, status?: string, createdDateTimeAfter?: string, createdDateTimeBefore?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return VirtualAccountsRefundsApiFp(this.configuration).getVirtualAccountRefunds(clientId, paymentInitiationId, status, createdDateTimeAfter, createdDateTimeBefore, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



